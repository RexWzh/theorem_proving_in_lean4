<!DOCTYPE HTML>
<html lang="zh" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Theorem Proving in Lean 4</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title_page.html">Lean 4中的定理证明</a></li><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> 引言</a></li><li class="chapter-item expanded "><a href="dependent_type_theory.html"><strong aria-hidden="true">2.</strong> 依赖类型论</a></li><li class="chapter-item expanded "><a href="propositions_and_proofs.html"><strong aria-hidden="true">3.</strong> 命题和证明</a></li><li class="chapter-item expanded "><a href="quantifiers_and_equality.html"><strong aria-hidden="true">4.</strong> 量词和相等</a></li><li class="chapter-item expanded "><a href="tactics.html"><strong aria-hidden="true">5.</strong> 策略</a></li><li class="chapter-item expanded "><a href="interacting_with_lean.html"><strong aria-hidden="true">6.</strong> 与Lean交互</a></li><li class="chapter-item expanded "><a href="inductive_types.html"><strong aria-hidden="true">7.</strong> 归纳类型</a></li><li class="chapter-item expanded "><a href="induction_and_recursion.html"><strong aria-hidden="true">8.</strong> 归纳和递归</a></li><li class="chapter-item expanded "><a href="structures_and_records.html"><strong aria-hidden="true">9.</strong> 结构和记录</a></li><li class="chapter-item expanded "><a href="type_classes.html"><strong aria-hidden="true">10.</strong> 类型类</a></li><li class="chapter-item expanded "><a href="conv.html"><strong aria-hidden="true">11.</strong> 转化策略模式</a></li><li class="chapter-item expanded "><a href="axioms_and_computation.html"><strong aria-hidden="true">12.</strong> 公理和计算</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Theorem Proving in Lean 4</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/RexWzh/theorem_proving_in_lean4" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="lean-4中的定理证明"><a class="header" href="#lean-4中的定理证明">Lean 4中的定理证明</a></h1>
<p><em>作者：Jeremy Avigad，Leonardo de Moura，Soonho Kong和Sebastian Ullrich，社区成员们贡献了这个版本的文本</em></p>
<p>本文的版本假定你正在使用Lean 4。请参考<a href="https://leanprover.github.io/lean4/doc/setup.html">Lean 4手册的安装指南</a>来安装Lean。这本书的第一个版本是为Lean 2写的，Lean 3的版本在<a href="https://leanprover.github.io/theorem_proving_in_lean/">这里</a>可用。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="引言"><a class="header" href="#引言">引言</a></h1>
<h2 id="计算机与定理证明"><a class="header" href="#计算机与定理证明">计算机与定理证明</a></h2>
<p><em>形式验证</em>涉及使用逻辑和计算方法来建立以确切的数学术语表达的声明。这些声明可以包括普通的数学定理，以及硬件或软件、网络协议、机械和混合系统符合其规范的声明。实际上，验证数学内容和验证系统正确性之间没有明确的界限：形式验证要求用数学术语描述硬件和软件系统，这时验证其正确性就变成了定理证明的一种形式。相反，数学定理的证明可能需要进行漫长的计算，这种情况下验证定理的真实性就需要验证计算是否按照预期进行。</p>
<p>支持数学断言的黄金标准是提供一个证明，在逻辑学的20世纪发展中，表明大多数，如果不是所有传统证明方法都可以归约为若干基础系统中的一小组公理和规则。通过这种归约，计算机可以帮助建立一个声明的两种方式：它可以帮助寻找一个证明，也可以帮助验证一个所谓的证明是正确的。</p>
<p><em>自动定理证明</em>专注于“寻找”方面。解析定理证明器、表格定理证明器、快速可满足性求解器等提供了在命题和一阶逻辑中建立公式有效性的方法。其他系统提供了针对特定语言和领域的搜索和决策过程，比如整数或实数上的线性或非线性表达式。像SMT（“可满足性模理论”）这样的体系结构结合了领域通用的搜索方法和领域特定的过程。计算机代数系统和专业的数学软件包提供了进行数学计算、建立数学边界或找到数学对象的方法。计算也可以看作是一种证明，这些系统也有助于建立数学断言。</p>
<p>自动推理系统追求强大和高效，常常以可靠性的代价。这些系统可能存在错误，很难确保它们提供的结果是正确的。相反，<em>交互定理证明</em>注重定理证明的“验证”方面，要求每个断言都必须有一个适当公理的证明来支持。这设置了一个非常高的标准：每个推理规则和每个步骤都必须经过证明，否则就无法接受。
为了证明计算的正确性，必须依据先前的定义和定理，一直追溯到基本公理和规则。事实上，大多数这样的系统提供了完整的“证明对象”，可以传递给其他系统进行独立检查。构建这样的证明通常需要用户提供更多的输入和交互，但它允许您获得更深入和更复杂的证明。</p>
<p><em>Lean 定理证明器</em>旨在弥合交互式和自动化定理证明之间的差距，通过将自动化工具和方法置于支持用户交互和构建完全规范化的公理证明的框架中。其目标是支持数学推理和复杂系统的推理，并验证在这两个领域中的断言。</p>
<p>Lean 的基本逻辑具有计算解释，因此 Lean 可以被看作一种编程语言。更重要的是，它可以被看作是一种具有精确语义的编写程序的系统，以及对程序计算的函数进行推理。Lean 还具有作为其自己的<em>元编程语言</em>的机制，这意味着可以使用 Lean 实现自动化，并使用 Lean 扩展 Lean 的功能。Lean 的这些方面在与本教程相伴的教程中进行了探讨，即<a href="TBD">在 Lean 4 中编程</a>，尽管该系统的计算方面也会在这里出现。</p>
<h2 id="关于-lean"><a class="header" href="#关于-lean">关于 Lean</a></h2>
<p><em>Lean</em> 项目由 Leonardo de Moura 在2013年于微软研究院 Redmond 发起。这是一个持续的、长期的努力，其中大部分自动化的潜力只会逐渐实现。Lean 以<a href="LICENSE">Apache 2.0 许可证</a>发布，这是一种自由的开源许可证，允许其他人自由使用和扩展代码和数学库。</p>
<p>要在计算机上安装 Lean，请使用<a href="https://github.com/leanprover/lean4/blob/master/doc/quickstart.md">快速入门</a>指南。Lean 的源代码和构建 Lean 的说明可在<a href="https://github.com/leanprover/lean4/">https://github.com/leanprover/lean4/</a>找到。</p>
<p>本教程描述的是当前版本的 Lean，即 Lean 4。</p>
<h2 id="关于本书"><a class="header" href="#关于本书">关于本书</a></h2>
<p>本书旨在教你在 Lean 中开发和验证证明。您将获得大部分背景信息，
为了完成这个任务，你需要掌握的知识并不仅限于 Lean 本身。首先，你将学习 Lean 所基于的逻辑系统，它是一个强大到可以证明几乎任何传统数学定理，同时又以自然方式表达这些定理的 <em>依赖类型论</em> 的版本。具体来说，Lean 是基于一个被称为带递归类型的构造演算的版本。Lean 不仅能够定义数学对象并在依赖类型论中表达数学断言，还可以作为写证明的语言。</p>
<p>由于完整的公理证明过程非常复杂，证明定理的挑战在于让计算机尽可能填充尽可能多的细节。你将学习各种支持这一过程的方法，包括<a href="dependent_type_theory.html">依赖类型论</a>中的术语重写、Lean 的自动化方法来简化术语和表达式，以及支持灵活形式的代数推理的规范化和类型推断方法。</p>
<p>最后，你还将学习一些 Lean 特有的功能，包括与系统交互的语言以及 Lean 提供的管理复杂理论和数据的机制。</p>
<p>在整个文本中，你会找到类似下面这样的 Lean 代码示例：</p>
<pre><code class="language-lean">theorem and_commutative (p q : Prop) : p ∧ q → q ∧ p :=
  fun hpq : p ∧ q =&gt;
  have hp : p := And.left hpq
  have hq : q := And.right hpq
  show q ∧ p from And.intro hq hp
</code></pre>
<p>如果您在 <a href="https://code.visualstudio.com/">VS Code</a> 中阅读这本书，您会看到一个名为 &quot;try it!&quot; 的按钮。点击这个按钮会将示例代码复制到编辑器中，并提供足够的上下文使代码正确编译。您可以在编辑器中输入内容并修改示例代码，Lean 会在您输入时持续检查结果并提供反馈。我们建议您在阅读后继章节时运行示例并尝试自己编写代码。您可以使用命令 &quot;Lean 4: Open Documentation View&quot; 在 VS Code 中打开本书。</p>
<h2 id="致谢"><a class="header" href="#致谢">致谢</a></h2>
<p>本教程是一个在 Github 上维护的开放存取项目。许多人为这个项目做出了贡献，提供了修正、建议、示例和文本。我们要感谢 Ulrik Buchholz、Kevin Buzzard、Mario Carneiro、Nathan
Carter、Eduardo Cavazos、Amine Chaieb、Joe Corneli、William DeMeo、Marcus Klaas de Vries、Ben Dyer、Gabriel Ebner、 Anthony Hart、Simon Hudon、Sean Leather、Assia Mahboubi、Gihan Marasingha、Patrick Massot、Christopher John Mazey、Sebastian Ullrich、Floris van Doorn、 Daniel Velleman、Théo Zimmerman、Paul Chisholm、Chris Lovett 和 Siddhartha Gadgil 对他们的贡献表示感谢。请参阅 <a href="https://github.com/leanprover/">lean prover</a> 和 <a href="https://github.com/leanprover-community/">lean community</a> 以获取我们杰出贡献者的最新列表。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="依赖类型理论"><a class="header" href="#依赖类型理论">依赖类型理论</a></h1>
<p>依赖类型理论是一种强大和表达力强的语言，您可以在其中表达复杂的数学断言，编写复杂的硬件和软件规范，并以一种自然和统一的方式进行推理。Lean基于一种称为“构造计算”的依赖类型理论的版本，其中有一个可数层次的非累积宇宙和归纳类型。通过本章的学习，您将对这些内容有深入的了解。</p>
<h2 id="简单类型理论"><a class="header" href="#简单类型理论">简单类型理论</a></h2>
<p>“类型理论”得名于每个表达式都有一个关联的<em>类型</em>。例如，在给定的上下文中，<code>x + 0</code> 可能表示一个自然数，而 <code>f</code> 可能表示自然数上的函数。对于那些喜欢精确定义的人来说，Lean中的自然数是一个任意精度的无符号整数。</p>
<p>以下是您可以在Lean中声明对象并检查它们类型的一些示例。</p>
<pre><code class="language-lean">/- Define some constants. -/

def m : Nat := 1       -- m is a natural number
def n : Nat := 0
def b1 : Bool := true  -- b1 is a Boolean
def b2 : Bool := false

/- Check their types. -/

#check m            -- output: Nat
#check n
#check n + 0        -- Nat
#check m * (n + 0)  -- Nat
#check b1           -- Bool
#check b1 &amp;&amp; b2     -- &quot;&amp;&amp;&quot; is the Boolean and
#check b1 || b2     -- Boolean or
#check true         -- Boolean &quot;true&quot;

/- Evaluate -/

#eval 5 * 4         -- 20
#eval m + 2         -- 3
#eval b1 &amp;&amp; b2      -- false
</code></pre>
<p>任何位于<code>/-</code>和<code>-/</code>之间的文本都被视为注释块，Lean会忽略它们。同样，两个短横线<code>--</code>表示该行剩余部分是注释，也会被忽略。注释块可以嵌套，这样可以像许多编程语言一样“注释掉”代码块。</p>
<p><code>def</code>关键字将新的常量符号声明到工作环境中。在上面的示例中，<code>def m : Nat := 1</code>定义了一个名为<code>m</code>的类型为<code>Nat</code>的新常量，其值为<code>1</code>。<code>#check</code>命令要求Lean报告它们的类型；在Lean中，查询系统信息的辅助命令通常以井号（#）符号开头。<code>#eval</code>命令要求Lean评估给定的表达式。你可以自己尝试声明一些常量和对一些表达式进行类型检查。以这种方式声明新对象是对系统进行实验的好方法。</p>
<p>简单类型理论的强大之处在于你可以用其他类型组合出新的类型。例如，如果<code>a</code>和<code>b</code>是类型，<code>a -&gt; b</code>表示从<code>a</code>到<code>b</code>的函数类型，<code>a × b</code>表示由<code>a</code>的元素和<code>b</code>的元素组成的对的类型，也被称为<em>笛卡尔积</em>。注意，<code>×</code>是一个Unicode符号。合理使用Unicode可以提高可读性，而且所有现代编辑器都对其有很好的支持。在Lean标准库中，经常使用希腊字母表示类型，使用Unicode符号<code>→</code>作为<code>-&gt;</code>的更紧凑版本。</p>
<pre><code class="language-lean">#check Nat → Nat      -- type the arrow as &quot;\to&quot; or &quot;\r&quot;
#check Nat -&gt; Nat     -- alternative ASCII notation

#check Nat × Nat      -- type the product as &quot;\times&quot;
#check Prod Nat Nat   -- alternative notation

#check Nat → Nat → Nat
#check Nat → (Nat → Nat)  --  same type as above

#check Nat × Nat → Nat
#check (Nat → Nat) → Nat -- a &quot;functional&quot;

#check Nat.succ     -- Nat → Nat
#check (0, 1)       -- Nat × Nat
#check Nat.add      -- Nat → Nat → Nat

#check Nat.succ 2   -- Nat
#check Nat.add 3    -- Nat → Nat
#check Nat.add 5 2  -- Nat
#check (5, 9).1     -- Nat
#check (5, 9).2     -- Nat

#eval Nat.succ 2   -- 3
#eval Nat.add 5 2  -- 7
#eval (5, 9).1     -- 5
#eval (5, 9).2     -- 9
</code></pre>
<p>再试试看一次你自己的例子。</p>
<p>让我们来看一些基本的语法。你可以通过输入<code>\to</code>或<code>\r</code>或<code>\-&gt;</code>来插入Unicode箭头<code>→</code>。你也可以使用ASCII替代形式<code>-&gt;</code>，因此表达式<code>Nat -&gt; Nat</code>和<code>Nat → Nat</code>的意思是相同的。这两个表达式都表示将自然数作为输入并返回自然数作为输出的函数类型。使用Unicode符号<code>×</code>表示笛卡尔积，输入方式为<code>\times</code>。通常你会使用小写希腊字母<code>α</code>、<code>β</code>和<code>γ</code>来表示类型的范围。你可以使用<code>\a</code>、<code>\b</code>和<code>\g</code>输入这些特定的字母。</p>
<p>这里还有一些需要注意的地方。首先，函数<code>f</code>应用到值<code>x</code>的表示方式是<code>f x</code>（例如，<code>Nat.succ 2</code>）。其次，在编写类型表达式时，箭头向<em>右</em>关联；例如，<code>Nat.add</code>的类型是<code>Nat → Nat → Nat</code>，它等同于<code>Nat → (Nat → Nat)</code>。因此，你可以将<code>Nat.add</code>看作是一个接受自然数并返回另一个接受自然数并返回自然数的函数。在类型理论中，这通常比将<code>Nat.add</code>编写为接受一对自然数作为输入并返回自然数作为输出的函数更方便。例如，它允许你对函数<code>Nat.add</code>进行“部分应用”。上面的示例说明了<code>Nat.add 3</code>的类型是<code>Nat → Nat</code>，也就是说，<code>Nat.add 3</code>返回一个“等待”第二个参数<code>n</code>的函数，等价于<code>Nat.add 3 n</code>。</p>
<!-- 将类型为``Nat × Nat → Nat``的函数``h``“重定义”为``g``是一种称为*柯里化*的过程。 -->
<p>你已经看到，如果有<code>m : Nat</code>和<code>n : Nat</code>，那么<code>(m, n)</code>表示<code>m</code>和<code>n</code>的有序对，其类型为
输入<code>Nat × Nat</code>。这样可以创建一对自然数。反过来，如果你有<code>p: Nat × Nat</code>，那么你可以写成<code>p.1: Nat</code>和<code>p.2: Nat</code>。这样可以提取出它的两个组成部分。</p>
<h2 id="类型作为对象"><a class="header" href="#类型作为对象">类型作为对象</a></h2>
<p>Lean的依赖类型理论扩展了简单类型理论的一种方法是，类型本身——如<code>Nat</code>和<code>Bool</code>——也是一等公民，也就是说它们本身也是对象。为了实现这一点，它们每一个也必须有一种类型。</p>
<pre><code class="language-lean">#check Nat               -- Type
#check Bool              -- Type
#check Nat → Bool        -- Type
#check Nat × Bool        -- Type
#check Nat → Nat         -- ...
#check Nat × Nat → Nat
#check Nat → Nat → Nat
#check Nat → (Nat → Nat)
#check Nat → Nat → Bool
#check (Nat → Nat) → Nat
</code></pre>
<p>你可以看到上面每个表达式都是一个“Type”类型的对象。你还可以声明新的类型常量：</p>
<pre><code class="language-lean">def α : Type := Nat
def β : Type := Bool
def F : Type → Type := List
def G : Type → Type → Type := Prod

#check α        -- Type
#check F α      -- Type
#check F Nat    -- Type
#check G α      -- Type → Type
#check G α β    -- Type
#check G α Nat  -- Type
</code></pre>
<p>正如上面的例子所示，您已经看到了一个类型为<code>Type → Type → Type</code>的函数的实例，即笛卡尔积<code>Prod</code>：</p>
<pre><code class="language-lean">def α : Type := Nat
def β : Type := Bool

#check Prod α β       -- Type
#check α × β          -- Type

#check Prod Nat Nat   -- Type
#check Nat × Nat      -- Type
</code></pre>
<p>这是另一个例子：给定任何类型<code>α</code>，类型<code>List α</code>表示类型<code>α</code>元素的列表的类型。</p>
<pre><code class="language-lean">def α : Type := Nat

#check List α    -- Type
#check List Nat  -- Type
</code></pre>
<p>鉴于Lean中的每个表达式都有一种类型，自然而然的是问：<code>Type</code>本身有什么类型？</p>
<pre><code class="language-lean">#check Type      -- Type 1
</code></pre>
<p>您实际上已经遇到了Lean类型系统中最微妙的一个方面。Lean的基础底层具有无限层次的类型：</p>
<pre><code class="language-lean">#check Type     -- Type 1
#check Type 1   -- Type 2
#check Type 2   -- Type 3
#check Type 3   -- Type 4
#check Type 4   -- Type 5
</code></pre>
<p>将<code>Type 0</code>看作“小型”或“普通”类型的宇宙。
<code>Type 1</code>则是一个更大的类型宇宙，它包含<code>Type 0</code>作为一个元素，而<code>Type 2</code>是一个更大的类型宇宙，它包含<code>Type 1</code>作为一个元素。列表是无限的，所以对于每个自然数<code>n</code>，都有一个<code>Type n</code>。<code>Type</code>是<code>Type 0</code>的缩写：</p>
<pre><code class="language-lean">#check Type
#check Type 0
</code></pre>
<p>以下的表格可能有助于具体说明所讨论的关系。</p>
<p>沿着x轴的运动代表了宇宙的变化，而沿着y轴的运动代表了所谓的“度”的变化。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center"></th><th style="text-align: center"></th><th style="text-align: center"></th><th style="text-align: center"></th><th style="text-align: center"></th><th style="text-align: center"></th></tr></thead><tbody>
<tr><td style="text-align: center">排序</td><td style="text-align: center">属性（排序0）</td><td style="text-align: center">类型（排序1）</td><td style="text-align: center">类型1（排序2）</td><td style="text-align: center">类型2（排序3）</td><td style="text-align: center">...</td></tr>
<tr><td style="text-align: center">类型</td><td style="text-align: center">True</td><td style="text-align: center">Bool</td><td style="text-align: center">自然数 -&gt; 类型</td><td style="text-align: center">类型 -&gt; 类型1</td><td style="text-align: center">...</td></tr>
<tr><td style="text-align: center">表达式</td><td style="text-align: center">平凡的</td><td style="text-align: center">真</td><td style="text-align: center">λn =&gt; 终态n</td><td style="text-align: center">λ_ : 类型 =&gt; 类型</td><td style="text-align: center">...</td></tr>
</tbody></table>
</div>
<p>然而，一些操作需要对类型宇宙进行<em>多态</em>处理。例如，“List α”应该对于任何类型“α”都有意义，无论“α”位于哪个类型宇宙中。这解释了函数“List”的类型注释：</p>
<pre><code class="language-lean">#check List    -- Type u_1 → Type u_1
</code></pre>
<p>在这里，<code>u_1</code>是一个范围在类型级别上的变量。<code>#check</code>命令的输出表明，只要<code>α</code>具有类型<code>Type n</code>，那么<code>List α</code>也具有类型<code>Type n</code>。函数<code>Prod</code>同样是多态的：</p>
<pre><code class="language-lean">#check Prod    -- Type u_1 → Type u_2 → Type (max u_1 u_2)
</code></pre>
<p>要定义多态常量，Lean允许你使用<code>universe</code>命令来显式地声明宇宙变量：</p>
<pre><code class="language-lean">universe u

def F (α : Type u) : Type u := Prod α α

#check F    -- Type u → Type u
</code></pre>
<p>当定义 F 时，您可以通过提供宇宙参数来避免使用 universe 命令。</p>
<pre><code class="language-lean">def F.{u} (α : Type u) : Type u := Prod α α

#check F    -- Type u → Type u
</code></pre>
<h2 id="函数抽象和评估"><a class="header" href="#函数抽象和评估">函数抽象和评估</a></h2>
<p>Lean提供了<code>fun</code>（或<code>λ</code>）关键字来从表达式中创建一个函数，如下所示：</p>
<pre><code class="language-lean">#check fun (x : Nat) =&gt; x + 5   -- Nat → Nat
#check λ (x : Nat) =&gt; x + 5     -- λ and fun mean the same thing
#check fun x : Nat =&gt; x + 5     -- Nat inferred
#check λ x : Nat =&gt; x + 5       -- Nat inferred
</code></pre>
<p>您可以通过传递所需的参数来评估 lambda 函数：</p>
<pre><code class="language-lean">#eval (λ x : Nat =&gt; x + 5) 10    -- 15
</code></pre>
<p>将另一个表达式创建为函数的过程称为<em>lambda抽象</em>。假设您有变量<code>x : α</code>，并且可以构建表达式<code>t : β</code>，那么表达式<code>fun (x : α) =&gt; t</code>，或等价地说，<code>λ (x : α) =&gt; t</code>，是类型为<code>α → β</code>的对象。可以将其视为从<code>α</code>到<code>β</code>的函数，将任何值<code>x</code>映射到值<code>t</code>。</p>
<p>以下是一些更多示例</p>
<pre><code class="language-lean">#check fun x : Nat =&gt; fun y : Bool =&gt; if not y then x + 1 else x + 2
#check fun (x : Nat) (y : Bool) =&gt; if not y then x + 1 else x + 2
#check fun x y =&gt; if not y then x + 1 else x + 2   -- Nat → Bool → Nat
</code></pre>
<p>Lean将最后三个例子解释为相同的表达式；在最后一个表达式中，Lean从表达式“如果不是y，则x + 1，否则x + 2“中推断出<code>x</code>和<code>y</code>的类型。</p>
<p>一些在数学中常见的函数操作示例可以用lambda抽象来描述：</p>
<pre><code class="language-lean">def f (n : Nat) : String := toString n
def g (s : String) : Bool := s.length &gt; 0

#check fun x : Nat =&gt; x        -- Nat → Nat
#check fun x : Nat =&gt; true     -- Nat → Bool
#check fun x : Nat =&gt; g (f x)  -- Nat → Bool
#check fun x =&gt; g (f x)        -- Nat → Bool
</code></pre>
<p>思考一下这些表达式的含义。表达式<code>fun x : Nat =&gt; x</code>代表了<code>Nat</code>上的恒等函数，表达式<code>fun x : Nat =&gt; true</code>代表了始终返回<code>true</code>的常数函数，而<code>fun x : Nat =&gt; g (f x)</code>代表了<code>f</code>和<code>g</code>的复合函数。通常情况下，你可以省略类型注释，让Lean来自动推断。因此，例如，你可以写成<code>fun x =&gt; g (f x)</code>而不是<code>fun x : Nat =&gt; g (f x)</code>。</p>
<p>你可以将函数作为参数传递，并通过给它们命名为<code>f</code>和<code>g</code>来在实现中使用这些函数：</p>
<pre><code class="language-lean">#check fun (g : String → Bool) (f : Nat → String) (x : Nat) =&gt; g (f x)
-- (String → Bool) → (Nat → String) → Nat → Bool
</code></pre>
<p>您还可以将类型作为参数传递：</p>
<pre><code class="language-lean">#check fun (α β γ : Type) (g : β → γ) (f : α → β) (x : α) =&gt; g (f x)
</code></pre>
<p>最后一个表达式，例如，表示一个接受三个类型<code>α</code>，<code>β</code>和<code>γ</code>，以及两个函数<code>g：β→γ</code>和<code>f：α→β</code>的函数，并返回<code>g</code>和<code>f</code>的复合函数。（理解该函数的类型需要了解依赖积，下文将对其进行解释。）</p>
<p>λ表达式的一般形式是<code>fun x：α =&gt; t</code>，其中变量<code>x</code>是一个“绑定变量”：它实际上是一个占位符，其“作用域”不延伸到表达式<code>t</code>之外。例如，表达式<code>fun（b：β）（x：α）=&gt; b</code>中的变量<code>b</code>与之前声明的常量<code>b</code>无关。事实上，该表达式表示与<code>fun（u：β）（z：α）=&gt; u</code>相同的函数。</p>
<p>形式上，对于通过重新命名绑定变量可以相同的表达式称为“α等价”，并被认为是“相同的”。Lean识别这种等价性。</p>
<p>注意，将项<code>t：α→β</code>应用到项<code>s：α</code>上会得到一个表达式<code>t s：β</code>。回到前面的例子并为了清晰起见对绑定变量重新命名，注意以下表达式的类型：</p>
<pre><code class="language-lean">#check (fun x : Nat =&gt; x) 1     -- Nat
#check (fun x : Nat =&gt; true) 1  -- Bool

def f (n : Nat) : String := toString n
def g (s : String) : Bool := s.length &gt; 0

#check
  (fun (α β γ : Type) (u : β → γ) (v : α → β) (x : α) =&gt; u (v x)) Nat String Bool g f 0
  -- Bool
</code></pre>
<p>如预期，表达式 <code>(fun x : Nat =&gt;  x) 1</code> 的类型是 <code>Nat</code>。
事实上，更多的是这样：将表达式 <code>(fun x : Nat =&gt; x)</code> 应用于 <code>1</code> 应该会“返回”值 <code>1</code>。而且，的确如此：</p>
<pre><code class="language-lean">#eval (fun x : Nat =&gt; x) 1     -- 1
#eval (fun x : Nat =&gt; true) 1  -- true
</code></pre>
<p>你将会看到这些术语是如何评估的。现在，请注意，这是依赖类型理论的一个重要特征：每个术语都具有计算行为，并支持一种<em>归约化</em>概念。原则上，归约到相同值的两个术语被称为<em>定义上相等</em>。它们被 Lean 的类型检查器视为&quot;相同&quot;，而 Lean 尽其所能识别和支持这些等同。</p>
<p>Lean 是一种完整的编程语言。它有一个生成二进制可执行文件和一个交互式解释器的编译器。你可以使用 <code>#eval</code> 命令执行表达式，这是测试函数的首选方法。</p>
<!--
请注意，`#eval` 和 `#reduce` *不是*等价的。`#eval` 命令首先将 Lean 表达式编译成中间表示（IR），然后使用解释器执行生成的 IR。一些内建类型（例如`Nat`、`String`、`Array`）在 IR 中具有更高效的表示。IR 支持使用 Lean 并不透明的外部函数。

相比之下，``#reduce`` 命令依赖于与 Lean 可信核心中使用的那个相似的归约引擎，该核心负责检查和验证表达式和证明的正确性。它比 ``#eval`` 更低效，并将所有外部函数视为不透明常量。稍后您将了解这两个命令之间的其他差异。
-->
<h2 id="定义"><a class="header" href="#定义">定义</a></h2>
<p>记住，<code>def</code> 关键字提供了一种声明新命名对象的重要方式。</p>
<pre><code class="language-lean">def double (x : Nat) : Nat :=
  x + x
</code></pre>
<p>如果你了解其他编程语言中的函数工作方式，这样可能更容易理解。名称“double”被定义为接受类型为“Nat”的输入参数“x”的函数，调用的结果是“x + x”，因此它返回类型为“Nat”。然后，您可以使用以下方法调用此函数：</p>
<pre><code class="language-lean"># def double (x : Nat) : Nat :=
#  x + x
#eval double 3    -- 6
</code></pre>
<p>在这种情况下，您可以将<code>def</code>视为一种命名的<code>lambda</code>。
下面的代码会产生相同的结果：</p>
<pre><code class="language-lean">def double : Nat → Nat :=
  fun x =&gt; x + x

#eval double 3    -- 6
</code></pre>
<p>当Lean有足够信息可以推断出类型时，您可以省略类型声明。类型推断是Lean的重要部分。</p>
<pre><code class="language-lean">def double :=
  fun (x : Nat) =&gt; x + x
</code></pre>
<p>定义的一般形式是 <code>def foo : α := bar</code>，其中 <code>α</code> 是从表达式 <code>bar</code> 返回的类型。Lean 通常可以推断出类型 <code>α</code>，但明确写出它通常是一个好主意。这样可以明确你的意图，如果定义的右侧没有匹配的类型，Lean 会报错。</p>
<p>右侧的 <code>bar</code> 可以是任何表达式，不仅仅是一个 lambda。因此，<code>def</code> 也可用于简单地命名一个值，如下所示：</p>
<pre><code class="language-lean">def pi := 3.141592654
</code></pre>
<p><code>def</code> 可以接收多个输入参数。让我们创建一个能够将两个自然数相加的函数：</p>
<pre><code class="language-lean">def add (x y : Nat) :=
  x + y

#eval add 3 2               -- 5
</code></pre>
<p>参数列表可以这样分隔：</p>
<pre><code class="language-lean"># def double (x : Nat) : Nat :=
#  x + x
def add (x : Nat) (y : Nat) :=
  x + y

#eval add (double 3) (7 + 9)  -- 22
</code></pre>
<p>请注意，我们在这里调用了<code>double</code>函数来创建<code>add</code>函数的第一个参数。</p>
<p>您可以在<code>def</code>之内使用其他更有趣的表达式。</p>
<pre><code class="language-lean">def greater (x y : Nat) :=
  if x &gt; y then x
  else y
</code></pre>
<p>您可以猜到这个会做什么。</p>
<p>您还可以定义一个以另一个函数作为输入的函数。
以下代码调用给定的函数两次，将第一次调用的输出传递给第二次调用的函数：</p>
<pre><code class="language-lean"># def double (x : Nat) : Nat :=
#  x + x
def doTwice (f : Nat → Nat) (x : Nat) : Nat :=
  f (f x)

#eval doTwice double 2   -- 8
</code></pre>
<p>现在来稍微抽象一点，你也可以指定类似类型参数的参数：</p>
<pre><code class="language-lean">def compose (α β γ : Type) (g : β → γ) (f : α → β) (x : α) : γ :=
  g (f x)
</code></pre>
<p>这意味着 <code>compose</code> 是一个函数，它以任意两个函数作为输入参数，只要这些函数都只接受一个输入。
类型代数 <code>β → γ</code> 和 <code>α → β</code> 意味着第二个函数的输出类型必须与第一个函数的输入类型匹配 - 这是有道理的，否则这两个函数将无法组合。</p>
<p><code>compose</code> 还接受第三个参数，类型为 <code>α</code>，它用于调用第二个函数（本地命名为 <code>f</code>），并将该函数的结果（类型为 <code>β</code>）作为输入传递给第一个函数（本地命名为 <code>g</code>）。第一个函数返回类型 <code>γ</code>，因此它也是 <code>compose</code> 函数的返回类型。</p>
<p><code>compose</code> 还非常通用，可以适用于任何类型 <code>α β γ</code>。这意味着 <code>compose</code> 可以组合几乎任何两个函数，只要它们每个函数都只接受一个参数，并且第二个函数的输出类型与第一个函数的输入类型匹配。例如：</p>
<pre><code class="language-lean"># def compose (α β γ : Type) (g : β → γ) (f : α → β) (x : α) : γ :=
#  g (f x)
# def double (x : Nat) : Nat :=
#  x + x
def square (x : Nat) : Nat :=
  x * x

#eval compose Nat Nat Nat double square 3  -- 18
</code></pre>
<h2 id="本地定义"><a class="header" href="#本地定义">本地定义</a></h2>
<p>Lean 还允许您使用 <code>let</code> 关键字引入“本地”定义。表达式 <code>let a := t1; t2</code> 在定义上等于通过将 <code>t2</code> 中的每个出现的 <code>a</code> 替换为 <code>t1</code> 的结果。</p>
<pre><code class="language-lean">#check let y := 2 + 2; y * y   -- Nat
#eval  let y := 2 + 2; y * y   -- 16

def twice_double (x : Nat) : Nat :=
  let y := x + x; y * y

#eval twice_double 2   -- 16
</code></pre>
<p>在这里，<code>twice_double x</code> 在定义上等于 <code>(x + x) * (x + x)</code>。</p>
<p>您可以通过链接 <code>let</code> 语句来组合多个赋值：</p>
<pre><code class="language-lean">#check let y := 2 + 2; let z := y + y; z * z   -- Nat
#eval  let y := 2 + 2; let z := y + y; z * z   -- 64
</code></pre>
<p>当使用换行符时，可以省略<code>;</code>。</p>
<pre><code class="language-lean">def t (x : Nat) : Nat :=
  let y := x + x
  y * y
</code></pre>
<p>请注意，表达式<code>let a := t1; t2</code>的含义与表达式<code>(fun a =&gt; t2) t1</code>非常相似，但两者并不相同。在第一个表达式中，你应该将<code>t2</code>中的每个<code>a</code>实例视为<code>t1</code>的一种语法缩写。在第二个表达式中，<code>a</code>是一个变量，且<code>fun a =&gt; t2</code>表达式必须独立于<code>a</code>的值而有意义。<code>let</code>结构是一种更强的缩写方法，存在着<code>let a := t1; t2</code>的形式表达式，无法表示为<code>(fun a =&gt; t2) t1</code>。作为练习，尝试理解为什么下面的<code>foo</code>定义可以通过类型检查，但<code>bar</code>定义不能。</p>
<pre><code class="language-lean">def foo := let a := Nat; fun x : a =&gt; x + 2
/-
  def bar := (fun a =&gt; fun x : a =&gt; x + 2) Nat
-/
</code></pre>
<h1 id="变量和部分"><a class="header" href="#变量和部分">变量和部分</a></h1>
<p>考虑以下三个函数定义:</p>
<pre><code class="language-lean">def compose (α β γ : Type) (g : β → γ) (f : α → β) (x : α) : γ :=
  g (f x)

def doTwice (α : Type) (h : α → α) (x : α) : α :=
  h (h x)

def doThrice (α : Type) (h : α → α) (x : α) : α :=
  h (h (h x))
</code></pre>
<p>Lean提供了<code>variable</code>命令，使这样的声明看起来更简洁：</p>
<pre><code class="language-lean">variable (α β γ : Type)

def compose (g : β → γ) (f : α → β) (x : α) : γ :=
  g (f x)

def doTwice (h : α → α) (x : α) : α :=
  h (h x)

def doThrice (h : α → α) (x : α) : α :=
  h (h (h x))
</code></pre>
<p>你可以声明任何类型的变量，不仅仅是<code>Type</code>本身：</p>
<pre><code class="language-lean">variable (α β γ : Type)
variable (g : β → γ) (f : α → β) (h : α → α)
variable (x : α)

def compose := g (f x)
def doTwice := h (h x)
def doThrice := h (h (h x))

#print compose
#print doTwice
#print doThrice
</code></pre>
<p>打印它们会发现这三组定义具有完全相同的效果。</p>
<p><code>variable</code>命令指示Lean将已声明的变量按名称作为绑定变量插入到引用它们的定义中。Lean足够聪明以确定在定义中明确或隐式使用的变量。因此，当你编写定义时，可以将<code>α</code>、<code>β</code>、<code>γ</code>、<code>g</code>、<code>f</code>、<code>h</code>和<code>x</code>视为固定对象，并让Lean自动为你抽象定义。</p>
<p>以这种方式声明的变量将在您正在使用的文件的末尾保持有效范围。然而，有时候限制变量的范围是有用的。因此，Lean提供了<code>section</code>的概念：</p>
<pre><code class="language-lean">section useful
  variable (α β γ : Type)
  variable (g : β → γ) (f : α → β) (h : α → α)
  variable (x : α)

  def compose := g (f x)
  def doTwice := h (h x)
  def doThrice := h (h (h x))
end useful
</code></pre>
<p>当部分关闭时，变量超出作用域，不能再被引用。</p>
<p>您不必对部分中的行进行缩进。您也不必为部分命名，也就是说，您可以使用一个匿名的 &quot;section&quot; / &quot;end&quot; 对。但是，如果您命名了一个部分，那么您必须使用相同的名称关闭它。部分也可以嵌套，这使您可以逐步声明新的变量。</p>
<h1 id="命名空间"><a class="header" href="#命名空间">命名空间</a></h1>
<p>Lean 为您提供将定义分组到嵌套的分层 &quot;命名空间&quot; 中的能力：</p>
<pre><code class="language-lean">namespace Foo
  def a : Nat := 5
  def f (x : Nat) : Nat := x + 7

  def fa : Nat := f a
  def ffa : Nat := f (f a)

  #check a
  #check f
  #check fa
  #check ffa
  #check Foo.fa
end Foo

-- #check a  -- error
-- #check f  -- error
#check Foo.a
#check Foo.f
#check Foo.fa
#check Foo.ffa

open Foo

#check a
#check f
#check fa
#check Foo.fa
</code></pre>
<p>当你声明你正在使用命名空间<code>Foo</code>时，你声明的每个标识符都有一个以&quot;<code>Foo.</code>&quot;为前缀的全名。在命名空间内，你可以通过更短的名称引用标识符，但是一旦你结束了命名空间，就必须使用更长的名称。
与<code>section</code>不同，命名空间需要一个名称。在根级别只有一个匿名命名空间。</p>
<p><code>open</code>命令将较短的名称带入当前上下文中。通常，当您导入一个模块时，您会想要打开其中一个或多个包含的命名空间，以便访问短标识符。但有时，当它们与您想要使用的另一个命名空间中的标识符发生冲突时，您可能希望将此信息保护在完全限定的名称中。因此，命名空间为您提供了在工作环境中管理名称的方法。</p>
<p>例如，Lean将涉及列表的定义和定理分组到一个名为<code>List</code>的命名空间中。</p>
<pre><code class="language-lean">#check List.nil
#check List.cons
#check List.map
</code></pre>
<p>命令“打开列表”允许您使用较短的名称：</p>
<pre><code class="language-lean">open List

#check nil
#check cons
#check map
</code></pre>
<p>与章节类似，命名空间可以嵌套：</p>
<pre><code class="language-lean">namespace Foo
  def a : Nat := 5
  def f (x : Nat) : Nat := x + 7

  def fa : Nat := f a

  namespace Bar
    def ffa : Nat := f (f a)

    #check fa
    #check ffa
  end Bar

  #check fa
  #check Bar.ffa
end Foo

#check Foo.fa
#check Foo.Bar.ffa

open Foo

#check fa
#check Bar.ffa
</code></pre>
<p>已关闭的命名空间可以在以后重新打开，甚至在另一个文件中：</p>
<pre><code class="language-lean">namespace Foo
  def a : Nat := 5
  def f (x : Nat) : Nat := x + 7

  def fa : Nat := f a
end Foo

#check Foo.a
#check Foo.f

namespace Foo
  def ffa : Nat := f (f a)
end Foo
</code></pre>
<p>像章节一样，嵌套的命名空间必须按照打开的顺序闭合。命名空间和章节有不同的用途：命名空间用于组织数据，而章节用于声明插入定义的变量。章节还可用于限定诸如&quot;set_option&quot;和&quot;open&quot;之类命令的作用范围。</p>
<p>然而，在很多方面，&quot;namespace ... end&quot;块与&quot;section ... end&quot;块的行为相同。特别是，如果在命名空间中使用&quot;variable&quot;命令，其作用域限制于该命名空间。类似地，如果在命名空间中使用&quot;open&quot;命令，其效果将在命名空间关闭时消失。</p>
<h2 id="何为依赖类型理论的依赖之处"><a class="header" href="#何为依赖类型理论的依赖之处">何为依赖类型理论的&quot;依赖&quot;之处？</a></h2>
<p>简单解释就是，类型可以依赖于参数。你已经看到了一个很好的例子：类型&quot;List α&quot;依赖于参数&quot;α&quot;，而这种依赖性正是&quot;List Nat&quot;和&quot;List Bool&quot;之间的区别所在。再举一个例子，考虑类型&quot;Vector α n&quot;，表示长度为&quot;n&quot;的由&quot;α&quot;类型元素构成的向量。这个类型依赖于<em>两个</em>参数：向量中元素的类型(&quot;α : Type&quot;)以及向量的长度(&quot;n : Nat&quot;)。</p>
<p>假设你希望编写一个名为&quot;cons&quot;的函数，它可以将一个新元素插入到列表的头部。那么&quot;cons&quot;应该具有什么类型？这样的函数是<em>多态的</em>：你期望对于&quot;Nat&quot;、&quot;Bool&quot;或任意类型&quot;α&quot;，&quot;cons&quot;函数的行为都相同。因此，将类型作为&quot;cons&quot;的第一个参数是有道理的，这样对于任何类型&quot;α&quot;，&quot;cons α&quot;就是类型为&quot;α&quot;的列表插入函数。换句话说，对于每个&quot;α&quot;，&quot;cons α&quot;是一个接受元素&quot;a : α&quot;和列表&quot;as : List α&quot;，并返回一个新列表的函数，因此你有&quot;cons α a as : List α&quot;。</p>
<p>很明显，&quot;cons α&quot;应该具有类型&quot;α → List α → List α&quot;。但是&quot;cons&quot;应该具有什么类型呢？第一个猜测可能是&quot;Type → α → list α → list α&quot;，但仔细思考后，这并不是合适的类型。
观点：这个表达式中的<code>α</code>并不指代任何东西，而应该指代类型<code>Type</code>的参数。换句话说，<em>假设</em>函数的第一个参数是<code>α : Type</code>，那么接下来的两个元素的类型分别是<code>α</code>和<code>List α</code>。这些类型会根据第一个参数<code>α</code>的变化而变化。</p>
<pre><code class="language-lean">def cons (α : Type) (a : α) (as : List α) : List α :=
  List.cons a as

#check cons Nat        -- Nat → List Nat → List Nat
#check cons Bool       -- Bool → List Bool → List Bool
#check cons            -- (α : Type) → α → List α → List α
</code></pre>
<p>这是<em>依赖函数类型</em>或<em>依赖箭头类型</em>的一个示例。给定<code>α：Type</code>和<code>β：α → Type</code>，可以将<code>β</code>看作是<code>α</code>上的一组类型，即为每个<code>a：α</code>定义一个类型<code>β a</code>。在这种情况下，类型<code>(a：α) → β a</code>表示具有以下性质的函数<code>f</code>的类型：对于每个<code>a：α</code>，<code>f a</code> 是<code>β a</code>的一个元素。换句话说，函数<code>f</code>返回的值的类型取决于其输入。</p>
<p>注意，对于任何表达式<code>β：Type</code>，表达式<code>(a：α) → β</code>都是有意义的。当<code>β</code>依赖于<code>a</code>（例如前一段中的表达式<code>β a</code>）时，<code>(a：α) → β</code>表示了一个依赖函数类型。而当<code>β</code>不依赖于<code>a</code>时，<code>(a：α) → β</code>与类型<code>α → β</code>没有区别。实际上，在依赖类型理论（以及 Lean）中，当<code>β</code>不依赖于<code>a</code>时，<code>α → β</code>只是<code>(a：α) → β</code>的一种记法。</p>
<p>回到列表的示例，您可以使用<code>#check</code>命令来检查以下<code>List</code>函数的类型。<code>@</code>符号以及圆括号和花括号之间的区别将在接下来解释。</p>
<pre><code class="language-lean">#check @List.cons    -- {α : Type u_1} → α → List α → List α
#check @List.nil     -- {α : Type u_1} → List α
#check @List.length  -- {α : Type u_1} → List α → Nat
#check @List.append  -- {α : Type u_1} → List α → List α → List α
</code></pre>
<p>正如依赖函数类型 <code>(a : α) → β a</code> 通过允许 <code>β</code> 依赖于 <code>α</code>，泛化了函数类型 <code>α → β</code> 的概念，依赖笛卡尔积类型 <code>(a : α) × β a</code> 以相同的方式泛化了笛卡尔积 <code>α × β</code>。依赖积类型也被称为 <em>sigma</em> 类型，你也可以将它们写作 <code>Σ a : α, β a</code>。你可以使用 <code>⟨a, b⟩</code> 或 <code>Sigma.mk a b</code> 来创建一个依赖对。</p>
<pre><code class="language-lean">universe u v

def f (α : Type u) (β : α → Type v) (a : α) (b : β a) : (a : α) × β a :=
  ⟨a, b⟩

def g (α : Type u) (β : α → Type v) (a : α) (b : β a) : Σ a : α, β a :=
  Sigma.mk a b

def h1 (x : Nat) : Nat :=
  (f Type (fun α =&gt; α) Nat x).2

#eval h1 5 -- 5

def h2 (x : Nat) : Nat :=
  (g Type (fun α =&gt; α) Nat x).2

#eval h2 5 -- 5
</code></pre>
<p>上述的函数 <code>f</code> 和 <code>g</code> 表示相同的函数。</p>
<h2 id="隐式参数"><a class="header" href="#隐式参数">隐式参数</a></h2>
<p>假设我们有一个列表的实现，如下所示：</p>
<pre><code class="language-lean"># universe u
# def Lst (α : Type u) : Type u := List α
# def Lst.cons (α : Type u) (a : α) (as : Lst α) : Lst α := List.cons a as
# def Lst.nil (α : Type u) : Lst α := List.nil
# def Lst.append (α : Type u) (as bs : Lst α) : Lst α := List.append as bs
#check Lst          -- Type u_1 → Type u_1
#check Lst.cons     -- (α : Type u_1) → α → Lst α → Lst α
#check Lst.nil      -- (α : Type u_1) → Lst α
#check Lst.append   -- (α : Type u_1) → Lst α → Lst α → Lst α
</code></pre>
<p>然后，您可以按照以下方式构建<code>Nat</code>的列表。</p>
<pre><code class="language-lean"># universe u
# def Lst (α : Type u) : Type u := List α
# def Lst.cons (α : Type u) (a : α) (as : Lst α) : Lst α := List.cons a as
# def Lst.nil (α : Type u) : Lst α := List.nil
# def Lst.append (α : Type u) (as bs : Lst α) : Lst α := List.append as bs
# #check Lst          -- Type u_1 → Type u_1
# #check Lst.cons     -- (α : Type u_1) → α → Lst α → Lst α
# #check Lst.nil      -- (α : Type u_1) → Lst α
# #check Lst.append   -- (α : Type u_1) → Lst α → Lst α → Lst α
#check Lst.cons Nat 0 (Lst.nil Nat)

def as : Lst Nat := Lst.nil Nat
def bs : Lst Nat := Lst.cons Nat 5 (Lst.nil Nat)

#check Lst.append Nat as bs
</code></pre>
<p>因为构造函数在类型上是多态的，我们不得不反复插入类型“Nat”作为参数。但是这些信息是冗余的：可以推断出参数“α”是“Lst.cons Nat 5 (Lst.nil Nat)”这个表达式的第一个参数，因为第二个参数“5”的类型是“Nat”。类似地，可以从“Lst.cons”函数期望在该位置有一个类型为“Lst α”的元素这一事实推断出“Lst.nil Nat”中的参数，而不是从该表达式中的其他任何信息中推断出来。</p>
<p>这是依赖类型理论的一个核心特点：项携带了大量信息，并且通常可以从上下文中推断出其中一些信息。在Lean中，可以使用下划线“_”来指定系统应该自动填充信息。这被称为“隐式参数”。</p>
<pre><code class="language-lean"># universe u
# def Lst (α : Type u) : Type u := List α
# def Lst.cons (α : Type u) (a : α) (as : Lst α) : Lst α := List.cons a as
# def Lst.nil (α : Type u) : Lst α := List.nil
# def Lst.append (α : Type u) (as bs : Lst α) : Lst α := List.append as bs
# #check Lst          -- Type u_1 → Type u_1
# #check Lst.cons     -- (α : Type u_1) → α → Lst α → Lst α
# #check Lst.nil      -- (α : Type u_1) → Lst α
# #check Lst.append   -- (α : Type u_1) → Lst α → Lst α → Lst α
#check Lst.cons _ 0 (Lst.nil _)

def as : Lst Nat := Lst.nil _
def bs : Lst Nat := Lst.cons _ 5 (Lst.nil _)

#check Lst.append _ as bs
</code></pre>
<p>这仍然是繁琐的，然而，要键入所有这些下划线。当函数接受一个通常可以从上下文中推断出的参数时，Lean允许您指定该参数默认情况下应该保留为隐式。这可以通过将参数放置在花括号中来完成，如下所示：</p>
<pre><code class="language-lean">universe u
def Lst (α : Type u) : Type u := List α

def Lst.cons {α : Type u} (a : α) (as : Lst α) : Lst α := List.cons a as
def Lst.nil {α : Type u} : Lst α := List.nil
def Lst.append {α : Type u} (as bs : Lst α) : Lst α := List.append as bs

#check Lst.cons 0 Lst.nil

def as : Lst Nat := Lst.nil
def bs : Lst Nat := Lst.cons 5 Lst.nil

#check Lst.append as bs
</code></pre>
<p>所做的改变仅限于在声明变量时将“α：Type u”用大括号括起来。我们还可以在函数定义中使用这种语法：</p>
<pre><code class="language-lean">universe u
def ident {α : Type u} (x : α) := x

#check ident         -- ?m → ?m
#check ident 1       -- Nat
#check ident &quot;hello&quot; -- String
#check @ident        -- {α : Type u_1} → α → α
</code></pre>
<p>这使得给 <code>ident</code> 的第一个参数隐式。符号上，这隐藏了类型的规格，使其看起来好像 <code>ident</code> 只是简单地接受任意类型的参数。事实上，标准库中的函数 <code>id</code> 就是以这种方式精确定义的。我们在这里选择了一个非传统的名称，只是为了避免名称冲突。</p>
<p>当使用 <code>variable</code> 命令声明变量时，变量也可以被指定为隐式的：</p>
<pre><code class="language-lean">universe u

section
  variable {α : Type u}
  variable (x : α)
  def ident := x
end

#check ident
#check ident 4
#check ident &quot;hello&quot;
</code></pre>
<p>这里对“ident”的定义与上面的定义有相同的效果。</p>
<p>Lean 对于实例化隐含参数有非常复杂的机制，我们将看到它们可以用来推断函数类型、谓词甚至证明。实例化术语中的这些“洞”或“占位符”的过程通常被称为<em>推导</em>。隐含参数的存在意味着有时可能没有足够的信息来精确确定表达式的含义。像“id”或“List.nil”这样的表达式被称为<em>多态</em>，因为它们可以在不同的上下文中具有不同的含义。</p>
<p>可以通过写成“(e : T)”来指定表达式“e”的类型“T”。这指示 Lean 的推导器在尝试解析隐含参数时使用值“T”作为“e”的类型。在下面的第二组示例中，这一机制被用来指定表达式“id”和“List.nil”的期望类型：</p>
<pre><code class="language-lean">#check List.nil               -- List ?m
#check id                     -- ?m → ?m

#check (List.nil : List Nat)  -- List Nat
#check (id : Nat → Nat)       -- Nat → Nat
</code></pre>
<p>Lean 中的数字是重载的，但是当无法推断出数字的类型时，Lean 默认认为它是一个自然数。因此，下面的前两个“#check”命令中的表达式会以相同的方式进行解释，而第三个“#check”命令将“2”解释为一个整数。</p>
<pre><code class="language-lean">#check 2            -- Nat
#check (2 : Nat)    -- Nat
#check (2 : Int)    -- Int
</code></pre>
<p>有时候，我们可能会发现自己处于这样一种情况：我们声明一个函数的参数为隐式的，但现在希望明确提供该参数。如果 <code>foo</code> 是这样一个函数，那么符号 <code>@foo</code> 表示具有所有参数都明确的相同函数。</p>
<pre><code class="language-lean">#check @id        -- {α : Type u_1} → α → α
#check @id Nat    -- Nat → Nat
#check @id Bool   -- Bool → Bool

#check @id Nat 1     -- Nat
#check @id Bool true -- Bool
</code></pre>
<p>请注意，现在第一个<code>#check</code>命令将不插入任何占位符，而是显示标识符<code>id</code>的类型。此外，输出还指示第一个参数是隐含的。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="命题和证明"><a class="header" href="#命题和证明">命题和证明</a></h1>
<p>到目前为止，您已经了解了在Lean中定义对象和函数的一些方法。在本章中，我们将开始解释如何使用依赖类型理论的语言编写数学断言和证明。</p>
<h2 id="命题作为类型"><a class="header" href="#命题作为类型">命题作为类型</a></h2>
<p>在依赖类型理论的语言中证明关于对象的断言的一种策略是在定义语言之上叠加一个断言语言和一个证明语言。但是没有理由以这种方式增加语言的数量：依赖类型理论是灵活且表达能力强的，我们没有理由不能在相同的普遍框架中表示命题和证明。</p>
<p>例如，我们可以引入一个新的类型“Prop”来表示命题，并引入构造函数从其他命题构建新的命题。</p>
<pre><code class="language-lean"># def Implies (p q : Prop) : Prop := p → q
#check And     -- Prop → Prop → Prop
#check Or      -- Prop → Prop → Prop
#check Not     -- Prop → Prop
#check Implies -- Prop → Prop → Prop

variable (p q r : Prop)
#check And p q                      -- Prop
#check Or (And p q) r               -- Prop
#check Implies (And p q) (And q p)  -- Prop
</code></pre>
<p>然后我们可以为每个元素<code>p: Prop</code>引入另一个类型<code>Proof p</code>，表示<code>p</code>的证明类型。&quot;公理&quot;将是这种类型的一个常量。</p>
<pre><code class="language-lean"># def Implies (p q : Prop) : Prop := p → q
# structure Proof (p : Prop) : Type where
#   proof : p
#check Proof   -- Proof : Prop → Type

axiom and_comm (p q : Prop) : Proof (Implies (And p q) (And q p))

variable (p q : Prop)
#check and_comm p q     -- Proof (Implies (And p q) (And q p))
</code></pre>
<p>除了公理，我们还需要规则来从旧证明中构建新证明。例如，在许多命题逻辑的证明系统中，我们有演绎法则：</p>
<blockquote>
<p>从证明&quot;蕴含 p q&quot;和证明&quot;p&quot;，我们获得证明&quot;q&quot;。</p>
</blockquote>
<p>我们可以表示如下：</p>
<pre><code class="language-lean"># def Implies (p q : Prop) : Prop := p → q
# structure Proof (p : Prop) : Type where
#   proof : p
axiom modus_ponens : (p q : Prop) → Proof (Implies p q) → Proof p → Proof q
</code></pre>
<p>对于命题逻辑的自然推理系统，通常还依赖于以下规则：</p>
<blockquote>
<p>假设我们有一个假设为 <code>p</code> 的证明，那么我们可以“取消”这个假设并得到一个 <code>Implies p q</code> 的证明。</p>
</blockquote>
<pre><code class="language-lean"># def Implies (p q : Prop) : Prop := p → q
# structure Proof (p : Prop) : Type where
#   proof : p
axiom implies_intro : (p q : Prop) → (Proof p → Proof q) → Proof (Implies p q)
</code></pre>
<p>这种方法将为我们提供一个合理的建立断言和证明的方式。确定表达式 &quot;t&quot; 是断言 &quot;p&quot; 的正确证明，只是简单地检查 &quot;t&quot; 是否具有类型 &quot;Proof p&quot;。</p>
<p>然而，我们可以进行一些简化。首先，我们可以通过将 &quot;Proof p&quot; 与 &quot;p&quot; 本身混淆来避免重复写入术语 &quot;Proof&quot;。换句话说，每当我们有 &quot;p：Prop&quot; 时，我们可以将 &quot;p&quot; 解释为一个类型，即其证明的类型。然后，我们可以将 &quot;t：p&quot; 读作 &quot;t&quot; 是 &quot;p&quot; 的证明的断言。</p>
<p>此外，一旦我们进行了这种识别，含蓄规则表明我们可以在 &quot;Implies p q&quot; 和 &quot;p → q&quot; 之间来回传递。换句话说，命题 &quot;p&quot; 和 &quot;q&quot; 之间的蕴含对应于具有将 &quot;p&quot; 的任何元素映射到 &quot;q&quot; 的元素的函数。因此，引入连词 &quot;Implies&quot; 是完全冗余的：我们可以使用依赖类型理论中的通常函数空间构造器 &quot;p → q&quot; 作为蕴涵的概念。</p>
<p>这是&quot;构造演算&quot;和&quot;依赖类型理论&quot;中遵循的方法，因此也是Lean中遵循的方法。证明系统中蕴含的规则完全对应于函数的抽象和应用的规则，这是 <em>Curry-Howard 同构</em>（有时被称为 <em>命题即类型</em> 范式）的一个实例。实际上，类型 &quot;Prop&quot; 是 &quot;Sort 0&quot; 的语法糖，表示类型层次结构中的最底层，如上一章所述。此外，&quot;Type u&quot; 也只是 &quot;Sort (u+1)&quot; 的语法糖。&quot;Prop&quot; 具有一些特殊功能，但与其他类型宇宙一样，它在箭头构造器下是封闭的：如果我们有 &quot;p q: Prop&quot;，那么 &quot;p → q: Prop&quot;。</p>
<p>有至少两种将命题看作类型的方式。对于那些对逻辑和数学持建设性观点的人来说，这是对 &quot;p&quot; 作为命题所代表的内容的忠实呈现：命题 &quot;p&quot; 表示一种数据类型，即一种结构。
构成证明的数据类型规范。那么，<code>p</code>的证明简单地说就是一个正确类型的对象<code>t：p</code>。
对于不倾向于这种意识形态的人来说，可以将其视为一种简单的编码技巧。对于每个命题<code>p</code>，我们关联一个类型，如果<code>p</code>为假，则该类型为空，如果<code>p</code>为真，则该类型有一个元素，比如<code>*</code>。在后一种情况下，我们可以说（与之关联的）<code>p</code>是“被赋值的”。恰好这种类型与函数应用和抽象的规则相吻合，方便我们跟踪“Prop”中的哪些元素是被赋值的。因此，构建一个元素<code>t：p</code>告诉我们，<code>p</code>的确是真的。你可以把<code>p</code>的元素想象成“<code>p</code>为真的事实”。<code>p→q</code>的证明使用“<code>p</code>为真的事实”来得出“<code>q</code>为真的事实”。</p>
<p>实际上，如果<code>p：Prop</code>是任何命题，Lean核心将任意两个元素<code>t1 t2：p</code>视为定义上相等，就像它将<code>（fun x =&gt; t）s</code>和<code>t[s/x]</code>视为定义上相等一样。这被称为<em>proof irrelevance</em>，与上段的解释一致。这意味着尽管我们可以将<code>t：p</code>的证明视为依赖类型理论语言中的普通对象，但它们除了<code>p</code>为真这个事实之外没有任何信息。</p>
<p>我们建议的两种思考命题即类型范式的方式在根本上有所不同。从建设性的角度来看，证明是一种抽象的数学对象，由依赖类型理论中的合适表达式来“表示”。相反，如果我们根据上述描述的编码技巧来思考，那么表达式本身并没有表示任何有趣的东西。相反，我们能够书写并检查它们是否具有良好类型的事实来确保所讨论的命题为真。换句话说，表达式本身就是证明。</p>
<p>在下面的阐述中，我们将在这两种说法之间来回切换，有时会说一个表达式“构造”或
&quot;产生&quot;或&quot;返回&quot;一个命题的证明，有时候只是说它&quot;是&quot;这样的一个证明。这类似于计算机科学家有时混淆语法和语义之间的区别，他们有时会说一个程序&quot;计算&quot;某个函数，有时又会说程序&quot;是&quot;该函数。</p>
<p>不管怎样，真正重要的是最终结果。为了在依赖类型理论的语言中形式化地表达一个数学断言，我们需要展示一个<code>p : Prop</code>的术语。为了<em>证明</em>这个断言，我们需要展示一个<code>t: p</code>的术语。作为一个证明助手，Lean的任务是帮助我们构造这样的术语<code>t</code>，并验证它的正确性和类型是否正确。</p>
<h2 id="以类型为命题的方式处理命题"><a class="header" href="#以类型为命题的方式处理命题">以类型为命题的方式处理命题</a></h2>
<p>在以类型为命题的范式中，只涉及<code>→</code>的定理可以使用lambda抽象和应用来证明。在Lean中，<code>theorem</code>命令引入一个新的定理：</p>
<pre><code class="language-lean">variable {p : Prop}
variable {q : Prop}

theorem t1 : p → q → p := fun hp : p =&gt; fun hq : q =&gt; hp
</code></pre>
<p>将这个证明与类型为<code>α → β → α</code>的表达式<code>fun x:α =&gt; fun y:β =&gt; x</code>进行比较，其中<code>α</code>和<code>β</code>是数据类型。
这描述了一个函数，它接受类型为<code>α</code>和<code>β</code>的参数<code>x</code>和<code>y</code>，然后返回<code>x</code>。
<code>t1</code>的证明具有相同的形式，唯一不同之处在于<code>p</code>和<code>q</code>是<code>Prop</code>而不是<code>Type</code>的元素。
直观地说，我们对<code>p → q → p</code>的证明假设<code>p</code>和<code>q</code>为真，并使用第一个假设（平凡地）来证明结论<code>p</code>为真。</p>
<p>请注意，<code>theorem</code>命令实际上是<code>def</code>命令的一个版本：在命题和类型的对应关系下，证明<code>p → q → p</code>实际上就是定义相关类型的元素。对于核心类型检查器来说，这两者之间没有区别。</p>
<p>然而，定义和定理之间存在一些实际上的差异。在正常情况下，从来不需要展开定理的“定义”；根据证明不可区分性，该定理的任意两个证明在定义上是相等的。一旦定理的证明完成，通常我们只需要知道该证明存在；无关乎证明是什么。基于这个事实，Lean将证明标记为<em>不可约</em>，这是对解析器（更准确地说是对<em>编译器</em>）的一种提示，即在处理文件时通常不需要展开它。实际上，由于评估一个证明的正确性不需要了解另一个证明的细节，Lean通常能够并行处理和检查证明。</p>
<p>与定义一样，<code>#print</code>命令将显示您的证明。</p>
<pre><code class="language-lean"># variable {p : Prop}
# variable {q : Prop}
theorem t1 : p → q → p := fun hp : p =&gt; fun hq : q =&gt; hp

#print t1
</code></pre>
<p>注意，lambda抽象“hp: p”和“hq: q”可以被视为在证明“t1”时的临时假设。Lean还允许我们使用“show”语句明确指定最终项“hp”的类型。</p>
<pre><code class="language-lean"># variable {p : Prop}
# variable {q : Prop}
theorem t1 : p → q → p :=
  fun hp : p =&gt;
  fun hq : q =&gt;
  show p from hp
</code></pre>
<p>添加这样的额外信息可以提高证明的清晰度，帮助在书写证明时检测错误。<code>show</code>命令除了注释类型外，内部还有所有我们见过的<code>t1</code>的表示产生相同的术语。</p>
<p>和普通定义一样，我们可以将抽象的变量移到冒号的左边：</p>
<pre><code class="language-lean"># variable {p : Prop}
# variable {q : Prop}
theorem t1 (hp : p) (hq : q) : p := hp

#print t1    -- p → q → p
</code></pre>
<p>现在我们可以将定理“t1”视为函数应用。</p>
<pre><code class="language-lean"># variable {p : Prop}
# variable {q : Prop}
theorem t1 (hp : p) (hq : q) : p := hp

axiom hp : p

theorem t2 : q → p := t1 hp
</code></pre>
<p>在这里，“axiom”声明假设存在给定类型的元素，并可能妥协逻辑一致性。例如，我们可以用它假设空类型 <code>False</code> 有一个元素。</p>
<pre><code class="language-lean">axiom unsound : False
-- Everything follows from false
theorem ex : 1 = 0 :=
  False.elim unsound
</code></pre>
<p>声明公理“hp : p”等同于声明“p”是真的，并由“hp”证实。将定理“t1 : p → q → p”应用于事实“hp : p”即“p”是真的，可以得到定理“t1 hp : q → p”。</p>
<p>回顾一下，我们也可以将定理“t1”写为以下形式：</p>
<pre><code class="language-lean">theorem t1 {p q : Prop} (hp : p) (hq : q) : p := hp

#print t1
</code></pre>
<p><code>t1</code> 的类型现在是 <code>∀ {p q : Prop}, p → q → p</code>。我们可以理解为断言：“对于每一对命题 <code>p q</code>，我们有 <code>p → q → p</code>。” 例如，我们可以将所有参数移到冒号的右边：</p>
<pre><code class="language-lean">theorem t1 : ∀ {p q : Prop}, p → q → p :=
  fun {p q : Prop} (hp : p) (hq : q) =&gt; hp
</code></pre>
<p>如果<code>p</code>和<code>q</code>已被声明为变量，Lean会自动为我们进行泛化处理：</p>
<pre><code class="language-lean">variable {p q : Prop}

theorem t1 : p → q → p := fun (hp : p) (hq : q) =&gt; hp
</code></pre>
<p>实际上，通过命题即类型对应，我们可以将“p”成立的假设“hp”声明为另一个变量：</p>
<pre><code class="language-lean">variable {p q : Prop}
variable (hp : p)

theorem t1 : q → p := fun (hq : q) =&gt; hp
</code></pre>
<p>Lean检测到证明使用了&quot;hq&quot;并自动添加&quot;hp : p&quot;作为前提条件。在所有情况下，命令“#print t1”仍然产生“∀ p q : Prop, p → q → p”。请记住，这种类型也可以写作&quot;∀ (p q : Prop) (hp : p) (hq : q), p&quot;，因为箭头只表示目标不依赖于绑定变量的箭头类型。</p>
<p>当我们以这种方式推广&quot;t1&quot;时，我们可以将它应用于不同的命题对，以得到常规定理的不同实例。</p>
<pre><code class="language-lean">theorem t1 (p q : Prop) (hp : p) (hq : q) : p := hp

variable (p q r s : Prop)

#check t1 p q                -- p → q → p
#check t1 r s                -- r → s → r
#check t1 (r → s) (s → r)    -- (r → s) → (s → r) → r → s

variable (h : r → s)
#check t1 (r → s) (s → r) h  -- (s → r) → r → s
</code></pre>
<p>再次，利用命题与类型对应的关系，类型为<code>r → s</code>的变量<code>h</code>可视为假设或前提，即<code>r → s</code>成立的假设。</p>
<p>以另一个示例为例，让我们考虑上一章中讨论的复合函数，现在使用命题而不是类型。</p>
<pre><code class="language-lean">variable (p q r s : Prop)

theorem t2 (h₁ : q → r) (h₂ : p → q) : p → r :=
  fun h₃ : p =&gt;
  show r from h₁ (h₂ h₃)
</code></pre>
<p>作为命题逻辑的定理，<code>t2</code>是什么意思？</p>
<p>请注意，使用数值Unicode下标作为假设经常非常有用，可以输入为<code>\0</code>、<code>\1</code>、<code>\2</code>、...，就像我们在这个示例中所做的一样。</p>
<h2 id="命题逻辑"><a class="header" href="#命题逻辑">命题逻辑</a></h2>
<p>Lean定义了所有标准的逻辑连接词和符号。命题连接词使用以下符号表示：</p>
<div class="table-wrapper"><table><thead><tr><th>Ascii</th><th>Unicode</th><th>编辑器快捷键</th><th>定义</th></tr></thead><tbody>
<tr><td>True</td><td></td><td></td><td>True</td></tr>
<tr><td>False</td><td></td><td></td><td>False</td></tr>
<tr><td>Not</td><td>¬</td><td><code>\not</code>, <code>\neg</code></td><td>Not</td></tr>
<tr><td>/\</td><td>∧</td><td><code>\and</code></td><td>And</td></tr>
<tr><td>\/</td><td>∨</td><td><code>\or</code></td><td>Or</td></tr>
<tr><td>-&gt;</td><td>→</td><td><code>\to</code>, <code>\r</code>, <code>\imp</code></td><td></td></tr>
<tr><td>&lt;-&gt;</td><td>↔</td><td><code>\iff</code>, <code>\lr</code></td><td>Iff</td></tr>
</tbody></table>
</div>
<p>它们都取值为<code>Prop</code>。</p>
<pre><code class="language-lean">variable (p q : Prop)

#check p → q → p ∧ q
#check ¬p → p ↔ False
#check p ∨ q → q ∨ p
</code></pre>
<p>运算顺序如下：一元否定 <code>¬</code> 最强，然后是 <code>∧</code>，然后是 <code>∨</code>，然后是 <code>→</code>，最后是 <code>↔</code>。例如，<code>a ∧ b → c ∨ d ∧ e</code> 的意思是 <code>(a ∧ b) → (c ∨ (d ∧ e))</code>。请记住，<code>→</code> 是从右向左结合的（精确来说，现在的参数是 <code>Prop</code> 类型，而不是其他类型），其他二元连结词也是如此。因此，如果我们有 <code>p q r : Prop</code>，表达式 <code>p → q → r</code> 表示 &quot;如果 <code>p</code>，那么如果 <code>q</code>，就 <code>r</code>。&quot; 这只是 <code>p ∧ q → r</code> 的 &quot;柯里化&quot; 形式。</p>
<p>在上一章中，我们观察到 lambda 抽象可以被视为 <code>→</code> 的 &quot;引入规则&quot;。在当前设置中，它展示了如何 &quot;引入&quot; 或建立一个蕴涵。应用可以被视为一种 &quot;消去规则&quot;，展示了如何在证明中 &quot;消去&quot; 或使用一个蕴涵。其他命题连结词在 Lean 的库文件 <code>Prelude.core</code> 中定义（有关库层次结构的更多信息，请参见 <a href="./interacting_with_lean.html#importing-files">importing files</a>），每个连结词都带有其规范的引入和消去规则。</p>
<h3 id="合取conjunction"><a class="header" href="#合取conjunction">合取（conjunction）</a></h3>
<p>表达式 <code>And.intro h1 h2</code> 使用证明 <code>h1 : p</code> 和 <code>h2 : q</code> 构建了一个 <code>p ∧ q</code> 的证明。通常将 <code>And.intro</code> 称为 <em>合取引入</em> 规则。在下一个示例中，我们使用 <code>And.intro</code> 创建了一个 <code>p → q → p ∧ q</code> 的证明。</p>
<pre><code class="language-lean">variable (p q : Prop)

example (hp : p) (hq : q) : p ∧ q := And.intro hp hq

#check fun (hp : p) (hq : q) =&gt; And.intro hp hq
</code></pre>
<p><code>example</code>命令陈述了一个定理，但没有为它命名或将其存储在永久上下文中。实质上，它只是检查给定的项是否具有指定的类型。它非常方便用于说明，并且我们经常会使用它。</p>
<p>表达式<code>And.left h</code>从证明<code>h : p ∧ q</code>中创建了一个关于“p”的证明。同样，<code>And.right h</code>是一个关于“q”的证明。它们通常称为左和右的<em>and-消除</em>规则。</p>
<pre><code class="language-lean">variable (p q : Prop)

example (h : p ∧ q) : p := And.left h
example (h : p ∧ q) : q := And.right h
</code></pre>
<p>我们现在可以使用以下证明项证明“p ∧ q → q ∧ p”。</p>
<pre><code class="language-lean">variable (p q : Prop)

example (h : p ∧ q) : q ∧ p :=
  And.intro (And.right h) (And.left h)
</code></pre>
<p>注意，安德引入和安德消除类似于笛卡尔乘积的配对和投影操作。不同之处在于给定<code>hp：p</code>和<code>hq：q</code>，<code>And.intro hp hq</code>的类型是<code>p ∧ q：Prop</code>，而<code>Prod hp hq</code>的类型是<code>p × q：Type</code>。<code>∧</code>和<code>×</code>之间的类似性是另一个Curry-Howard同构的例子，但与蕴含和函数空间构造器不同的是，<code>∧</code>和<code>×</code>在Lean中是分开处理的。然而，通过这个类比，我们刚刚构建的证明类似于将一对元素交换的函数。</p>
<p>我们将在<a href="./structures_and_records.html">结构和记录章节</a>中看到，在Lean中，某些类型是<em>结构</em>，这意味着该类型是用单个规范的<em>构造器</em>定义的，该构造器从一系列合适的参数构建类型的元素。对于每个<code>p q：Prop</code>，<code>p ∧ q</code>就是一个例子：构建元素的规范方法是将适当的参数<code>hp：p</code>和<code>hq：q</code>应用到<code>And.intro</code>中。Lean允许我们在这种情况下使用<em>匿名构造器</em>表示法<code>⟨arg1, arg2, ...⟩</code>，当相关类型是归纳类型并且可以从上下文中推断出时。特别地，我们可以经常写成<code>⟨hp, hq⟩</code>而不是<code>And.intro hp hq</code>：</p>
<pre><code class="language-lean">variable (p q : Prop)
variable (hp : p) (hq : q)

#check (⟨hp, hq⟩ : p ∧ q)
</code></pre>
<p>这些尖括号可以通过键入<code>\&lt;</code>和<code>\&gt;</code>来获得。</p>
<p>Lean还提供了另一个有用的语法工具。给定一个表达式<code>e</code>，它的归纳类型是<code>Foo</code>（可能应用了一些参数），记号<code>e.bar</code>是<code>Foo.bar e</code>的简写。这提供了一种方便的方式来访问函数而不需要打开命名空间。例如，以下两个表达式表示相同的意思：</p>
<pre><code class="language-lean">variable (xs : List Nat)

#check List.length xs
#check xs.length
</code></pre>
<p>因此，鉴于“h：p ∧ q”，我们可以用“h.left”表示“And.left h”，用“h.right”表示“And.right h”。因此，我们可以方便地将上述示例证明重写为：</p>
<pre><code class="language-lean">variable (p q : Prop)

example (h : p ∧ q) : q ∧ p :=
  ⟨h.right, h.left⟩
</code></pre>
<p>简洁和混淆之间有一条微妙的界线，以这种方式省略信息有时会使证明更难阅读。但对于像上面那样的直接构造，当“h”的类型和构造的目标明显时，这种表示法是简洁而有效的。</p>
<p>在 Lean 中，常见的迭代构造方式是 “And”。Lean 还允许将右结合的嵌套构造方式展平，所以这两个证明是等效的：</p>
<pre><code class="language-lean">variable (p q : Prop)

example (h : p ∧ q) : q ∧ p ∧ q :=
  ⟨h.right, ⟨h.left, h.right⟩⟩

example (h : p ∧ q) : q ∧ p ∧ q :=
  ⟨h.right, h.left, h.right⟩
</code></pre>
<p>这也常常很有用。</p>
<h3 id="析取"><a class="header" href="#析取">析取</a></h3>
<p>表达式<code>Or.intro_left q hp</code>根据证明<code>hp : p</code>创建了一个<code>p ∨ q</code>的证明。类似地，<code>Or.intro_right p hq</code>使用证明<code>hq : q</code>创建了一个<code>p ∨ q</code>的证明。这些是左右<em>析取引入</em>规则。</p>
<pre><code class="language-lean">variable (p q : Prop)
example (hp : p) : p ∨ q := Or.intro_left q hp
example (hq : q) : p ∨ q := Or.intro_right p hq
</code></pre>
<p>*or-elimination（或消去）*规则稍微复杂一些。其思路是我们可以从<code>p ∨ q</code>证明出<code>r</code>，通过展示<code>r</code>从<code>p</code>和<code>r</code>从<code>q</code>都可以得到。换句话说，这是一种根据情况证明的方式。在表达式<code>Or.elim hpq hpr hqr</code>中，<code>Or.elim</code>接受三个参数，<code>hpq : p ∨ q</code>，<code>hpr : p → r</code> 和 <code>hqr : q → r</code>，然后得到<code>r</code>的证明。在下面的例子中，我们使用<code>Or.elim</code>来证明<code>p ∨ q → q ∨ p</code>。</p>
<pre><code class="language-lean">variable (p q r : Prop)

example (h : p ∨ q) : q ∨ p :=
  Or.elim h
    (fun hp : p =&gt;
      show q ∨ p from Or.intro_right q hp)
    (fun hq : q =&gt;
      show q ∨ p from Or.intro_left p hq)
</code></pre>
<p>在大多数情况下，Lean可以自动推断出<code>Or.intro_right</code>和<code>Or.intro_left</code>的第一个参数。因此，Lean提供了<code>Or.inr</code>和<code>Or.inl</code>，可以看作是<code>Or.intro_right _</code>和<code>Or.intro_left _</code>的简写形式。因此，上述证明项可以更简洁地编写为：</p>
<pre><code class="language-lean">variable (p q r : Prop)

example (h : p ∨ q) : q ∨ p :=
  Or.elim h (fun hp =&gt; Or.inr hp) (fun hq =&gt; Or.inl hq)
</code></pre>
<p>请注意，完整表达式中有足够的信息供Lean推断<code>hp</code>和<code>hq</code>的类型。但是，使用更长版本中的类型注释可以使证明更可读，并且可以帮助捕捉和调试错误。</p>
<p>由于<code>Or</code>有两个构造函数，我们无法使用匿名构造函数表示法。但是我们仍然可以写<code>h.elim</code>而不是<code>Or.elim h</code>：</p>
<pre><code class="language-lean">variable (p q r : Prop)

example (h : p ∨ q) : q ∨ p :=
  h.elim (fun hp =&gt; Or.inr hp) (fun hq =&gt; Or.inl hq)
</code></pre>
<p>再次，你应该行使判断力来确定这些缩写符是否增强或减弱了可读性。</p>
<h3 id="否定和谬误"><a class="header" href="#否定和谬误">否定和谬误</a></h3>
<p>否定，<code>¬p</code>，实际上被定义为 <code>p → False</code>，因此我们可以通过从 <code>p</code> 推导出一个矛盾来获得 <code>¬p</code>。类似地，表达式 <code>hnp hp</code> 从 <code>hp : p</code> 和 <code>hnp : ¬p</code> 中产生了一个 <code>False</code> 的证明。下一个例子使用了这两条规则来产生一个 <code>(p → q) → ¬q → ¬p</code> 的证明。（符号 <code>¬</code> 通过输入 <code>\not</code> 或者 <code>\neg</code> 获取。）</p>
<pre><code class="language-lean">variable (p q : Prop)

example (hpq : p → q) (hnq : ¬q) : ¬p :=
  fun hp : p =&gt;
  show False from hnq (hpq hp)
</code></pre>
<p>逻辑连词<code>False</code>具有一个单一的消解规则，<code>False.elim</code>，它表达了任何事物都可以从矛盾中推导出来的事实。有时将此规则称为<em>ex falso</em>（<em>ex falso sequitur quodlibet</em>的缩写）或者<em>爆炸原理</em>。</p>
<pre><code class="language-lean">variable (p q : Prop)

example (hp : p) (hnp : ¬p) : q := False.elim (hnp hp)
</code></pre>
<p><code>absurd</code>是从矛盾的假设中推导出任意事实的模式，被应用在<code>False.elim</code>这个函数中，并且会自动推断出这个任意事实<code>q</code>。这种模式是相当常见的。</p>
<pre><code class="language-lean">variable (p q : Prop)

example (hp : p) (hnp : ¬p) : q := absurd hp hnp
</code></pre>
<p>以下是<code>¬p → q → (q → p) → r</code>的一个证明示例：</p>
<p>首先，我们假设<code>¬p</code>为真（设置前提）。</p>
<p>接下来，我们假设<code>q</code>也为真（设置前提）。</p>
<p>然后，假设<code>q → p</code>为真（设置前提）。</p>
<p>根据前提<code>¬p</code>和设置的<code>q → p</code>，我们可以得出<code>p</code>为假（通过逻辑推理）。</p>
<p>再根据前提<code>q</code>和得出的<code>p</code>为假，我们可以得出<code>q → p</code>为假（通过逻辑推理）。</p>
<p>根据前提<code>q → p</code>为假和设置的<code>q → p</code>，我们可以得出<code>¬q</code>为真（通过逻辑推理）。</p>
<p>最后，根据前提<code>¬q</code>和设置的<code>¬p</code>，我们可以得出<code>r</code>为真（通过逻辑推理）。</p>
<p>因此，我们可以得出结论：<code>¬p → q → (q → p) → r</code>为真。</p>
<pre><code class="language-lean">variable (p q r : Prop)

example (hnp : ¬p) (hq : q) (hqp : q → p) : r :=
  absurd (hqp hq) hnp
</code></pre>
<p>顺便说一下，就像<code>False</code>只有一个消除规则一样，<code>True</code>只有一个引入规则，即<code>True.intro : true</code>。换句话说，<code>True</code>就是真，它有一个规范的证明，即<code>True.intro</code>。</p>
<h3 id="逻辑等价"><a class="header" href="#逻辑等价">逻辑等价</a></h3>
<p>表达式<code>Iff.intro h1 h2</code>从<code>h1 : p → q</code>和<code>h2 : q → p</code>中产生了<code>p ↔ q</code>的证明。表达式<code>Iff.mp h</code>从<code>h : p ↔ q</code>中产生了<code>p → q</code>的证明。类似地，<code>Iff.mpr h</code>从<code>h : p ↔ q</code>中产生了<code>q → p</code>的证明。这是一个<code>p ∧ q ↔ q ∧ p</code>的证明：</p>
<pre><code class="language-lean">variable (p q : Prop)

theorem and_swap : p ∧ q ↔ q ∧ p :=
  Iff.intro
    (fun h : p ∧ q =&gt;
     show q ∧ p from And.intro (And.right h) (And.left h))
    (fun h : q ∧ p =&gt;
     show p ∧ q from And.intro (And.right h) (And.left h))

#check and_swap p q    -- p ∧ q ↔ q ∧ p

variable (h : p ∧ q)
example : q ∧ p := Iff.mp (and_swap p q) h
</code></pre>
<p>我们可以使用匿名构造函数表示法从前向和后向的证明来构造<code>p ↔ q</code>的证明，还可以使用<code>.</code>表示法与<code>mp</code>和<code>mpr</code>。因此，前面的示例可以简洁地写成如下形式：</p>
<pre><code class="language-lean">variable (p q : Prop)

theorem and_swap : p ∧ q ↔ q ∧ p :=
  ⟨ fun h =&gt; ⟨h.right, h.left⟩, fun h =&gt; ⟨h.right, h.left⟩ ⟩

example (h : p ∧ q) : q ∧ p := (and_swap p q).mp h
</code></pre>
<h2 id="介绍辅助子目标"><a class="header" href="#介绍辅助子目标">介绍辅助子目标</a></h2>
<p>这是一个介绍Lean提供的帮助组织长证明的另一种方法的好地方，即“have”结构，在证明中引入了一个辅助子目标。这里有一个小例子，根据上一节进行了调整：</p>
<pre><code class="language-lean">variable (p q : Prop)

example (h : p ∧ q) : q ∧ p :=
  have hp : p := h.left
  have hq : q := h.right
  show q ∧ p from And.intro hq hp
</code></pre>
<p>内部表达式<code>have h : p := s; t</code>会生成<code>(fun (h : p) =&gt; t) s</code>。换句话说，<code>s</code>是<code>p</code>的证明，<code>t</code>是在假设<code>h : p</code>下所需结论的证明，并且通过lambda抽象和应用将两者组合在一起。这个简单的方法在构建长证明时非常有用，因为我们可以使用中间的<code>have</code>作为通往最终目标的跳板。</p>
<p>Lean还支持一种从目标向后推理的结构化方法，这种方法模拟了普通数学中的“足够展示”构造。下一个例子只是对之前证明中的最后两行进行了排列。</p>
<pre><code class="language-lean">variable (p q : Prop)

example (h : p ∧ q) : q ∧ p :=
  have hp : p := h.left
  suffices hq : q from And.intro hq hp
  show q from And.right h
</code></pre>
<p>写<code> suffices hq: q</code> 可以让我们达到两个目标。首先，我们必须证明确实只需证明<code>q</code>，通过证明带有额外假设<code>hq：q</code> 的原始目标<code>q ∧ p</code>。最后，我们必须证明<code>q</code>。</p>
<h2 id="经典逻辑"><a class="header" href="#经典逻辑">经典逻辑</a></h2>
<p>到目前为止，我们所看到的引入和消除规则都是建设性的，也就是说，它们反映了基于命题即类型对应的逻辑连词的计算理解。普通的经典逻辑在此基础上添加了排中律，<code>p ∨ ¬p</code>。要使用这个原则，你必须打开经典命名空间。</p>
<pre><code class="language-lean">open Classical

variable (p : Prop)
#check em p
</code></pre>
<p>直观上，构造性的“或”非常强大：断言“p ∨ q”等同于知道哪种情况成立。如果“RH”代表黎曼猜想(Riemann hypothesis)，一个经典的数学家愿意断言“RH ∨ ¬RH”，即使我们还不能断言任何一个分离部分。</p>
<p>排中律的一个结果是双重否定消除原则：</p>
<pre><code class="language-lean">open Classical

theorem dne {p : Prop} (h : ¬¬p) : p :=
  Or.elim (em p)
    (fun hp : p =&gt; hp)
    (fun hnp : ¬p =&gt; absurd hnp h)
</code></pre>
<p>双重否定消除允许我们证明任何命题“p”，通过假设“¬p”并推导出“false”，因为这等同于证明“¬¬p”。换句话说，双重否定消除允许我们进行一个证明通过矛盾，这在建构性逻辑中通常是不可能的。作为一个练习，你可以尝试证明逆命题，即从“dne”证明“em”是可以的。</p>
<p>经典公理还给你提供了通过使用“em”的辅助证明的其他模式。例如，我们可以通过分情况进行证明：</p>
<pre><code class="language-lean">open Classical
variable (p : Prop)

example (h : ¬¬p) : p :=
  byCases
    (fun h1 : p =&gt; h1)
    (fun h1 : ¬p =&gt; absurd h1 h)
</code></pre>
<p>或者你可以采用反证法来进行证明：</p>
<pre><code class="language-lean">open Classical
variable (p : Prop)

example (h : ¬¬p) : p :=
  byContradiction
    (fun h1 : ¬p =&gt;
     show False from h h1)
</code></pre>
<p>如果你不习惯进行建设性思维，可能需要一些时间才能意识到在哪些情况下使用了经典推理。在以下示例中需要使用经典推理，因为从建设性的观点来看，知道“p”和“q”不同时真实并不能告诉你哪一个是假的：</p>
<pre><code class="language-lean"># open Classical
# variable (p q : Prop)
example (h : ¬(p ∧ q)) : ¬p ∨ ¬q :=
  Or.elim (em p)
    (fun hp : p =&gt;
      Or.inr
        (show ¬q from
          fun hq : q =&gt;
          h ⟨hp, hq⟩))
    (fun hp : ¬p =&gt;
      Or.inl hp)
</code></pre>
<p>我们稍后将会看到，在建设性逻辑中确实存在一些情况下，排中律和双重否定消除等原则是可以使用的，并且Lean支持在这样的上下文中使用经典推理而不依赖于排中律。</p>
<p>在Lean中用于支持经典推理的完整公理列表在《公理与计算》中进行了讨论。</p>
<h2 id="命题有效性的示例"><a class="header" href="#命题有效性的示例">命题有效性的示例</a></h2>
<p>Lean的标准库中包含了许多命题逻辑的有效陈述的证明，您可以自由地在您自己的证明中使用它们。下面的列表包括了一些常见的等式。</p>
<p>交换律：</p>
<ol>
<li><code>p ∧ q ↔ q ∧ p</code></li>
<li><code>p ∨ q ↔ q ∨ p</code></li>
</ol>
<p>结合律：</p>
<ol start="3">
<li><code>(p ∧ q) ∧ r ↔ p ∧ (q ∧ r)</code></li>
<li><code>(p ∨ q) ∨ r ↔ p ∨ (q ∨ r)</code></li>
</ol>
<p>分配律：</p>
<ol start="5">
<li><code>p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r)</code></li>
<li><code>p ∨ (q ∧ r) ↔ (p ∨ q) ∧ (p ∨ r)</code></li>
</ol>
<p>其他属性：</p>
<ol start="7">
<li><code>(p → (q → r)) ↔ (p ∧ q → r)</code></li>
<li><code>((p ∨ q) → r) ↔ (p → r) ∧ (q → r)</code></li>
<li><code>¬(p ∨ q) ↔ ¬p ∧ ¬q</code></li>
<li><code>¬p ∨ ¬q → ¬(p ∧ q)</code></li>
<li><code>¬(p ∧ ¬p)</code></li>
<li><code>p ∧ ¬q → ¬(p → q)</code></li>
<li><code>¬p → (p → q)</code></li>
<li><code>(¬p ∨ q) → (p → q)</code></li>
<li><code>p ∨ False ↔ p</code></li>
<li><code>p ∧ False ↔ False</code></li>
<li><code>¬(p ↔ ¬p)</code></li>
<li><code>(p → q) → (¬q → ¬p)</code></li>
</ol>
<p>以下需要经典推理：</p>
<ol start="19">
<li>
<p><code>(p → r ∨ s) → ((p → r) ∨ (p → s))</code></p>
</li>
<li>
<p><code>¬(p ∧ q) → ¬p ∨ ¬q</code></p>
</li>
<li>
<p><code>¬(p → q) → p ∧ ¬q</code></p>
</li>
<li>
<p><code>(p → q) → (¬p ∨ q)</code></p>
</li>
<li>
<p><code>(p → q) → (¬p ∨ q)</code></p>
</li>
<li>
<p><code>(¬q → ¬p) → (p → q)</code></p>
</li>
<li>
<p><code>(¬q → ¬p) → (p → q)</code></p>
</li>
<li>
<p><code>p ∨ ¬p</code></p>
</li>
<li>
<p><code>p ∨ ¬p</code></p>
</li>
<li>
<p><code>(((p → q) → p) → p)</code></p>
</li>
<li>
<p><code>(((p → q) → p) → p)</code></p>
</li>
</ol>
<p><code>sorry</code> 不知何故可以生成任何结论的证明，或提供任何数据类型的对象。当然，这种证明方法是不可行的——例如，你可以用它证明<code>False</code>——当使用或导入依赖于<code>sorry</code>的定理时，Lean会产生严重的警告。但是，它非常有用于逐步构建较长的证明。从上到下编写证明，使用<code>sorry</code>填充子证明。确保Lean接受带有所有<code>sorry</code>的项；如果不接受，则需要纠正错误。然后，逐个将<code>sorry</code>替换为实际的证明，直到没有剩下为止。</p>
<p>这里还有另一个有用的技巧。你可以使用下划线<code>_</code>作为占位符，而不是使用<code>sorry</code>。回想一下，这告诉Lean参数是隐式的，并且应该自动填充。如果Lean尝试并失败，它会返回一个错误消息&quot;don't know how to synthesize placeholder&quot;，后跟它期望的项的类型以及上下文中提供的所有对象和假设。换句话说，对于每个未解决的占位符，Lean报告需要在该点填写的子目标。然后，您可以通过逐步填写这些占位符来构造证明。 </p>
<p>作为参考，这里有两个从上面列表中取出的有效性的示例证明。</p>
<pre><code class="language-lean">open Classical

-- distributivity
example (p q r : Prop) : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) :=
  Iff.intro
    (fun h : p ∧ (q ∨ r) =&gt;
      have hp : p := h.left
      Or.elim (h.right)
        (fun hq : q =&gt;
          show (p ∧ q) ∨ (p ∧ r) from Or.inl ⟨hp, hq⟩)
        (fun hr : r =&gt;
          show (p ∧ q) ∨ (p ∧ r) from Or.inr ⟨hp, hr⟩))
    (fun h : (p ∧ q) ∨ (p ∧ r) =&gt;
      Or.elim h
        (fun hpq : p ∧ q =&gt;
          have hp : p := hpq.left
          have hq : q := hpq.right
          show p ∧ (q ∨ r) from ⟨hp, Or.inl hq⟩)
        (fun hpr : p ∧ r =&gt;
          have hp : p := hpr.left
          have hr : r := hpr.right
          show p ∧ (q ∨ r) from ⟨hp, Or.inr hr⟩))

-- an example that requires classical reasoning
example (p q : Prop) : ¬(p ∧ ¬q) → (p → q) :=
  fun h : ¬(p ∧ ¬q) =&gt;
  fun hp : p =&gt;
  show q from
    Or.elim (em q)
      (fun hq : q =&gt; hq)
      (fun hnq : ¬q =&gt; absurd (And.intro hp hnq) h)
</code></pre>
<h2 id="练习"><a class="header" href="#练习">练习</a></h2>
<p>证明下面的恒等式，将“sorry”占位符替换为实际的证明。</p>
<pre><code class="language-lean">variable (p q r : Prop)

-- commutativity of ∧ and ∨
example : p ∧ q ↔ q ∧ p := sorry
example : p ∨ q ↔ q ∨ p := sorry

-- associativity of ∧ and ∨
example : (p ∧ q) ∧ r ↔ p ∧ (q ∧ r) := sorry
example : (p ∨ q) ∨ r ↔ p ∨ (q ∨ r) := sorry

-- distributivity
example : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) := sorry
example : p ∨ (q ∧ r) ↔ (p ∨ q) ∧ (p ∨ r) := sorry

-- other properties
example : (p → (q → r)) ↔ (p ∧ q → r) := sorry
example : ((p ∨ q) → r) ↔ (p → r) ∧ (q → r) := sorry
example : ¬(p ∨ q) ↔ ¬p ∧ ¬q := sorry
example : ¬p ∨ ¬q → ¬(p ∧ q) := sorry
example : ¬(p ∧ ¬p) := sorry
example : p ∧ ¬q → ¬(p → q) := sorry
example : ¬p → (p → q) := sorry
example : (¬p ∨ q) → (p → q) := sorry
example : p ∨ False ↔ p := sorry
example : p ∧ False ↔ False := sorry
example : (p → q) → (¬q → ¬p) := sorry
</code></pre>
<p>证明以下恒等式，用实际的证明来替换 &quot;sorry&quot; 占位符。这些恒等式需要经典的推理方法。</p>
<ol>
<li>恒等式：(a + b = b + a)，对于任意实数 (a) 和 (b) 成立。</li>
</ol>
<p>证明：根据实数的加法交换律，我们知道对于任意实数 (a) 和 (b)，有 (a + b = b + a)。因此，恒等式成立。</p>
<ol start="2">
<li>恒等式：(a - b = -b + a)，对于任意实数 (a) 和 (b) 成立。</li>
</ol>
<p>证明：根据实数的加法逆元定义，我们有 (b + (-b) = 0)。然后，根据实数的加法单位元定义，我们有 (0 + a = a)。结合这两个等式，我们可以得出 (b + (-b) + a = a)。进一步化简，我们可以得出 ((-b) + a = a - b)。因此，恒等式成立。</p>
<ol start="3">
<li>恒等式：(a \cdot b = b \cdot a)，对于任意实数 (a) 和 (b) 成立。</li>
</ol>
<p>证明：根据实数的乘法交换律，我们知道对于任意实数 (a) 和 (b)，有 (a \cdot b = b \cdot a)。因此，恒等式成立。</p>
<ol start="4">
<li>恒等式：(a \div b = \frac{1}{b} \cdot a)，对于任意实数 (a) 和 (b) 成立。</li>
</ol>
<p>证明：由于除法可以转换为乘法的倒数运算，我们可以将 (a \div b) 转化为 (a \cdot \frac{1}{b})。根据实数的乘法交换律，我们知道对于任意实数 (a) 和 (b)，有 (a \cdot \frac{1}{b} = \frac{1}{b} \cdot a)。因此，恒等式成立。</p>
<p>这些证明使用了实数运算的基本性质和定义，因此都是合理的。</p>
<pre><code class="language-lean">open Classical

variable (p q r : Prop)

example : (p → q ∨ r) → ((p → q) ∨ (p → r)) := sorry
example : ¬(p ∧ q) → ¬p ∨ ¬q := sorry
example : ¬(p → q) → p ∧ ¬q := sorry
example : (p → q) → (¬p ∨ q) := sorry
example : (¬q → ¬p) → (p → q) := sorry
example : p ∨ ¬p := sorry
example : (((p → q) → p) → p) := sorry
</code></pre>
<p>证明 <code>¬(p ↔ ¬p)</code> 而不使用经典逻辑。</p>
<p>让我们使用直觉istic逻辑证明这个表达式。</p>
<p>假设 <code>p</code>为真，即 p=True。那么根据双向蕴含的定义，<code>p ↔ ¬p</code>表达式得到真值:</p>
<pre><code>(p ↔ ¬p) 
≡ (True ↔ ¬True)  
≡ (True ↔ False)
≡ False
</code></pre>
<p>同样地，如果我们假设 <code>p</code>为假，即 p=False，我们会得到相同的结果:</p>
<pre><code>(p ↔ ¬p) 
≡ (False ↔ ¬False)  
≡ (False ↔ True)
≡ False
</code></pre>
<p>由于<code>p</code>可以取<code>True</code>或<code>False</code>的值，并且<code>p ↔ ¬p</code>的结果总是<code>False</code>，我们可以确定该表达式是真的，即 <code>¬(p ↔ ¬p)</code> 为真。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="全称量化"><a class="header" href="#全称量化">全称量化</a></h2>
<p>注意，如果 <code>α</code> 是任意类型，我们可以将 <code>α</code> 上的一元谓词 <code>p</code> 表示为类型为 <code>α → Prop</code> 的对象。在这种情况下，给定 <code>x:α</code>，<code>p x</code> 表示 <code>p</code> 对于 <code>x</code> 成立的断言。类似地，对象 <code>r ：α → α → Prop</code> 表示 <code>α</code> 上的二元关系：给定 <code>x y : α</code>，<code>r x y</code> 表示 <code>x</code> 和 <code>y</code> 有关系的断言。</p>
<p>全称量化符号 <code>∀ x : α, p x</code> 被认为表示了“对于每个 <code>x : α</code> ， <code>p x</code> 成立”的断言。和命题联结词一样，在自然推理系统中，“对于所有”受到引入规则和消除规则的制约。非正式地说，引入规则如下：</p>
<blockquote>
<p>在一个假设为 <code>x : α</code> 的上下文中给定 <code>p x</code> 的证明，我们可以得到一个证明 <code>∀ x : α, p x</code>。</p>
</blockquote>
<p>消除规则如下：</p>
<blockquote>
<p>给定一个证明 <code>∀ x : α, p x</code> 和任意项 <code>t : α</code>，我们可以得到一个证明 <code>p t</code>。</p>
</blockquote>
<p>和蕴含的情况相同，类型为命题的项来进行解释。回想一下依赖箭头类型的引入和消除规则：</p>
<blockquote>
<p>给定类型为 <code>β x</code> 的项 <code>t</code>，在一个假设为 <code>x : α</code> 的上下文中我们有 <code>(fun x : α =&gt; t) : (x : α) → β x</code>。</p>
</blockquote>
<p>消除规则如下：</p>
<blockquote>
<p>给定一个类型为 <code>(x : α) → β x</code> 的项 <code>s</code> 和任意项 <code>t : α</code>，我们有 <code>s t : β t</code>。</p>
</blockquote>
<p>在 <code>p x</code> 的类型为 <code>Prop</code> 的情况下，如果我们将 <code>(x : α) → β x</code> 替换为 <code>∀ x : α, p x</code>，我们可以将这些规则解释为关于全称量化的构建证明的正确规则。
因此，Constructions计算将依赖箭头类型与forall表达式等同起来。如果 <code>p</code> 是任何表达式，那么 <code>∀ x : α, p</code> 不过是 <code>(x : α) → p</code> 的别名，前者在 <code>p</code> 是命题的情况下比后者更加自然。通常情况下，表达式 <code>p</code> 会依赖于 <code>x : α</code>。回想一下，在普通函数空间的情况下，我们可以将 <code>α → β</code> 解释为 <code>(x : α) → β</code> 的特殊情况，其中 <code>β</code> 不依赖于 <code>x</code>。类似地，我们可以将命题之间的蕴含关系 <code>p → q</code> 视为 <code>∀ x : p, q</code> 的特殊情况，其中表达式 <code>q</code> 不依赖于 <code>x</code>。</p>
<p>下面是一个展示命题即类型对应关系如何实践的例子。</p>
<pre><code class="language-lean">example (α : Type) (p q : α → Prop) : (∀ x : α, p x ∧ q x) → ∀ y : α, p y :=
  fun h : ∀ x : α, p x ∧ q x =&gt;
  fun y : α =&gt;
  show p y from (h y).left
</code></pre>
<p>作为一项符号约定，我们将全称量词的作用范围设定为最宽，因此需要用括号将量词限制在上述示例的前提中。证明 <code>∀ y : α, p y</code> 的经典方式是取一个任意的 <code>y</code>，并证明 <code>p y</code>。这是引入规则。现在，假设 <code>h</code> 的类型是 <code>∀ x : α, p x ∧ q x</code>，那么表达式 <code>h y</code> 的类型是 <code>p y ∧ q y</code>。这是消去规则。取左合取项即得到所需结论，即 <code>p y</code>。</p>
<p>请记住，只要变量的绑定不同，表达式即被认为是等价的。因此，例如，在假设和结论中可以使用相同的变量 <code>x</code>，并在证明中用不同的变量 <code>z</code> 实例化它：</p>
<pre><code class="language-lean">example (α : Type) (p q : α → Prop) : (∀ x : α, p x ∧ q x) → ∀ x : α, p x :=
  fun h : ∀ x : α, p x ∧ q x =&gt;
  fun z : α =&gt;
  show p z from And.left (h z)
</code></pre>
<p>另一个例子是我们如何表达一个关系 <code>r</code> 是可传递的：</p>
<pre><code class="language-lean">def transitive {α : Type} (r : α → α → Prop) : Prop :=
∀ (a b c : α), r a b → r b c → r a c
</code></pre>
<p>这里，我们定义了一个函数 <code>transitive</code>，它接受一个类型为 <code>α</code> 的参数，以及一个从 <code>α</code> 到 <code>α</code> 到命题的关系 <code>r</code>。函数的类型为 <code>Prop</code>，即表示命题的类型。在函数体内，我们使用了一个全称量化的命题，即对于任意的 <code>a</code>、<code>b</code>、<code>c</code>，如果 <code>r a b</code> 和 <code>r b c</code> 成立，那么 <code>r a c</code> 也成立。这个定义就表达了关系 <code>r</code> 是可传递的这一事实。</p>
<pre><code class="language-lean">variable (α : Type) (r : α → α → Prop)
variable (trans_r : ∀ x y z, r x y → r y z → r x z)

variable (a b c : α)
variable (hab : r a b) (hbc : r b c)

#check trans_r    -- ∀ (x y z : α), r x y → r y z → r x z
#check trans_r a b c
#check trans_r a b c hab
#check trans_r a b c hab hbc
</code></pre>
<p>考虑这里发生了什么。当我们使用值 <code>a b c</code> 实例化 <code>trans_r</code> 时，我们得到了一个证明，即 <code>r a b → r b c → r a c</code>。将其应用于“假设”<code>hab : r a b</code>，我们得到了一个蕴含的证明 <code>r b c → r a c</code>。最后，将其应用于假设<code>hbc</code>，我们得到了一个结论的证明<code>r a c</code>。</p>
<p>在这种情况下，如果从 <code>hab hbc</code> 可以推断出 <code>a b c</code>，那么提供这些参数可能会很繁琐。因此，通常会将这些参数设为隐式的：</p>
<pre><code class="language-lean">variable (α : Type) (r : α → α → Prop)
variable (trans_r : ∀ {x y z}, r x y → r y z → r x z)

variable (a b c : α)
variable (hab : r a b) (hbc : r b c)

#check trans_r
#check trans_r hab
#check trans_r hab hbc
</code></pre>
<p><strong>好处</strong>是我们可以简单地写<code>trans_r hab hbc</code>来证明<code>r a c</code>。缺点是Lean没有足够的信息来推断表达式<code>trans_r</code>和<code>trans_r hab</code>的参数类型。第一个<code>#check</code>命令的输出是<code>r ?m.1 ?m.2 → r ?m.2 ?m.3 → r ?m.1 ?m.3</code>，表示在这种情况下隐式参数未指定。</p>
<p>以下是如何使用等价关系进行基本推理的示例：</p>
<pre><code class="language-lean">variable (α : Type) (r : α → α → Prop)

variable (refl_r : ∀ x, r x x)
variable (symm_r : ∀ {x y}, r x y → r y x)
variable (trans_r : ∀ {x y z}, r x y → r y z → r x z)

example (a b c d : α) (hab : r a b) (hcb : r c b) (hcd : r c d) : r a d :=
  trans_r (trans_r hab (symm_r hcb)) hcd
</code></pre>
<p>为了熟悉使用全称量词，你应该尝试一下这节末尾的一些练习题。</p>
<p>正是依赖箭头类型的类型规则，尤其是普遍量化符号，使得 <code>Prop</code> 与其他类型有所区别。假设我们有 <code>α : Sort i</code> 和 <code>β : Sort j</code>，其中表达式 <code>β</code> 可能依赖于变量 <code>x : α</code>。然后 <code>(x : α) → β</code> 是 <code>Sort (imax i j)</code> 的一个元素，其中 <code>imax i j</code> 是如果 <code>j</code> 不为0，则为 <code>i</code> 和 <code>j</code> 的最大值，否则为0。</p>
<p>思路如下。如果 <code>j</code> 不是 <code>0</code>，那么 <code>(x : α) → β</code> 是 <code>Sort (max i j)</code> 的一个元素。换句话说，从 <code>α</code> 到 <code>β</code> 的依赖函数的类型 &quot;存在&quot; 在索引为 <code>i</code> 和 <code>j</code> 的最大值的宇宙中。然而，假设 <code>β</code> 是 <code>Sort 0</code>，即属于 <code>Prop</code> 的一个元素。在这种情况下，无论 <code>α</code> 生活在哪种类型宇宙中， <code>(x : α) → β</code> 也是 <code>Sort 0</code> 的一个元素。换句话说，如果 <code>β</code> 是依赖于 <code>α</code> 的命题，那么 <code>∀ x : α, β</code> 再次是一个命题。这反映了将 <code>Prop</code> 解释为命题类型而不是数据类型的含义，并且正是这使得 <code>Prop</code> <em>不可谓的</em>。</p>
<h1>术语 &quot;头等预测&quot; 起源于二十世纪转折时期的基础研究，当时像庞加莱和罗素这样的逻辑学家归咎于集合论悖论，原因是当我们通过量化集合来定义属性时，就出现了 &quot;恶性循环&quot;。请注意，如果 <code>α</code> 是任意类型，我们可以构造类型 <code>α → Prop</code>，表示所有关于 <code>α</code> 的谓词的类型（<code>α</code> 的 &quot;幂类型&quot;）。<code>Prop</code> 的不可预测性意味着我们可以形成量化整个 <code>α → Prop</code> 的命题。特别地，我们可以通过量化所有关于 <code>α</code> 的谓词来定义关于 <code>α</code> 的谓词。
关于 Lean 定理证明</h1>
<p>在 Lean 的定理证明库中，<em>等式（equality）</em> 是其中的一个最基本的关系。在 <a href="inductive_types.html">归纳类型（Inductive Types）章节</a> 中，我们将解释 *等式是如何从 Lean 逻辑框架的基本元素中定义出来的。在此期间，我们将解释如何使用它。</p>
<p>当然，等式的一个基本性质就是它是一个等价关系：</p>
<pre><code class="language-lean">#check Eq.refl    -- ∀ (a : ?m.1), a = a
#check Eq.symm    -- ?m.2 = ?m.3 → ?m.3 = ?m.2
#check Eq.trans   -- ?m.2 = ?m.3 → ?m.3 = ?m.4 → ?m.2 = ?m.4
</code></pre>
<p>我们可以通过告诉 Lean 不插入隐式参数（在这里显示为元变量）来使输出更易读。</p>
<pre><code class="language-lean">universe u

#check @Eq.refl.{u}   -- ∀ {α : Sort u} (a : α), a = a
#check @Eq.symm.{u}   -- ∀ {α : Sort u} {a b : α}, a = b → b = a
#check @Eq.trans.{u}  -- ∀ {α : Sort u} {a b c : α}, a = b → b = c → a = c
</code></pre>
<p>LEᴀɴ θᴇᴏʀᴇᴍ-7: 给定一个类型<code>A</code>和<code>x, y : A</code>，表达式<code>x = y</code>（即x和y相等）类型为<code>Pro p</code>。</p>
<p>证明：通过引入类型 A，我们可以实例化上述引理以证明它对于任何类型 A 是成立的。假设<code>A</code>是一个类型，并且<code>x, y : A</code>是 A 上的任意两个元素。我们的目标是证明<code>x = y</code>是一个命题。</p>
<p>根据上述引理的定义，我们需要实例化它的类型为<code>Type (max u v)</code>，其中 u 和 v 是<code>x</code>和<code>y</code>所在的宇宙的级别。在此证明中，我们将使用它们的级别作为我们实例化的宇宙 u 和 v 的值。</p>
<p>此外，我们还需要为此引理提供其他的参数，例如<code>x</code>和<code>y</code>的类型，即<code>A</code>。此外，我们还需要提供一个以证明<code>x = y</code>的证据构造函数。</p>
<p>在这种情况下，由于我们没有提供任何特定的<code>x</code>和<code>y</code>的值，我们不能使用等价关系（<code>=</code>）的构造函数。相反，我们只需要证明在任何情况下，当<code>x</code>和<code>y</code>都被视为命题时，它们是相等的。</p>
<p>因此，我们可以确定<code>x = y</code>的类型为<code>Prop</code>，它是<code>Type</code>的一个子类型，用于表示命题。通过此推理，我们完成了对<code>x = y</code>是一个命题的证明。</p>
<p>因此，我们可以得出结论：对于任何类型<code>A</code>和<code>x, y : A</code>，表达式<code>x = y</code>是一个命题。</p>
<pre><code class="language-lean">variable (α : Type) (a b c d : α)
variable (hab : a = b) (hcb : c = b) (hcd : c = d)

example : a = d :=
  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd
</code></pre>
<p>我们还可以使用投影符号表示：</p>
<pre><code class="language-lean"># variable (α : Type) (a b c d : α)
# variable (hab : a = b) (hcb : c = b) (hcd : c = d)
example : a = d := (hab.trans hcb.symm).trans hcd
</code></pre>
<p>自反比它看起来更强大。回想一下，构造演算中的项具有计算解释，并且逻辑框架将具有共同还原的项视为相同。因此，一些非平凡的等式可以通过自反来证明：</p>
<pre><code class="language-lean">variable (α β : Type)

example (f : α → β) (a : α) : (fun x =&gt; f x) a = f a := Eq.refl _
example (a : α) (b : β) : (a, b).1 = a := Eq.refl _
example : 2 + 3 = 5 := Eq.refl _
</code></pre>
<p>这个框架的这个特性非常重要，因此库为<code>Eq.refl _</code>定义了一个记号<code>rfl</code>：</p>
<pre><code class="language-lean"># variable (α β : Type)
example (f : α → β) (a : α) : (fun x =&gt; f x) a = f a := rfl
example (a : α) (b : β) : (a, b).1 = a := rfl
example : 2 + 3 = 5 := rfl
</code></pre>
<p>然而，等式远不止是一种等价关系。它具有重要的性质，即每个命题都尊重等价关系，也就是说我们可以在不改变真值的情况下替换相等的表达式。换句话说，给定 <code>h1: a = b</code> 和 <code>h2: p a</code>，我们可以使用替换操作<code>Eq.subst h1 h2</code> 构建一个证明 <code>p b</code>。</p>
<pre><code class="language-lean">example (α : Type) (a b : α) (p : α → Prop)
        (h1 : a = b) (h2 : p a) : p b :=
  Eq.subst h1 h2

example (α : Type) (a b : α) (p : α → Prop)
    (h1 : a = b) (h2 : p a) : p b :=
  h1 ▸ h2
</code></pre>
<p>第二个表达式中的三角形是在 <code>Eq.subst</code> 和 <code>Eq.symm</code> 之上构建的宏，你可以通过键入 <code>\t</code> 来输入它。</p>
<p>规则 <code>Eq.subst</code> 用于定义以下辅助规则，它们执行更明确的替换。它们旨在处理可应用项，即形如 <code>s t</code> 的项。具体来说，<code>congrArg</code> 可以用于替换参数，<code>congrFun</code> 可以用于替换被应用的项，<code>congr</code> 可以一次替换两者。</p>
<pre><code class="language-lean">variable (α : Type)
variable (a b : α)
variable (f g : α → Nat)
variable (h₁ : a = b)
variable (h₂ : f = g)

example : f a = f b := congrArg f h₁
example : f a = g a := congrFun h₂ a
example : f a = g b := congr h₂ h₁
</code></pre>
<p>Lean 的库中包含大量常见的恒等式，比如这些：</p>
<ul>
<li><strong>对称律（Symmetry）</strong>：对于任意两个对象 P 和 Q，如果 P 等于 Q，那么 Q 也等于 P。</li>
<li><strong>传递律（Transitivity）</strong>：对于任意三个对象 P、Q 和 R，如果 P 等于 Q，且 Q 等于 R，那么 P 等于 R。</li>
<li><strong>自反性（Reflexivity）</strong>：对于任意对象 P，P 等于 P。</li>
<li><strong>加法的单位元（Addition Identity）</strong>：对于任意对象 P，P 加 0 等于 P。</li>
<li><strong>加法的逆元（Addition Inverse）</strong>：对于任意对象 P，存在一个对象 Q，使得 P 加 Q 等于 0。</li>
<li><strong>乘法的单位元（Multiplication Identity）</strong>：对于任意对象 P，P 乘 1 等于 P。</li>
<li><strong>乘法的逆元（Multiplication Inverse）</strong>：对于任意对象 P，如果 P 不等于 0，那么存在一个对象 Q，使得 P 乘 Q 等于 1。</li>
<li><strong>乘法的分配律（Multiplication Distributivity）</strong>：对于任意三个对象 P、Q 和 R，(P 加 Q) 乘 R 等于 P 乘 R 加 Q 乘 R。</li>
</ul>
<p>这些恒等式是数学中经常使用的基本原理，在 Lean 中被用来构建更复杂的证明。</p>
<pre><code class="language-lean">variable (a b c : Nat)

example : a + 0 = a := Nat.add_zero a
example : 0 + a = a := Nat.zero_add a
example : a * 1 = a := Nat.mul_one a
example : 1 * a = a := Nat.one_mul a
example : a + b = b + a := Nat.add_comm a b
example : a + b + c = a + (b + c) := Nat.add_assoc a b c
example : a * b = b * a := Nat.mul_comm a b
example : a * b * c = a * (b * c) := Nat.mul_assoc a b c
example : a * (b + c) = a * b + a * c := Nat.mul_add a b c
example : a * (b + c) = a * b + a * c := Nat.left_distrib a b c
example : (a + b) * c = a * c + b * c := Nat.add_mul a b c
example : (a + b) * c = a * c + b * c := Nat.right_distrib a b c
</code></pre>
<p>注意，<code>Nat.mul_add</code> 和 <code>Nat.add_mul</code> 是 <code>Nat.left_distrib</code> 和 <code>Nat.right_distrib</code> 的另外两个名字。上述性质都是针对自然数（类型为 <code>Nat</code>）而言的。</p>
<p>这里是一个在自然数中使用替换、结合律和分配律进行计算的例子。</p>
<pre><code class="language-lean">example (x y : Nat) : (x + y) * (x + y) = x * x + y * x + x * y + y * y :=
  have h1 : (x + y) * (x + y) = (x + y) * x + (x + y) * y :=
    Nat.mul_add (x + y) x y
  have h2 : (x + y) * (x + y) = x * x + y * x + (x * y + y * y) :=
    (Nat.add_mul x y x) ▸ (Nat.add_mul x y y) ▸ h1
  h2.trans (Nat.add_assoc (x * x + y * x) (x * y) (y * y)).symm
</code></pre>
<p>注意到<code>Eq.subst</code>的第二个隐式参数，它提供了进行替换的上下文，类型为<code>α → Prop</code>。因此，推断此谓词需要一个<em>高阶一致性</em>实例。在完整的一般情况下，确定一个高阶一致性是否存在是不可判定的，而Lean在最佳情况下只能对这个问题提供不完美和近似的解决方案。因此，<code>Eq.subst</code>并不总能做到您希望的那样。宏<code>h ▸ e</code>使用了更有效的启发式方法来计算这个隐式参数，在应用<code>Eq.subst</code>失败的情况下通常会成功。</p>
<p>由于等式推理是如此常见和重要，Lean提供了一些机制来更有效地进行推理。下一节提供了一些语法，使您能够以更自然和清晰的方式编写计算证明。但是，更重要的是，等式推理还得到了术语重写器、简化器和其他类型的自动化支持。术语重写器和简化器在下一节中简要介绍，然后在下一章中详细描述。</p>
<h2 id="计算证明"><a class="header" href="#计算证明">计算证明</a></h2>
<p>计算证明就是一个由中间结果构成的链条，这些中间结果可以通过基本原理（如等式的传递性）进行组合。在Lean中，计算证明以关键字<code>calc</code>开始，具有以下语法：</p>
<pre><code>calc
  &lt;expr&gt;_0  'op_1'  &lt;expr&gt;_1  ':='  &lt;proof&gt;_1
  '_'       'op_2'  &lt;expr&gt;_2  ':='  &lt;proof&gt;_2
  ...
  '_'       'op_n'  &lt;expr&gt;_n  ':='  &lt;proof&gt;_n
</code></pre>
<p>注意，<code>calc</code> 关系的所有缩进都相同。每个 <code>&lt;proof&gt;_i</code> 都是 <code>&lt;expr&gt;_{i-1} op_i &lt;expr&gt;_i</code> 的一个证明。</p>
<p>我们还可以在第一个关系（紧跟着 <code>&lt;expr&gt;_0</code> 的右边）中使用 <code>_</code>，这有助于对齐关系/证明对的序列：</p>
<pre><code>calc &lt;expr&gt;_0 
    '_' 'op_1' &lt;expr&gt;_1 ':=' &lt;proof&gt;_1
    '_' 'op_2' &lt;expr&gt;_2 ':=' &lt;proof&gt;_2
    ...
    '_' 'op_n' &lt;expr&gt;_n ':=' &lt;proof&gt;_n
</code></pre>
<p>这里是一个例子：</p>
<pre><code class="language-lean">variable (a b c d e : Nat)
variable (h1 : a = b)
variable (h2 : b = c + 1)
variable (h3 : c = d)
variable (h4 : e = 1 + d)

theorem T : a = e :=
  calc
    a = b      := h1
    _ = c + 1  := h2
    _ = d + 1  := congrArg Nat.succ h3
    _ = 1 + d  := Nat.add_comm d 1
    _ = e      := Eq.symm h4
</code></pre>
<p>这种证明方法在与<code>simp</code>和<code>rewrite</code>策略结合使用时效果最好，这些策略将在下一章中详细讨论。例如，使用<code>rw</code>缩写为rewrite，上面的证明可以写作如下：</p>
<pre><code class="language-lean"># variable (a b c d e : Nat)
# variable (h1 : a = b)
# variable (h2 : b = c + 1)
# variable (h3 : c = d)
# variable (h4 : e = 1 + d)
theorem T : a = e :=
  calc
    a = b      := by rw [h1]
    _ = c + 1  := by rw [h2]
    _ = d + 1  := by rw [h3]
    _ = 1 + d  := by rw [Nat.add_comm]
    _ = e      := by rw [h4]
</code></pre>
<p>实际上，<code>rw</code> 策略使用给定的等式（可以是假设、定理名或复杂的项）来“重写”目标。如果这样做将目标缩减为恒等式 <code>t = t</code>，则该策略将应用自反性来证明它。</p>
<p>重写可以按顺序应用，因此上述证明可以简化为以下形式：</p>
<pre><code class="language-lean"># variable (a b c d e : Nat)
# variable (h1 : a = b)
# variable (h2 : b = c + 1)
# variable (h3 : c = d)
# variable (h4 : e = 1 + d)
theorem T : a = e :=
  calc
    a = d + 1  := by rw [h1, h2, h3]
    _ = 1 + d  := by rw [Nat.add_comm]
    _ = e      := by rw [h4]
</code></pre>
<p>甚至这样：</p>
<pre><code class="language-lean"># variable (a b c d e : Nat)
# variable (h1 : a = b)
# variable (h2 : b = c + 1)
# variable (h3 : c = d)
# variable (h4 : e = 1 + d)
theorem T : a = e :=
  by rw [h1, h2, h3, Nat.add_comm, h4]
</code></pre>
<p>相反，<code>simp</code>策略通过重复应用给定的等式，以任意顺序和任何适用的位置，重写目标。它还使用了之前在系统中声明过的其他规则，并明智地应用交换律以避免循环。因此，我们可以通过以下方式证明该定理：</p>
<pre><code class="language-lean"># variable (a b c d e : Nat)
# variable (h1 : a = b)
# variable (h2 : b = c + 1)
# variable (h3 : c = d)
# variable (h4 : e = 1 + d)
theorem T : a = e :=
  by simp [h1, h2, h3, Nat.add_comm, h4]
</code></pre>
<p>我们将在下一章讨论关于 <code>rw</code> 和 <code>simp</code> 的变化。</p>
<p><code>calc</code> 命令可以配置成支持某种形式的可传递性的任意关系。甚至可以组合不同的关系。</p>
<pre><code class="language-lean">example (a b c d : Nat) (h1 : a = b) (h2 : b ≤ c) (h3 : c + 1 &lt; d) : a &lt; d :=
  calc
    a = b     := h1
    _ &lt; b + 1 := Nat.lt_succ_self b
    _ ≤ c + 1 := Nat.succ_le_succ h2
    _ &lt; d     := h3
</code></pre>
<p>您可以通过添加 <code>Trans</code> 类型类的新实例来，“教” <code>calc</code> 新的传递性定理。类型类的介绍稍后会给出，但下面的小例子演示了如何使用新的 <code>Trans</code> 实例来扩展 <code>calc</code> 表示法。</p>
<pre><code class="language-Lean">class Trans (α : Type) : Type :=
  (trans : α → α → α)

instance add_trans : Trans nat :=
  ⟨λ a b, a + b⟩

instance mul_trans : Trans nat :=
  ⟨λ a b, a * b⟩

instance concat_trans : Trans string :=
  ⟨λ a b, a ++ b⟩

def calc {α : Type} [Trans α] := α

notation `⟦` a `⟧` := calc.eval a

infixl:1 &quot;×&quot; =&gt; Trans.trans
infixl:0 &quot;+&quot; =&gt; Trans.trans

def add_example : nat :=
  ⟦2 + 3 * 4⟧

def mul_example : nat :=
  ⟦2 × 3 + 4⟧

def concat_example : string :=
  ⟦&quot;Hello, &quot; ++ &quot;World!&quot;⟧

#reduce add_example
#reduce mul_example
#reduce concat_example
</code></pre>
<p>上述代码通过为 <code>nat</code> 和 <code>string</code> 类型分别创建了 <code>Trans</code> 实例 <code>add_trans</code>、<code>mul_trans</code> 和 <code>concat_trans</code>。这些实例定义了 <code>trans</code> 方法，该方法将两个值合并为一个值。</p>
<p>然后，我们定义了 <code>calc</code> 函数，该函数接受一个类型参数 <code>α</code> 和一个 <code>Trans</code> 实例。该函数通过 <code>α</code> 和 <code>Trans</code> 实例来确定要使用的运算符。</p>
<p>接下来，我们定义了 <code>add_example</code>、<code>mul_example</code> 和 <code>concat_example</code> 三个示例，它们使用了 <code>calc</code> 表示法来计算不同类型的表达式。</p>
<p>最后，我们使用 <code>#reduce</code> 命令分别计算了这三个示例。</p>
<pre><code class="language-lean">def divides (x y : Nat) : Prop :=
  ∃ k, k*x = y

def divides_trans (h₁ : divides x y) (h₂ : divides y z) : divides x z :=
  let ⟨k₁, d₁⟩ := h₁
  let ⟨k₂, d₂⟩ := h₂
  ⟨k₁ * k₂, by rw [Nat.mul_comm k₁ k₂, Nat.mul_assoc, d₁, d₂]⟩

def divides_mul (x : Nat) (k : Nat) : divides x (k*x) :=
  ⟨k, rfl⟩

instance : Trans divides divides divides where
  trans := divides_trans

example (h₁ : divides x y) (h₂ : y = z) : divides x (2*z) :=
  calc
    divides x y     := h₁
    _ = z           := h₂
    divides _ (2*z) := divides_mul ..

infix:50 &quot; ∣ &quot; =&gt; divides

example (h₁ : divides x y) (h₂ : y = z) : divides x (2*z) :=
  calc
    x ∣ y   := h₁
    _ = z   := h₂
    _ ∣ 2*z := divides_mul ..
</code></pre>
<p>上面的例子还清楚地表明，即使您没有关于您的关系的中缀表示法，也可以使用<code>calc</code>。最后，我们注意到上面的例子中的垂直线符号<code>∣</code>是Unicode版本的。我们使用Unicode来确保不重载<code>match .. with</code>表达式中使用的ASCII字符<code>|</code>。</p>
<p>使用<code>calc</code>，我们可以以一种更自然和明了的方式编写上一节中的证明。</p>
<pre><code class="language-lean">example (x y : Nat) : (x + y) * (x + y) = x * x + y * x + x * y + y * y :=
  calc
    (x + y) * (x + y) = (x + y) * x + (x + y) * y  := by rw [Nat.mul_add]
    _ = x * x + y * x + (x + y) * y                := by rw [Nat.add_mul]
    _ = x * x + y * x + (x * y + y * y)            := by rw [Nat.add_mul]
    _ = x * x + y * x + x * y + y * y              := by rw [←Nat.add_assoc]
</code></pre>
<p>这里值得考虑使用一种叫 <code>calc</code> 的替代符号表示法。当第一个表达式占据了这么多空间时，在第一个关系中使用 <code>_</code> 自然会对齐所有关系：</p>
<pre><code class="language-lean">example (x y : Nat) : (x + y) * (x + y) = x * x + y * x + x * y + y * y :=
  calc (x + y) * (x + y)
    _ = (x + y) * x + (x + y) * y       := by rw [Nat.mul_add]
    _ = x * x + y * x + (x + y) * y     := by rw [Nat.add_mul]
    _ = x * x + y * x + (x * y + y * y) := by rw [Nat.add_mul]
    _ = x * x + y * x + x * y + y * y   := by rw [←Nat.add_assoc]
</code></pre>
<p>这里 <code>Nat.add_assoc</code> 前面的箭头告诉 rewrite 在相反的方向上使用这个等式（你可以用 <code>\l</code> 输入它或者用 ASCII 码的等价表示 <code>&lt;-</code>）。如果我们追求简洁， <code>rw</code> 和 <code>simp</code> 都可以单独完成这个任务：</p>
<pre><code class="language-lean">example (x y : Nat) : (x + y) * (x + y) = x * x + y * x + x * y + y * y :=
  by rw [Nat.mul_add, Nat.add_mul, Nat.add_mul, ←Nat.add_assoc]

example (x y : Nat) : (x + y) * (x + y) = x * x + y * x + x * y + y * y :=
  by simp [Nat.mul_add, Nat.add_mul, Nat.add_assoc]
</code></pre>
<h2 id="存在量化器"><a class="header" href="#存在量化器">存在量化器</a></h2>
<p>最后，考虑存在量化器，可以写作 <code>exists x : α, p x</code> 或者 <code>∃ x : α, p x</code>。实际上，这两个版本都是更冗长表达式的便利缩写，即 <code>Exists (fun x : α =&gt; p x)</code>，在 Lean 的库中已经定义好了。</p>
<p>正如你现在所期望的那样，这个库包含引入规则和消除规则。引入规则很直接：要证明 <code>∃ x : α, p x</code>，只需提供一个合适的项 <code>t</code> 和一个证明 <code>p t</code>。以下是一些例子：</p>
<pre><code class="language-lean">example : ∃ x : Nat, x &gt; 0 :=
  have h : 1 &gt; 0 := Nat.zero_lt_succ 0
  Exists.intro 1 h

example (x : Nat) (h : x &gt; 0) : ∃ y, y &lt; x :=
  Exists.intro 0 h

example (x y z : Nat) (hxy : x &lt; y) (hyz : y &lt; z) : ∃ w, x &lt; w ∧ w &lt; z :=
  Exists.intro y (And.intro hxy hyz)

#check @Exists.intro
</code></pre>
<p>当上下文中的类型清晰时，我们可以使用匿名构造符号 <code>⟨t, h⟩</code> 来表示 <code>Exists.intro t h</code>。</p>
<pre><code class="language-lean">example : ∃ x : Nat, x &gt; 0 :=
  have h : 1 &gt; 0 := Nat.zero_lt_succ 0
  ⟨1, h⟩

example (x : Nat) (h : x &gt; 0) : ∃ y, y &lt; x :=
  ⟨0, h⟩

example (x y z : Nat) (hxy : x &lt; y) (hyz : y &lt; z) : ∃ w, x &lt; w ∧ w &lt; z :=
  ⟨y, hxy, hyz⟩
</code></pre>
<p>注意，<code>Exists.intro</code>具有隐式参数：Lean必须推断出结论中的谓词<code>p：α → Prop</code>，即<code>∃x，p x</code>。这不是一个简单的事情。例如，如果我们有<code>hg：g 0 0 = 0</code>并写<code>Exists.intro 0 hg</code>，则谓词<code>p</code>可能有很多可能的值，对应于定理<code>∃ x，g x x = x</code>、<code>∃ x，g x x = 0</code>、<code>∃ x，g x 0 = x</code>等。Lean使用上下文推断哪一个是合适的。以下示例说明了此情况，在其中我们将选项<code>pp.explicit</code>设置为true，以要求Lean的漂亮打印机显示隐式参数。</p>
<pre><code class="language-lean">variable (g : Nat → Nat → Nat)
variable (hg : g 0 0 = 0)

theorem gex1 : ∃ x, g x x = x := ⟨0, hg⟩
theorem gex2 : ∃ x, g x 0 = x := ⟨0, hg⟩
theorem gex3 : ∃ x, g 0 0 = x := ⟨0, hg⟩
theorem gex4 : ∃ x, g x x = 0 := ⟨0, hg⟩

set_option pp.explicit true  -- display implicit arguments
#print gex1
#print gex2
#print gex3
#print gex4
</code></pre>
<p>我们可以将 <code>Exists.intro</code> 视为一种信息隐藏的操作，因为它隐藏了对断言主体的见证。 存在消去规则 <code>Exists.elim</code> 执行相反的操作。 它允许我们从 <code>∃ x : α，p x</code> 来证明一个命题 <code>q</code>，通过展示对于任意值 <code>w</code>，<code>q</code> 从 <code>p w</code> 推导出来。 粗略地说，由于我们知道存在满足 <code>p x</code> 的 <code>x</code>，我们可以给它一个名字，比如 <code>w</code>。 如果 <code>q</code> 不提及 <code>w</code>，那么展示 <code>q</code> 从 <code>p w</code> 推导出来等价于展示 <code>q</code> 从任何这样的 <code>x</code> 的存在推导出来。 这是一个例子：</p>
<pre><code class="language-lean">variable (α : Type) (p q : α → Prop)

example (h : ∃ x, p x ∧ q x) : ∃ x, q x ∧ p x :=
  Exists.elim h
    (fun w =&gt;
     fun hw : p w ∧ q w =&gt;
     show ∃ x, q x ∧ p x from ⟨w, hw.right, hw.left⟩)
</code></pre>
<p>对于存在消去规则，与“或”消去法进行比较可能会有所帮助：命题“∃ x : α, p x”可以被看作命题“p a”的一个大的析取，其中“a”遍历整个“α”。请注意，匿名构造符号“⟨w, hw.right, hw.left⟩”是一个嵌套构造应用的缩写；我们同样可以写作“⟨w, ⟨hw.right, hw.left⟩⟩”。</p>
<p>注意，存在命题与Σ类型非常相似，正如在依赖类型部分中所描述的那样。区别在于给定“a : α”和“h : p a”，术语“Exists.intro a h”的类型为“(∃ x : α, p x) : Prop”，而“Sigma.mk a h”的类型为“(Σ x : α, p x) : Type”。∃和Σ之间的相似性是柯里-霍华德同构的另一个例子。</p>
<p>Lean提供了一种更方便的方法来通过“match”表达式消去存在量词：</p>
<pre><code class="language-lean">variable (α : Type) (p q : α → Prop)

example (h : ∃ x, p x ∧ q x) : ∃ x, q x ∧ p x :=
  match h with
  | ⟨w, hw⟩ =&gt; ⟨w, hw.right, hw.left⟩
</code></pre>
<p><code>match</code>表达式是Lean函数定义系统的一部分，它提供了定义复杂函数的便捷且表达力强的方法。再次地，正是Curry-Howard同构使得我们能够利用这个机制来编写证明。<code>match</code>语句将存在断言“解构”为组件<code>w</code>和<code>hw</code>，然后可以在语句的主体中使用它们来证明命题。我们可以为匹配中使用的类型添加注释以增加清晰度：</p>
<pre><code class="language-lean"># variable (α : Type) (p q : α → Prop)
example (h : ∃ x, p x ∧ q x) : ∃ x, q x ∧ p x :=
  match h with
  | ⟨(w : α), (hw : p w ∧ q w)⟩ =&gt; ⟨w, hw.right, hw.left⟩
</code></pre>
<p>我们甚至可以使用 match 语句同时分解合取式：</p>
<pre><code class="language-lean">variables P Q R : Prop

example (h : P ∧ Q ∧ R) : P ∧ Q :=
match h with ⟨hp, hq, _⟩ :=
  ⟨hp, hq⟩
end
</code></pre>
<p>在这个例子中，我们假设了一个命题 <code>P</code>、<code>Q</code> 和 <code>R</code> 构成的合取式 <code>h</code>，我们想要证明 <code>P ∧ Q</code>。我们使用 match 语句来分解合取式 <code>h</code>，并将分解得到的 <code>P</code> 和 <code>Q</code> 分别命名为 <code>hp</code> 和 <code>hq</code>。然后我们使用构造子 <code>⟨⟩</code> 来重新构建合取式，得到证明 <code>⟨hp, hq⟩</code>。最后我们使用 match 语句的结束符号 <code>end</code> 表示 match 语句结束。由于我们只关心 <code>P</code> 和 <code>Q</code>，所以我们对 <code>R</code> 不做任何处理。因此，我们成功地将合取式 <code>h</code> 分解为 <code>P</code> 和 <code>Q</code>。</p>
<pre><code class="language-lean"># variable (α : Type) (p q : α → Prop)
example (h : ∃ x, p x ∧ q x) : ∃ x, q x ∧ p x :=
  match h with
  | ⟨w, hpw, hqw⟩ =&gt; ⟨w, hqw, hpw⟩
</code></pre>
<p>Lean 还提供了一种模式匹配的 <code>let</code> 表达式：</p>
<pre><code class="language-lean"># variable (α : Type) (p q : α → Prop)
example (h : ∃ x, p x ∧ q x) : ∃ x, q x ∧ p x :=
  let ⟨w, hpw, hqw⟩ := h
  ⟨w, hqw, hpw⟩
</code></pre>
<p>这实质上只是上述 <code>match</code> 构造的一种替代表示方法。Lean 甚至允许我们在 <code>fun</code> 表达式中使用隐式 <code>match</code>：</p>
<pre><code class="language-lean"># variable (α : Type) (p q : α → Prop)
example : (∃ x, p x ∧ q x) → ∃ x, q x ∧ p x :=
  fun ⟨w, hpw, hqw⟩ =&gt; ⟨w, hqw, hpw⟩
</code></pre>
<p>我们将在 <a href="./induction_and_recursion.html">归纳与递归章节</a> 中看到，所有这些变体都是更一般的模式匹配结构的实例。</p>
<p>在下面的示例中，我们将 <code>is_even a</code> 定义为 <code>∃ b, a = 2 * b</code>，然后我们证明两个偶数的和仍然是一个偶数。</p>
<pre><code class="language-lean">def is_even (a : Nat) := ∃ b, a = 2 * b

theorem even_plus_even (h1 : is_even a) (h2 : is_even b) : is_even (a + b) :=
  Exists.elim h1 (fun w1 (hw1 : a = 2 * w1) =&gt;
  Exists.elim h2 (fun w2 (hw2 : b = 2 * w2) =&gt;
    Exists.intro (w1 + w2)
      (calc a + b
        _ = 2 * w1 + 2 * w2 := by rw [hw1, hw2]
        _ = 2 * (w1 + w2)   := by rw [Nat.mul_add])))
</code></pre>
<p>使用本章描述的各种工具——匹配语句、匿名构造函数和“rewrite”策略，我们可以将此证明简洁地写成如下形式：</p>
<pre><code class="language-lean"># def is_even (a : Nat) := ∃ b, a = 2 * b
theorem even_plus_even (h1 : is_even a) (h2 : is_even b) : is_even (a + b) :=
  match h1, h2 with
  | ⟨w1, hw1⟩, ⟨w2, hw2⟩ =&gt; ⟨w1 + w2, by rw [hw1, hw2, Nat.mul_add]⟩
</code></pre>
<p>正如构造上的“或”比经典上的“或”更强，构造上的“存在”也比经典上的“存在”更强。举个例子，以下蕴含关系需要经典的推理，因为从构造的角度来看，知道并非每个“x”满足“¬p”并不等同于找到一个特定的“x”满足“p”。</p>
<pre><code class="language-lean">open Classical
variable (p : α → Prop)

example (h : ¬ ∀ x, ¬ p x) : ∃ x, p x :=
  byContradiction
    (fun h1 : ¬ ∃ x, p x =&gt;
      have h2 : ∀ x, ¬ p x :=
        fun x =&gt;
        fun h3 : p x =&gt;
        have h4 : ∃ x, p x := ⟨x, h3⟩
        show False from h1 h4
      show False from h h2)
</code></pre>
<p>以下是一些涉及存在量词的常见等式。在下面的练习中，我们鼓励您尽可能证明更多的等式。我们也让您自行确定哪些是非构造性的，因此需要某种形式的古典推理。</p>
<pre><code class="language-lean">open Classical

variable (α : Type) (p q : α → Prop)
variable (r : Prop)

example : (∃ x : α, r) → r := sorry
example (a : α) : r → (∃ x : α, r) := sorry
example : (∃ x, p x ∧ r) ↔ (∃ x, p x) ∧ r := sorry
example : (∃ x, p x ∨ q x) ↔ (∃ x, p x) ∨ (∃ x, q x) := sorry

example : (∀ x, p x) ↔ ¬ (∃ x, ¬ p x) := sorry
example : (∃ x, p x) ↔ ¬ (∀ x, ¬ p x) := sorry
example : (¬ ∃ x, p x) ↔ (∀ x, ¬ p x) := sorry
example : (¬ ∀ x, p x) ↔ (∃ x, ¬ p x) := sorry

example : (∀ x, p x → r) ↔ (∃ x, p x) → r := sorry
example (a : α) : (∃ x, p x → r) ↔ (∀ x, p x) → r := sorry
example (a : α) : (∃ x, r → p x) ↔ (r → ∃ x, p x) := sorry
</code></pre>
<p>请注意，第二个示例和最后两个示例需要作出假设：至少存在一个类型为 <code>α</code> 的元素 <code>a</code>。</p>
<p>以下是两个较难示例的解决方案：</p>
<pre><code class="language-lean">open Classical

variable (α : Type) (p q : α → Prop)
variable (a : α)
variable (r : Prop)

example : (∃ x, p x ∨ q x) ↔ (∃ x, p x) ∨ (∃ x, q x) :=
  Iff.intro
    (fun ⟨a, (h1 : p a ∨ q a)⟩ =&gt;
      Or.elim h1
        (fun hpa : p a =&gt; Or.inl ⟨a, hpa⟩)
        (fun hqa : q a =&gt; Or.inr ⟨a, hqa⟩))
    (fun h : (∃ x, p x) ∨ (∃ x, q x) =&gt;
      Or.elim h
        (fun ⟨a, hpa⟩ =&gt; ⟨a, (Or.inl hpa)⟩)
        (fun ⟨a, hqa⟩ =&gt; ⟨a, (Or.inr hqa)⟩))

example : (∃ x, p x → r) ↔ (∀ x, p x) → r :=
  Iff.intro
    (fun ⟨b, (hb : p b → r)⟩ =&gt;
     fun h2 : ∀ x, p x =&gt;
     show r from hb (h2 b))
    (fun h1 : (∀ x, p x) → r =&gt;
     show ∃ x, p x → r from
       byCases
         (fun hap : ∀ x, p x =&gt; ⟨a, λ h' =&gt; h1 hap⟩)
         (fun hnap : ¬ ∀ x, p x =&gt;
          byContradiction
            (fun hnex : ¬ ∃ x, p x → r =&gt;
              have hap : ∀ x, p x :=
                fun x =&gt;
                byContradiction
                  (fun hnp : ¬ p x =&gt;
                    have hex : ∃ x, p x → r := ⟨x, (fun hp =&gt; absurd hp hnp)⟩
                    show False from hnex hex)
              show False from hnap hap)))
</code></pre>
<h2 id="关于证明语言的更多内容"><a class="header" href="#关于证明语言的更多内容">关于证明语言的更多内容</a></h2>
<p>我们已经看到，“fun”、“have”和“show”等关键字使得我们可以编写形式化证明项，这些证明项与非形式化的数学证明结构相似。在本节中，我们将讨论一些通常方便的证明语言的其他特性。</p>
<p>首先，我们可以使用匿名的“have”表达式引入辅助目标，而无需为其添加标签。我们可以使用关键字“this”引用以这种方式引入的最后一个表达式：</p>
<pre><code class="language-lean">variable (f : Nat → Nat)
variable (h : ∀ x : Nat, f x ≤ f (x + 1))

example : f 0 ≤ f 3 :=
  have : f 0 ≤ f 1 := h 0
  have : f 0 ≤ f 2 := Nat.le_trans this (h 1)
  show f 0 ≤ f 3 from Nat.le_trans this (h 2)
</code></pre>
<p>通常证明会从一个事实转移到另一个事实，这样可以有效地消除大量标签的混乱。</p>
<p>当目标可以被推断出来时，我们还可以要求 Lean 通过写入“<code>by assumption</code>”来填充证明：</p>
<pre><code class="language-lean"># variable (f : Nat → Nat)
# variable (h : ∀ x : Nat, f x ≤ f (x + 1))
example : f 0 ≤ f 3 :=
  have : f 0 ≤ f 1 := h 0
  have : f 0 ≤ f 2 := Nat.le_trans (by assumption) (h 1)
  show f 0 ≤ f 3 from Nat.le_trans (by assumption) (h 2)
</code></pre>
<p>这样告诉 Lean 使用 <code>assumption</code> 策略，该策略通过在局部上下文中找到合适的假设来证明目标。我们将在下一章中更多地了解 <code>assumption</code> 策略。</p>
<p>我们也可以要求 Lean 在证明中填入 <code>‹p›</code>，其中 <code>p</code> 是我们想要 Lean 在上下文中找到的命题的证明。你可以使用 <code>\f&lt;</code> 和 <code>\f&gt;</code> 输入这些引号。字母 &quot;f&quot; 代表 &quot;French&quot;，因为这些 unicode 符号也可以用作法语引号。实际上，该符号在 Lean 中的表示方式如下：</p>
<pre><code class="language-lean">notation &quot;‹&quot; p &quot;›&quot; =&gt; show p by assumption
</code></pre>
<p>这种方法比使用“假设”的方法更加稳健，因为需要推断的假设的类型是明确给出的。它使得证明更容易阅读。下面是一个更详细的示例：</p>
<pre><code class="language-lean">variable (f : Nat → Nat)
variable (h : ∀ x : Nat, f x ≤ f (x + 1))

example : f 0 ≥ f 1 → f 1 ≥ f 2 → f 0 = f 2 :=
  fun _ : f 0 ≥ f 1 =&gt;
  fun _ : f 1 ≥ f 2 =&gt;
  have : f 0 ≥ f 2 := Nat.le_trans ‹f 1 ≥ f 2› ‹f 0 ≥ f 1›
  have : f 0 ≤ f 2 := Nat.le_trans (h 0) (h 1)
  show f 0 = f 2 from Nat.le_antisymm this ‹f 0 ≥ f 2›
</code></pre>
<p>请记住，在这种情况下你可以使用法语引号来引用“任何”上下文中的内容，不仅仅限于匿名引入的事物。它的使用也不限于命题，尽管将其用于数据有些奇怪：</p>
<pre><code class="language-lean">example (n : Nat) : Nat := ‹Nat›
</code></pre>
<p>以后我们将展示如何使用 Lean 的宏系统扩展证明语言。</p>
<h2 id="练习-1"><a class="header" href="#练习-1">练习</a></h2>
<ol>
<li>证明以下等价关系：</li>
</ol>
<pre><code class="language-lean">variable (α : Type) (p q : α → Prop)

example : (∀ x, p x ∧ q x) ↔ (∀ x, p x) ∧ (∀ x, q x) := sorry
example : (∀ x, p x → q x) → (∀ x, p x) → (∀ x, q x) := sorry
example : (∀ x, p x) ∨ (∀ x, q x) → ∀ x, p x ∨ q x := sorry
</code></pre>
<p>你也应该尝试理解为什么在最后一个例子中无法推导出反向蕴含。</p>
<ol start="2">
<li>当一个组成公式的部分不依赖于量化变量时，通常可以将其从普遍量词外部提取出来。尝试证明以下命题（第二个命题的一个方向需要使用经典逻辑）：</li>
</ol>
<pre><code class="language-lean">variable (α : Type) (p q : α → Prop)
variable (r : Prop)

example : α → ((∀ x : α, r) ↔ r) := sorry
example : (∀ x, p x ∨ r) ↔ (∀ x, p x) ∨ r := sorry
example : (∀ x, r → p x) ↔ (r → ∀ x, p x) := sorry
</code></pre>
<ol start="3">
<li>考虑“理发师悖论”，即在某个城镇中存在一个（男性）理发师，他为所有不给自己刮脸的男人刮脸，而仅仅为这些男人刮脸。证明这是一个矛盾的陈述：</li>
</ol>
<p>Assume that such a barber exists in the town. Let's denote this barber as B. 
假设这个城镇中存在这样一位理发师。我们用 B 表示这个理发师。</p>
<p>Now, we consider the question of whether B shaves himself or not. There are two possibilities:
现在，我们考虑 B 是否给自己刮脸。有两种可能性：</p>
<ol>
<li>
<p>If B shaves himself, then according to the statement of the paradox, B should not shave himself since he only shaves the men who do not shave themselves. This leads to a contradiction because B cannot simultaneously shave himself and not shave himself.
如果 B 给自己刮脸，根据悖论陈述，B 不应该给自己刮脸，因为他只为不给自己刮脸的男人刮脸。这会导致一个矛盾，因为 B 不能同时给自己刮脸和不给自己刮脸。</p>
</li>
<li>
<p>If B does not shave himself, then according to the statement of the paradox, B should shave himself since he shaves all the men who do not shave themselves. Again, this leads to a contradiction because B cannot simultaneously shave himself and not shave himself.
如果 B 不给自己刮脸，根据悖论陈述，B 应该给自己刮脸，因为他为所有不给自己刮脸的男人刮脸。同样，这会导致一个矛盾，因为 B 不能同时给自己刮脸和不给自己刮脸。</p>
</li>
</ol>
<p>In both cases, we arrive at a contradiction. Therefore, it is impossible for such a barber to exist in the town. This paradox demonstrates the self-referential nature of the barber's statement and the logical inconsistency it leads to.
无论哪种情况，我们都得到了一个矛盾。因此，在这个城镇中不可能存在这样一位理发师。这个悖论展示了理发师陈述的自我参照性质以及由此引发的逻辑不一致性。</p>
<pre><code class="language-lean">variable (men : Type) (barber : men)
variable (shaves : men → men → Prop)

example (h : ∀ x : men, shaves barber x ↔ ¬ shaves x x) : False := sorry
</code></pre>
<ol start="4">
<li>记住，如果没有任何参数，类型为 <code>Prop</code> 的表达式只是一个断言。请填写下面的 <code>prime</code> 和 <code>Fermat_prime</code> 的定义，并构建每个给定的断言。例如，您可以通过断言对于每个自然数 <code>n</code>，存在一个大于 <code>n</code> 的质数来表明存在无穷多个质数。哥德巴赫猜想认为，每个大于5的奇数都可以被三个质数相加。如果需要的话，请查找 Fermat 质数的定义或其它陈述的定义。</li>
</ol>
<pre><code class="language-lean">def even (n : Nat) : Prop := sorry

def prime (n : Nat) : Prop := sorry

def infinitely_many_primes : Prop := sorry

def Fermat_prime (n : Nat) : Prop := sorry

def infinitely_many_Fermat_primes : Prop := sorry

def goldbach_conjecture : Prop := sorry

def Goldbach's_weak_conjecture : Prop := sorry

def Fermat's_last_theorem : Prop := sorry
</code></pre>
<p><strong>翻译</strong></p>
<ol start="5">
<li>尽可能证明存在量词部分列出的所有恒等式。</li>
</ol>
<hr />
<p>在这里，我们将尝试证明 Existential Quantifier 部分列出的一些恒等式。</p>
<ol>
<li><code>∃x P(x) ∨ ∃x Q(x) ⇔ ∃x (P(x) ∨ Q(x))</code>*</li>
</ol>
<p>假设存在某个元素 x，它满足性质 P(x) 或者存在某个元素 x，它满足性质 Q(x)。我们想要证明：存在某个元素 x，它同时满足 P(x) 或 Q(x)。</p>
<p>根据 Logic 中的合取分配律，我们可以将此恒等式拆分为两个分支进行证明。</p>
<p><strong>分支1</strong>：假设存在某个元素 x，它满足性质 P(x)。那么存在某个元素 x，它同时满足 P(x) 或 Q(x)。</p>
<p><strong>分支2</strong>：假设存在某个元素 x，它满足性质 Q(x)。那么存在某个元素 x，它同时满足 P(x) 或 Q(x)。</p>
<p>根据合取分配律，我们可以得出：存在某个元素 x，它同时满足 P(x) 或 Q(x)。因此，恒等式成立。</p>
<ol start="2">
<li><code>∃x P(x) ∧ ∃x Q(x) ⇔ ∃x (P(x) ∧ Q(x))</code>*</li>
</ol>
<p>假设存在某个元素 x，它满足性质 P(x) 和存在某个元素 x，它满足性质 Q(x)。我们想要证明：存在某个元素 x，它同时满足 P(x) 和 Q(x)。</p>
<p>根据 Logic 中的析取分配律，我们可以将此恒等式拆分为两个分支进行证明。</p>
<p><strong>分支1</strong>：假设存在某个元素 x，它满足性质 P(x)。那么存在某个元素 x，它同时满足 P(x) 和 Q(x)。</p>
<p><strong>分支2</strong>：假设存在某个元素 x，它满足性质 Q(x)。那么存在某个元素 x，它同时满足 P(x) 和 Q(x)。</p>
<p>根据析取分配律，我们可以得出：存在某个元素 x，它同时满足 P(x) 和 Q(x)。因此，恒等式成立。</p>
<ol start="3">
<li><code>¬(∃x P(x)) ⇔ ∀x ¬P(x)</code>*</li>
</ol>
<p>假设不存在任何元素 x，它满足性质 P(x)。我们想要证明：对于所有的元素 x，它都不满足性质 P(x)。</p>
<p>根据 Logic 中否定的存在量词规则，我们可以得出：对于所有的元素 x，它都不满足性质 P(x)。因此，恒等式成立。</p>
<ol start="4">
<li><code>∀x (P(x)∨ Q(x)) ⇔ (∀x P(x)) ∨ (∀x Q(x))</code>*</li>
</ol>
<p>对于所有的元素 x，它满足性质 P(x) 或 Q(x)。我们想要证明：对于所有的元素 x，它满足性质 P(x) 或对于所有的元素 x，它满足性质 Q(x)。</p>
<p>根据 Logic 中析取的全称量词规则，我们可以将此恒等式拆分为两个分支进行证明。</p>
<p><strong>分支1</strong>：对于所有的元素 x，它满足性质 P(x)。那么对于所有的元素 x，它满足性质 P(x) 或对于所有的元素 x，它满足性质 Q(x)。</p>
<p><strong>分支2</strong>：对于所有的元素 x，它满足性质 Q(x)。那么对于所有的元素 x，它满足性质 P(x) 或对于所有的元素 x，它满足性质 Q(x)。</p>
<p>根据析取的全称量词规则，我们可以得出：对于所有的元素 x，它满足性质 P(x) 或对于所有的元素 x，它满足性质 Q(x)。因此，恒等式成立。</p>
<p>这是我们能够证明的一些存在量词部分列出的恒等式。其他的恒等式可能需要使用不同的推理法则或证明方式来完成。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="策略"><a class="header" href="#策略">策略</a></h1>
<p>在这一章中，我们将介绍一种构建证明的替代方法，使用 <em>策略</em>。证明项是数学证明的一种表示；策略是一种命令或指令，描述如何构建这样的证明。简单地说，您可能开始一个数学证明时会说“为了证明正向推理，展开定义，应用前一个引理，并化简。”就像这些是告诉读者如何找到相关证明的指示一样，策略是告诉 Lean 如何构建一个证明项的指令。它们自然地支持一种逐步编写证明的风格，您可以将证明分解并逐步处理目标。</p>
<p>我们将由一系列策略组成的证明称为“策略样式”证明，以与我们目前已经见过的编写证明项的方式相对比，后者被称为“术语样式”证明。每种样式都有其优点和缺点。例如，策略样式的证明可能更难阅读，因为它们要求读者预测或猜测每个指令的结果。但它们也可以更短更容易编写。此外，策略为使用 Lean 的自动化提供了一个入口，因为自动化过程本身也是策略。</p>
<h2 id="进入策略模式"><a class="header" href="#进入策略模式">进入策略模式</a></h2>
<p>从概念上讲，陈述一个定理或引入一个<code>have</code>语句都会创建一个目标，即构造一个具有预期类型的项。例如，下面的代码会创建一个目标，需要构造一个类型为<code>p ∧ q ∧ p</code>的项，在上下文中有常数<code>p q : Prop</code>，<code>hp : p</code>和<code>hq : q</code>：</p>
<pre><code class="language-lean">theorem test (p q : Prop) (hp : p) (hq : q) : p ∧ q ∧ p :=
  sorry
</code></pre>
<p>你可以将这个目标写成以下形式：</p>
<pre><code>    p : Prop, q : Prop, hp : p, hq : q ⊢ p ∧ q ∧ p
</code></pre>
<p>确实，在上面的例子中，如果你将 &quot;sorry&quot; 替换为空白符号，Lean 将报告这个目标没有被解决。</p>
<p>通常，你可以通过编写一个明确的术语来达成这个目标。然而，当需要一个术语的地方，Lean 允许我们插入一个 <code>by &lt;tactics&gt;</code> 块，其中 <code>&lt;tactics&gt;</code> 是一系列通过分号或换行符分隔的命令。你可以通过以下方式证明上述定理：</p>
<pre><code class="language-lean">theorem test (p q : Prop) (hp : p) (hq : q) : p ∧ q ∧ p :=
  by apply And.intro
     exact hp
     apply And.intro
     exact hq
     exact hp
</code></pre>
<p>我们通常将 <code>by</code> 关键字放在前一行，并将上面的示例写为：</p>
<pre><code class="language-lean">theorem test (p q : Prop) (hp : p) (hq : q) : p ∧ q ∧ p := by
  apply And.intro
  exact hp
  apply And.intro
  exact hq
  exact hp
</code></pre>
<p><code>apply</code>策略将一个表达式应用于一个被视为具有零个或多个参数的函数。它将当前目标的结论与表达式进行统一，并为剩余的参数创建新的子目标，前提是后续参数不依赖于它们。在上面的例子中，命令 <code>apply And.intro</code> 生成了两个子目标：</p>
<pre><code>    case left
    p q : Prop
    hp : p
    hq : q
    ⊢ p

    case right
    p q : Prop
    hp : p
    hq : q
    ⊢ q ∧ p
</code></pre>
<p>第一个目标通过命令 <code>exact hp</code> 实现。<code>exact</code> 命令是 <code>apply</code> 的一种变体，用于指示给定的表达式应该完全填充目标。在策略证明中使用它是好的做法，因为它的失败会提示出现了问题。与 <code>apply</code> 相比，<code>exact</code> 更可靠，因为在处理应用的表达式时，解析器会考虑目标的预期类型。然而，在这种情况下，<code>apply</code> 也同样适用。</p>
<p>您可以使用 <code>#print</code> 命令查看生成的证明项（proof term）：</p>
<pre><code class="language-lean"># theorem test (p q : Prop) (hp : p) (hq : q) : p ∧ q ∧ p := by
#  apply And.intro
#  exact hp
#  apply And.intro
#  exact hq
#  exact hp
#print test
</code></pre>
<p>你可以逐步编写一个策略脚本。在 VS Code 中，按下 <code>Ctrl-Shift-Enter</code> 可以打开一个窗口显示消息，当光标在策略块中时，该窗口会显示当前的目标。在 Emacs 中，按下 <code>C-c C-g</code> 会在任意行的末尾显示目标，或者在不完整的证明中将光标放在最后一个策略的第一个字符之后以查看剩余的目标。如果证明不完整，关键字 <code>by</code> 将会被一个红色波浪线标记，错误消息中也会包含剩余的目标。</p>
<p>策略命令可以接受复合表达式，而不仅仅是单个标识符。下面是前面证明的较短版本：</p>
<pre><code class="language-lean">theorem test (p q : Prop) (hp : p) (hq : q) : p ∧ q ∧ p := by
  apply And.intro hp
  exact And.intro hq hp
</code></pre>
<p>不出意外，它产生了完全相同的证明术语。</p>
<pre><code class="language-lean"># theorem test (p q : Prop) (hp : p) (hq : q) : p ∧ q ∧ p := by
#  apply And.intro hp
#  exact And.intro hq hp
#print test
</code></pre>
<p>多个策略应用可以通过分号连接在一行上写出。</p>
<p>这是因为 Lean 每行只执行一个策略应用，但是可以通过在每个策略应用之间添加分号来在一行中一次性应用多个策略。这种写法能够提高代码的紧凑性和可读性。</p>
<p>在 Lean 中，策略（tactic）是一种用于构造和变换证明的指令。它们可以被应用于目标（goal）或者证明的间断点（proof state）。策略的应用会改变目标或证明的状态，并且可以用于引入、消去、重写等操作。使用策略可以帮助我们更有效地构建证明。</p>
<p>例如，假设我们有两个策略 <code>tac1</code> 和 <code>tac2</code>，并且我们想在当前的目标上依次应用这两个策略。我们可以在一行中使用分号将它们连接起来，如下所示：</p>
<pre><code class="language-lean">tac1; tac2
</code></pre>
<p>这将首先应用 <code>tac1</code> 策略，然后将 <code>tac2</code> 策略应用于产生的证明状态。通过这种方式，我们可以在一行中一次性应用多个策略，简化证明过程。</p>
<p>总而言之，通过在 Lean 中使用分号来连接多个策略的应用，我们可以在一行上写出多个策略的代码，提高代码的紧凑性和可读性。</p>
<pre><code class="language-lean">theorem test (p q : Prop) (hp : p) (hq : q) : p ∧ q ∧ p := by
  apply And.intro hp; exact And.intro hq hp
</code></pre>
<p>可能会产生多个子目标的策略通常会给它们加上标签。例如，策略 <code>apply And.intro</code> 将第一个子目标标记为 <code>left</code>，第二个子目标标记为 <code>right</code>。对于 <code>apply</code> 策略，标签是从 <code>And.intro</code> 声明中使用的参数名推断出来的。您可以使用记法 <code>case &lt;tag&gt; =&gt; &lt;tactics&gt;</code> 来结构化您的策略。以下是我们在本章中第一个策略证明的结构化版本。</p>
<pre><code>Lemma and_commutative :
  forall P Q : Prop, P /\ Q -&gt; Q /\ P.
Proof.
  intros P Q H.
  apply And.intro as left.
  case left.
    intros p q.
    apply And.intro.
      exact q.
      exact p.
Qed.
</code></pre>
<p>这个例子中，我们给 <code>apply And.intro</code> 的第一个子目标加上了标签 <code>left</code>。然后，我们根据标签来结构化策略并进行证明。在 <code>case left</code> 中，我们使用了 <code>intros p q</code> 来引入标记为 <code>left</code> 的子目标的假设，并使用 <code>apply And.intro</code> 来继续证明。最后，我们使用了 <code>exact</code> 策略来完成证明。</p>
<pre><code class="language-lean">theorem test (p q : Prop) (hp : p) (hq : q) : p ∧ q ∧ p := by
  apply And.intro
  case left =&gt; exact hp
  case right =&gt;
    apply And.intro
    case left =&gt; exact hq
    case right =&gt; exact hp
</code></pre>
<p>你可以使用<code>case</code>符号在解决<code>left</code>之前解决子目标<code>right</code>：</p>
<pre><code class="language-lean">theorem test (p q : Prop) (hp : p) (hq : q) : p ∧ q ∧ p := by
  apply And.intro
  case right =&gt;
    apply And.intro
    case left =&gt; exact hq
    case right =&gt; exact hp
  case left =&gt; exact hp
</code></pre>
<p>请注意，Lean 将其他目标隐藏在 <code>case</code> 块中。我们称之为“聚焦”在所选目标上。此外，如果所选目标在 <code>case</code> 块结束时没有完全解决，Lean 会报错。</p>
<p>对于简单的子目标来说，可能没有必要使用标签选择子目标，但你可能仍然希望结构化证明。Lean 还提供了“bullet”符号的记法<code>. &lt;策略&gt;</code>（或 <code>· &lt;策略&gt;</code>）用于结构化证明。</p>
<pre><code class="language-lean">theorem test (p q : Prop) (hp : p) (hq : q) : p ∧ q ∧ p := by
  apply And.intro
  . exact hp
  . apply And.intro
    . exact hq
    . exact hp
</code></pre>
<h2 id="基本策略"><a class="header" href="#基本策略">基本策略</a></h2>
<p>除了 <code>apply</code> 和 <code>exact</code> 外，另一个有用的策略是 <code>intro</code>，它引入了一个假设。接下来是一个在前一章中我们在命题逻辑中证明的恒等式的例子，现在我们将使用策略来证明它。</p>
<pre><code class="language-lean">example (p q r : Prop) : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) := by
  apply Iff.intro
  . intro h
    apply Or.elim (And.right h)
    . intro hq
      apply Or.inl
      apply And.intro
      . exact And.left h
      . exact hq
    . intro hr
      apply Or.inr
      apply And.intro
      . exact And.left h
      . exact hr
  . intro h
    apply Or.elim h
    . intro hpq
      apply And.intro
      . exact And.left hpq
      . apply Or.inl
        exact And.right hpq
    . intro hpr
      apply And.intro
      . exact And.left hpr
      . apply Or.inr
        exact And.right hpr
</code></pre>
<p><code>intro</code> 命令可以更一般地用于引入任意类型的变量：</p>
<pre><code class="language-lean">example (α : Type) : α → α := by
  intro a
  exact a

example (α : Type) : ∀ x : α, x = x := by
  intro x
  exact Eq.refl x
</code></pre>
<p>可以使用它来介绍几个变量：</p>
<pre><code class="language-lean">example : ∀ a b c : Nat, a = b → a = c → c = b := by
  intro a b c h₁ h₂
  exact Eq.trans (Eq.symm h₂) h₁
</code></pre>
<p>正如<code>apply</code>策略用于交互式构建函数应用一样，<code>intro</code>策略用于交互式构建函数抽象（例如，<code>fun x =&gt; e</code>形式的项）。与lambda抽象记法一样，<code>intro</code>策略允许我们使用隐式的<code>match</code>。</p>
<pre><code class="language-lean">example (α : Type) (p q : α → Prop) : (∃ x, p x ∧ q x) → ∃ x, q x ∧ p x := by
  intro ⟨w, hpw, hqw⟩
  exact ⟨w, hqw, hpw⟩
</code></pre>
<p>你还可以像 <code>match</code> 表达式一样提供多个选择。</p>
<pre><code class="language-lean">example (α : Type) (p q : α → Prop) : (∃ x, p x ∨ q x) → ∃ x, q x ∨ p x := by
  intro
  | ⟨w, Or.inl h⟩ =&gt; exact ⟨w, Or.inr h⟩
  | ⟨w, Or.inr h⟩ =&gt; exact ⟨w, Or.inl h⟩
</code></pre>
<p><code>intros</code> 策略可以在没有参数的情况下使用，此时它会选择变量的名称并引入尽可能多的变量。您即将看到一个示例。</p>
<p><code>assumption</code> 策略会查找上下文中与当前目标匹配的假设，如果找到匹配的假设，则应用该假设。</p>
<pre><code class="language-lean">example (x y z w : Nat) (h₁ : x = y) (h₂ : y = z) (h₃ : z = w) : x = w := by
  apply Eq.trans h₁
  apply Eq.trans h₂
  assumption   -- applied h₃
</code></pre>
<p>必要时，它会统一结论中的元变量：</p>
<pre><code class="language-lean">example (x y z w : Nat) (h₁ : x = y) (h₂ : y = z) (h₃ : z = w) : x = w := by
  apply Eq.trans
  assumption      -- solves x = ?b with h₁
  apply Eq.trans
  assumption      -- solves y = ?h₂.b with h₂
  assumption      -- solves z = w with h₃
</code></pre>
<p>下面的示例使用 <code>intros</code> 命令自动引入三个变量和两个假设：</p>
<pre><code class="language-lean">example : ∀ a b c : Nat, a = b → a = c → c = b := by
  intros
  apply Eq.trans
  apply Eq.symm
  assumption
  assumption
</code></pre>
<p>请注意，默认情况下，Lean 自动生成的名称是不可访问的。这么做的目的是确保你的策略证明不依赖于自动生成的名称，从而使其更加健壮。但是，你可以使用组合子 <code>unhygienic</code> 来取消此限制。</p>
<pre><code class="language-lean">example : ∀ a b c : Nat, a = b → a = c → c = b := by unhygienic
  intros
  apply Eq.trans
  apply Eq.symm
  exact a_2
  exact a_1
</code></pre>
<p>你还可以使用 <code>rename_i</code> 策略来重命名上下文中最近不可访问的名称。
在下面的例子中，策略 <code>rename_i h1 _ h2</code> 重命名了上下文中最后三个假设中的两个。</p>
<pre><code class="language-lean">example : ∀ a b c d : Nat, a = b → a = d → a = c → c = b := by
  intros
  rename_i h1 _ h2
  apply Eq.trans
  apply Eq.symm
  exact h2
  exact h1
</code></pre>
<p><code>rfl</code> 策略是 <code>exact rfl</code> 的语法糖。</p>
<pre><code class="language-lean">example (y : Nat) : (fun x : Nat =&gt; 0) y = 0 :=
  by rfl
</code></pre>
<p><code>repeat</code> 组合子可以用来多次应用一种策略。</p>
<pre><code class="language-lean">example : ∀ a b c : Nat, a = b → a = c → c = b := by
  intros
  apply Eq.trans
  apply Eq.symm
  repeat assumption
</code></pre>
<p>有时候，另一种有用的策略是<code>revert</code>策略，从某种意义上说，它是<code>intro</code>的逆向操作。</p>
<pre><code class="language-lean">example (x : Nat) : x = x := by
  revert x
  -- goal is ⊢ ∀ (x : Nat), x = x
  intro y
  -- goal is y : Nat ⊢ y = y
  rfl
</code></pre>
<p>将一个假设移动到目标中，可以得到一个蕴含关系：</p>
<pre><code>H : P
============================
P
</code></pre>
<p>In Lean, we can write this as:</p>
<pre><code>example (P : Prop) (H : P) : P := H
</code></pre>
<p>Here, <code>P</code> represents a proposition (an assertion or a statement), and <code>H</code> represents a proof or evidence for <code>P</code>. The goal is to prove <code>P</code> using the hypothesis <code>H</code>. In Lean, the <code>example</code> keyword is used to introduce a new theorem or lemma. The proof is simply the hypothesis <code>H</code> itself, as it already provides the evidence needed to prove <code>P</code>. Therefore, by applying <code>H</code> as the proof, we can conclude that <code>P</code> is true.</p>
<pre><code class="language-lean">example (x y : Nat) (h : x = y) : y = x := by
  revert h
  -- goal is x y : Nat ⊢ x = y → y = x
  intro h₁
  -- goal is x y : Nat, h₁ : x = y ⊢ y = x
  apply Eq.symm
  assumption
</code></pre>
<p>但是 <code>revert</code> 更加聪明，不仅会还原上下文中的一个元素，还会还原依赖于它的所有后续元素。例如，在上面的例子中，还原 <code>x</code> 会同时带回 <code>h</code>：</p>
<pre><code class="language-lean">example (x y : Nat) (h : x = y) : y = x := by
  revert x
  -- goal is y : Nat ⊢ ∀ (x : Nat), x = y → y = x
  intros
  apply Eq.symm
  assumption
</code></pre>
<p>您也可以一次撤销多个上下文元素:</p>
<pre><code class="language-lean">example (x y : Nat) (h : x = y) : y = x := by
  revert x y
  -- goal is ⊢ ∀ (x y : Nat), x = y → y = x
  intros
  apply Eq.symm
  assumption
</code></pre>
<p>你只能 <code>revert</code> 本地上下文中的一个元素，也就是局部变量或假设。但是你可以使用 <code>generalize</code> 策略，将目标中的任意表达式替换为一个新的变量。</p>
<pre><code class="language-lean">example : 3 = 3 := by
  generalize 3 = x
  -- goal is x : Nat ⊢ x = x
  revert x
  -- goal is ⊢ ∀ (x : Nat), x = x
  intro y
  -- goal is y : Nat ⊢ y = y
  rfl
</code></pre>
<p>上述表示法中的助记符是，通过将 &quot;3&quot; 设置为一个任意变量 &quot;x&quot;，对目标进行泛化。注意：并非每个泛化都能保持目标的有效性。在这里，&quot;generalize&quot; 替换了一个可以使用 &quot;rfl&quot; 证明的目标，变为了一个不可证明的目标：</p>
<pre><code class="language-lean">example : 2 + 3 = 5 := by
  generalize 3 = x
  -- goal is x : Nat ⊢ 2 + x = 5
  admit
</code></pre>
<p>在这个例子中，<code>admit</code> 策略是 <code>sorry</code> 证明项的类比。它关闭当前的目标，并产生通常的警告，表明<code>sorry</code> 已被使用。为了保留先前目标的有效性，<code>generalize</code> 策略允许我们记录<code>3</code>被<code>x</code>替代的事实。您只需要提供一个标签，<code>generalize</code> 将使用它来将分配存储在本地上下文中：</p>
<pre><code class="language-lean">example : 2 + 3 = 5 := by
  generalize h : 3 = x
  -- goal is x : Nat, h : 3 = x ⊢ 2 + x = 5
  rw [← h]
</code></pre>
<p><code>rewrite</code> 策略使用 <code>h</code> 来再次用 <code>3</code> 替换 <code>x</code>。下面将讨论 <code>rewrite</code> 策略。</p>
<h2 id="更多策略"><a class="header" href="#更多策略">更多策略</a></h2>
<p>有一些附加的策略对于构造和析构命题和数据很有用。例如，当应用于形式为 <code>p ∨ q</code> 的目标时，你可以使用诸如 <code>apply Or.inl</code> 和 <code>apply Or.inr</code> 的策略。反过来，<code>cases</code> 策略可以用于分解一个或关系。</p>
<pre><code class="language-lean">example (p q : Prop) : p ∨ q → q ∨ p := by
  intro h
  cases h with
  | inl hp =&gt; apply Or.inr; exact hp
  | inr hq =&gt; apply Or.inl; exact hq
</code></pre>
<p>注意，语法与 <code>match</code> 表达式中使用的语法相似。
新的子目标可以以任何顺序解决。</p>
<pre><code class="language-lean">example (p q : Prop) : p ∨ q → q ∨ p := by
  intro h
  cases h with
  | inr hq =&gt; apply Or.inl; exact hq
  | inl hp =&gt; apply Or.inr; exact hp
</code></pre>
<p>你也可以使用一个（非结构化的）不带 <code>with</code> 的 <code>cases</code> 结构以及为每个分支使用一个策略。</p>
<pre><code class="language-lean">example (p q : Prop) : p ∨ q → q ∨ p := by
  intro h
  cases h
  apply Or.inr
  assumption
  apply Or.inl
  assumption
</code></pre>
<p>(unstructured) <code>cases</code> 在你可以使用同一个策略关闭多个子目标时特别有用。</p>
<pre><code class="language-lean">example (p : Prop) : p ∨ p → p := by
  intro h
  cases h
  repeat assumption
</code></pre>
<p>您还可以使用组合符号<code>tac1 &lt;;&gt; tac2</code>，将<code>tac2</code>应用于<code>tac1</code>产生的每个子目标。</p>
<pre><code class="language-lean">example (p : Prop) : p ∨ p → p := by
  intro h
  cases h &lt;;&gt; assumption
</code></pre>
<p>您可以将 <code>cases</code> 策略与 <code>case</code> 和 <code>.</code> 符号结合使用。</p>
<pre><code class="language-lean">example (p q : Prop) : p ∨ q → q ∨ p := by
  intro h
  cases h
  . apply Or.inr
    assumption
  . apply Or.inl
    assumption

example (p q : Prop) : p ∨ q → q ∨ p := by
  intro h
  cases h
  case inr h =&gt;
    apply Or.inl
    assumption
  case inl h =&gt;
    apply Or.inr
    assumption

example (p q : Prop) : p ∨ q → q ∨ p := by
  intro h
  cases h
  case inr h =&gt;
    apply Or.inl
    assumption
  . apply Or.inr
    assumption
</code></pre>
<p><code>cases</code>策略也可以用于分解合取式。</p>
<p>在 Lean 中，合取式是由逻辑“与”操作符<code>∧</code>连接的两个或多个命题。使用<code>cases</code>策略来分解合取式，可以把一个合取式分解为多个子目标，并分别处理每个子目标。</p>
<p>下面是一个示例：</p>
<pre><code class="language-lean">example (P Q : Prop) : P ∧ Q → (P → Q) :=
begin
  intro h,
  cases h with hP hQ,
  intro h'P,
  exact hQ
end
</code></pre>
<p>在这个例子中，我们假设<code>P</code>和<code>Q</code>是命题，<code>P ∧ Q</code>是一个合取式。我们的目标是证明<code>P ∧ Q</code>蕴含<code>P → Q</code>。首先使用<code>intro</code>策略引入前提假设<code>h : P ∧ Q</code>，然后使用<code>cases</code>策略分解合取式，得到两个子目标：<code>hP : P</code>和<code>hQ : Q</code>。接着，使用<code>intro</code>策略引入新的前提假设<code>h'P : P</code>，最后使用<code>exact</code>策略证明<code>Q</code>，从而完成了证明。</p>
<p>通过使用<code>cases</code>策略，在拥有合取式的证明中可以更方便地处理每个子目标，从而推导出相应的结论。</p>
<pre><code class="language-lean">example (p q : Prop) : p ∧ q → q ∧ p := by
  intro h
  cases h with
  | intro hp hq =&gt; constructor; exact hq; exact hp
</code></pre>
<p>在这个例子中，<code>cases</code>策略应用后只有一个目标，<code>h : p ∧ q</code> 被一对假设<code>hp : p</code> 和 <code>hq : q</code> 替换。<code>constructor</code>策略应用了合取的唯一构造子<code>And.intro</code>。通过使用这些策略，前一节中的一个例子可以重写如下：</p>
<pre><code class="language-lean">example (p q r : Prop) : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) := by
  apply Iff.intro
  . intro h
    cases h with
    | intro hp hqr =&gt;
      cases hqr
      . apply Or.inl; constructor &lt;;&gt; assumption
      . apply Or.inr; constructor &lt;;&gt; assumption
  . intro h
    cases h with
    | inl hpq =&gt;
      cases hpq with
      | intro hp hq =&gt; constructor; exact hp; apply Or.inl; exact hq
    | inr hpr =&gt;
      cases hpr with
      | intro hp hr =&gt; constructor; exact hp; apply Or.inr; exact hr
</code></pre>
<p>你将在 <a href="./inductive_types.html">归纳类型章节</a> 中看到，这些策略非常通用。 <code>cases</code> 策略可以用于分解归纳定义类型的任何元素；<code>constructor</code> 总是应用归纳定义类型的第一个可用构造函数。例如，你可以使用 <code>cases</code> 和 <code>constructor</code> 来处理存在量词的情况：</p>
<pre><code class="language-lean">example (p q : Nat → Prop) : (∃ x, p x) → ∃ x, p x ∨ q x := by
  intro h
  cases h with
  | intro x px =&gt; constructor; apply Or.inl; exact px
</code></pre>
<p>在这里，<code>constructor</code> 策略将存在量化命题的第一个组成部分 <code>x</code> 的值留下隐含。它由一个元变量表示，应该在后面被实例化。在前面的例子中，元变量的正确值由策略 <code>exact px</code> 决定，因为 <code>px</code> 的类型是 <code>p x</code>。如果您想明确指定对存在量词的见证，可以使用 <code>exists</code> 策略替代：</p>
<pre><code class="language-lean">example (p q : Nat → Prop) : (∃ x, p x) → ∃ x, p x ∨ q x := by
  intro h
  cases h with
  | intro x px =&gt; exists x; apply Or.inl; exact px
</code></pre>
<p>这里是另一个例子：</p>
<pre><code class="language-lean">example (p q : Nat → Prop) : (∃ x, p x ∧ q x) → ∃ x, q x ∧ p x := by
  intro h
  cases h with
  | intro x hpq =&gt;
    cases hpq with
    | intro hp hq =&gt;
      exists x
</code></pre>
<p>这些策略同样适用于数据和命题。在下一个示例中，它们被用来定义函数，用于交换乘积类型和求和类型的组成部分：</p>
<pre><code class="language-lean">def swap_pair : α × β → β × α := by
  intro p
  cases p
  constructor &lt;;&gt; assumption

def swap_sum : Sum α β → Sum β α := by
  intro p
  cases p
  . apply Sum.inr; assumption
  . apply Sum.inl; assumption
</code></pre>
<p>请注意，我们选择的变量名称之前，这些定义与对于<strong>合取</strong>和<strong>析取</strong>的相应命题的证明完全相同。<code>cases</code>策略也可以对自然数进行情况分析：</p>
<pre><code class="language-lean">open Nat
example (P : Nat → Prop) (h₀ : P 0) (h₁ : ∀ n, P (succ n)) (m : Nat) : P m := by
  cases m with
  | zero    =&gt; exact h₀
  | succ m' =&gt; exact h₁ m'
</code></pre>
<p>在<strong>归纳类型的策略</strong>一节中详细讨论了<code>cases</code>策略和它的伙伴<code>induction</code>策略。</p>
<p><code>contradiction</code>策略在当前目标的假设中搜索矛盾。</p>
<pre><code class="language-lean">example (p q : Prop) : p ∧ ¬ p → q := by
  intro h
  cases h
  contradiction
</code></pre>
<p>你还可以在策略块中使用 <code>match</code>。</p>
<pre><code class="language-lean">example (p q r : Prop) : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) := by
  apply Iff.intro
  . intro h
    match h with
    | ⟨_, Or.inl _⟩ =&gt; apply Or.inl; constructor &lt;;&gt; assumption
    | ⟨_, Or.inr _⟩ =&gt; apply Or.inr; constructor &lt;;&gt; assumption
  . intro h
    match h with
    | Or.inl ⟨hp, hq⟩ =&gt; constructor; exact hp; apply Or.inl; exact hq
    | Or.inr ⟨hp, hr⟩ =&gt; constructor; exact hp; apply Or.inr; exact hr
</code></pre>
<p>你可以将 <code>intro h</code> 与 <code>match h ...</code> 结合起来，将之前的例子写成以下形式：</p>
<pre><code class="language-lean">example (p q r : Prop) : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) := by
  apply Iff.intro
  . intro
    | ⟨hp, Or.inl hq⟩ =&gt; apply Or.inl; constructor &lt;;&gt; assumption
    | ⟨hp, Or.inr hr⟩ =&gt; apply Or.inr; constructor &lt;;&gt; assumption
  . intro
    | Or.inl ⟨hp, hq⟩ =&gt; constructor; assumption; apply Or.inl; assumption
    | Or.inr ⟨hp, hr⟩ =&gt; constructor; assumption; apply Or.inr; assumption
</code></pre>
<h2 id="构造策略证明"><a class="header" href="#构造策略证明">构造策略证明</a></h2>
<p>策略通常提供了一种有效的建立证明的方法，但是长串的指令可能会掩盖论证的结构。在本节中，我们描述一些方法，帮助为策略样式的证明提供结构，使得这样的证明更易读和稳定。</p>
<p>Lean的证明写作语法的一个好处是可以混合使用术语样式和策略样式的证明，并且可以自由地在两者之间切换。例如，策略<code>apply</code>和<code>exact</code>都需要任意术语，你可以使用<code>have</code>、<code>show</code>等方式来编写这些术语。相反，当编写一个任意的Lean术语时，你总是可以通过插入一个<code>by</code>块来调用策略模式。下面是一个有点玩具化的例子：</p>
<pre><code class="language-lean">example (p q r : Prop) : p ∧ (q ∨ r) → (p ∧ q) ∨ (p ∧ r) := by
  intro h
  exact
    have hp : p := h.left
    have hqr : q ∨ r := h.right
    show (p ∧ q) ∨ (p ∧ r) by
      cases hqr with
      | inl hq =&gt; exact Or.inl ⟨hp, hq⟩
      | inr hr =&gt; exact Or.inr ⟨hp, hr⟩
</code></pre>
<p>以下是一个更自然的例子：</p>
<pre><code class="language-lean">example (p q r : Prop) : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) := by
  apply Iff.intro
  . intro h
    cases h.right with
    | inl hq =&gt; exact Or.inl ⟨h.left, hq⟩
    | inr hr =&gt; exact Or.inr ⟨h.left, hr⟩
  . intro h
    cases h with
    | inl hpq =&gt; exact ⟨hpq.left, Or.inl hpq.right⟩
    | inr hpr =&gt; exact ⟨hpr.left, Or.inr hpr.right⟩
</code></pre>
<p>实际上，Coq 中有一种名为<code>show</code>的策略，类似于证明项中的<code>show</code>表达式。它在策略模式下，用于声明即将解决的目标的类型。</p>
<pre><code class="language-lean">example (p q r : Prop) : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) := by
  apply Iff.intro
  . intro h
    cases h.right with
    | inl hq =&gt;
      show (p ∧ q) ∨ (p ∧ r)
      exact Or.inl ⟨h.left, hq⟩
    | inr hr =&gt;
      show (p ∧ q) ∨ (p ∧ r)
      exact Or.inr ⟨h.left, hr⟩
  . intro h
    cases h with
    | inl hpq =&gt;
      show p ∧ (q ∨ r)
      exact ⟨hpq.left, Or.inl hpq.right⟩
    | inr hpr =&gt;
      show p ∧ (q ∨ r)
      exact ⟨hpr.left, Or.inr hpr.right⟩
</code></pre>
<p><code>show</code>策略可以用于将一个目标重写为在定义上等价的形式：</p>
<pre><code class="language-lean">theorem show_tactic : ∀ (P : Prop), P → P :=
begin
  intro P,
  show P, -- 使用 show 策略
  exact id, -- 使用 id 函数将目标转化为定义上等价的形式
end
</code></pre>
<p>该例子证明了对于任意命题 P，如果已知 P 成立，那么 P 也成立。在证明的过程中，我们使用了 <code>show</code> 策略，将目标 <code>P</code> 重写为定义上等价的形式。通过使用 <code>exact id</code> 策略，我们将目标转化为一个恒等函数 <code>id</code>，从而完成了证明。</p>
<pre><code class="language-lean">example (n : Nat) : n + 1 = Nat.succ n := by
  show Nat.succ n = Nat.succ n
  rfl
</code></pre>
<p>还有一种“have”策略，它引入一个新的子目标，就像写证明项时一样：</p>
<pre><code class="language-lean">example (p q r : Prop) : p ∧ (q ∨ r) → (p ∧ q) ∨ (p ∧ r) := by
  intro ⟨hp, hqr⟩
  show (p ∧ q) ∨ (p ∧ r)
  cases hqr with
  | inl hq =&gt;
    have hpq : p ∧ q := And.intro hp hq
    apply Or.inl
    exact hpq
  | inr hr =&gt;
    have hpr : p ∧ r := And.intro hp hr
    apply Or.inr
    exact hpr
</code></pre>
<p>和证明项一样，你可以在 <code>have</code> 策略中省略标签，这种情况下默认的标签 <code>this</code> 会被使用：</p>
<pre><code class="language-lean">example (p q r : Prop) : p ∧ (q ∨ r) → (p ∧ q) ∨ (p ∧ r) := by
  intro ⟨hp, hqr⟩
  show (p ∧ q) ∨ (p ∧ r)
  cases hqr with
  | inl hq =&gt;
    have : p ∧ q := And.intro hp hq
    apply Or.inl
    exact this
  | inr hr =&gt;
    have : p ∧ r := And.intro hp hr
    apply Or.inr
    exact this
</code></pre>
<p>在策略<code>have</code>中可以省略类型声明，因此可以写成<code>have hp := h.left</code>和<code>have hqr := h.right</code>。实际上，使用这个记号，甚至可以同时省略类型和标签，这种情况下，新的事实会被引入并以标签<code>this</code>命名。</p>
<pre><code class="language-lean">example (p q r : Prop) : p ∧ (q ∨ r) → (p ∧ q) ∨ (p ∧ r) := by
  intro ⟨hp, hqr⟩
  cases hqr with
  | inl hq =&gt;
    have := And.intro hp hq
    apply Or.inl; exact this
  | inr hr =&gt;
    have := And.intro hp hr
    apply Or.inr; exact this
</code></pre>
<p>Lean 还提供了一个 <code>let</code> 策略，类似于 <code>have</code> 策略，但是用于引入局部定义而不是辅助事实。它是证明项中的 <code>let</code> 的策略模拟。</p>
<pre><code class="language-lean">example : ∃ x, x + 2 = 8 := by
  let a : Nat := 3 * 2
  exists a
</code></pre>
<p>与 <code>have</code> 类似，你可以通过写成 <code>let a := 3 * 2</code> 的形式来省略类型的定义。<code>let</code> 和 <code>have</code> 的不同之处在于，<code>let</code> 在上下文中引入了一个局部定义，因此局部声明的定义可以在证明中展开。</p>
<p>我们使用<code>.</code>来创建嵌套的策略块。在嵌套块中，Lean 关注第一个目标，并在块结束时生成错误，如果此目标未被完全解决。这对于指示由策略引入的多个子目标的单独证明是有帮助的。<code>.</code> 的符号对空白字符敏感，并依赖缩进来检测策略块的结束。或者，你可以使用花括号和分号来定义策略块。</p>
<pre><code class="language-lean">example (p q r : Prop) : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) := by
  apply Iff.intro
  { intro h;
    cases h.right;
    { show (p ∧ q) ∨ (p ∧ r);
      exact Or.inl ⟨h.left, ‹q›⟩ }
    { show (p ∧ q) ∨ (p ∧ r);
      exact Or.inr ⟨h.left, ‹r›⟩ } }
  { intro h;
    cases h;
    { show p ∧ (q ∨ r);
      rename_i hpq;
      exact ⟨hpq.left, Or.inl hpq.right⟩ }
    { show p ∧ (q ∨ r);
      rename_i hpr;
      exact ⟨hpr.left, Or.inr hpr.right⟩ } }
</code></pre>
<p>使用缩进来结构化证明是很有用的：每当一个策略产生超过一个子目标时，我们会用块来将剩余的子目标分隔开，并进行缩进。因此，如果将定理 <code>foo</code> 应用于一个目标产生了四个子目标，那么我们期望证明的样子是这样的：</p>
<pre><code>  apply foo
  . &lt;proof of first goal&gt;
  . &lt;proof of second goal&gt;
  . &lt;proof of third goal&gt;
  . &lt;proof of final goal&gt;
</code></pre>
<p>好的，下面是关于 LEAN 定理证明的文章的中文翻译：</p>
<h1 id="lean-定理证明"><a class="header" href="#lean-定理证明">LEAN 定理证明</a></h1>
<h2 id="引言-1"><a class="header" href="#引言-1">引言</a></h2>
<p>在数学和逻辑学中，定理证明是一种通过逻辑推理来证明数学命题的过程。而 LEAN 是一个支持形式化证明的交互式定理证明系统。在本文中，我们将介绍如何在 LEAN 中使用构造性数学来证明定理。</p>
<h2 id="lean-简介"><a class="header" href="#lean-简介">LEAN 简介</a></h2>
<p>LEAN 是一种基于依赖类型理论的交互式定理证明系统。它的设计目标是支持数学家和计算机科学家进行形式化证明，并提供严谨的证明检查机制。</p>
<h2 id="构造性数学"><a class="header" href="#构造性数学">构造性数学</a></h2>
<p>构造性数学是一种数学分支，它要求每个数学命题的证明都必须能够提供一个具体的构造过程。与传统数学不同，构造性数学注重于证明的可执行性。</p>
<h2 id="lean-中的构造性证明"><a class="header" href="#lean-中的构造性证明">LEAN 中的构造性证明</a></h2>
<p>在 LEAN 中，我们可以使用构造性数学的方法来证明定理。首先，我们需要定义一些基本的概念和符号，然后利用这些定义来构造一个具体的证明过程。</p>
<h2 id="定理证明的过程"><a class="header" href="#定理证明的过程">定理证明的过程</a></h2>
<p>在 LEAN 中，定理证明的过程通常分为以下几个步骤：</p>
<ol>
<li>定义概念和符号；</li>
<li>陈述待证明的定理；</li>
<li>给出证明的主要思路和策略；</li>
<li>逐步展开证明过程，使用合适的规则和定理；</li>
<li>最后，通过 LEAN 的证明检查机制来验证证明的正确性。</li>
</ol>
<h2 id="lean-中的规则和定理"><a class="header" href="#lean-中的规则和定理">LEAN 中的规则和定理</a></h2>
<p>LEAN 中有许多已知的数学定理和规则，可以在证明中使用。这些定理和规则是经过验证和严格审查的，可以确保证明的正确性。</p>
<h2 id="示例"><a class="header" href="#示例">示例</a></h2>
<p>下面是一个简单的 LEAN 定理证明的示例：</p>
<p><strong>定理</strong>：对于任意两个整数 a 和 b，存在一个整数 c，使得 a + b = c。</p>
<p><strong>证明</strong>：我们可以使用引理 “整数的加法是满射” 来证明这个定理。根据这个引理，在整数集上的加法运算是满射的，即对于任意一个整数 c，总存在两个整数 a 和 b，使得 a + b = c。因此，我们可以得出结论，对于任意两个整数 a 和 b，存在一个整数 c，使得 a + b = c。</p>
<h2 id="结论"><a class="header" href="#结论">结论</a></h2>
<p>LEAN 是一个强大的定理证明系统，可以帮助数学家和计算机科学家形式化地证明定理。通过使用构造性数学的方法，在 LEAN 中进行定理证明可以提高证明的可执行性和严谨性。</p>
<p>希望本文对您理解 LEAN 定理证明有所帮助！</p>
<pre><code>  apply foo
  case &lt;tag of first goal&gt;  =&gt; &lt;proof of first goal&gt;
  case &lt;tag of second goal&gt; =&gt; &lt;proof of second goal&gt;
  case &lt;tag of third goal&gt;  =&gt; &lt;proof of third goal&gt;
  case &lt;tag of final goal&gt;  =&gt; &lt;proof of final goal&gt;
</code></pre>
<h1 id="lean-定理证明-1"><a class="header" href="#lean-定理证明-1">LEAN 定理证明</a></h1>
<h2 id="引言-2"><a class="header" href="#引言-2">引言</a></h2>
<p>Lean 是一款交互式证明助手和通用编程语言。它的设计目标是支持高效的定理证明和正确的程序开发。Lean 使用了基于类型论的直观、可理解的逻辑体系，并提供了一套表达式语言和工具来进行定理证明。</p>
<p>在 Lean 中，定理证明是通过构造一个证明对象来完成的。证明对象是一个具有严密结构的表达式，可以描述证明中的逻辑推导过程。Lean 的类型检查器可以验证证明对象的正确性，并确保其与推导过程完全一致。</p>
<p>下面我们将使用 Lean 来证明一个简单的定理。</p>
<h2 id="定理及证明"><a class="header" href="#定理及证明">定理及证明</a></h2>
<p><strong>定理</strong>：对于任意自然数 n，存在自然数 m，使得 n &lt; m。</p>
<p><strong>证明</strong>：我们使用归纳法来证明这个定理。</p>
<ul>
<li>基础情况：令 n = 0，我们可以选择 m = 1。此时显然有 0 &lt; 1 成立。</li>
<li>归纳步骤：假设对于某个自然数 k，存在自然数 m，使得 k &lt; m 成立。我们要证明对于 k + 1，也存在一个自然数 m'，使得 k + 1 &lt; m' 成立。</li>
</ul>
<p>根据归纳假设，存在一个自然数 m，使得 k &lt; m 成立。我们可以令 m' = m + 1，那么有：</p>
<p>k + 1 &lt; m + 1</p>
<p>根据自然数的性质，我们知道 m + 1 也是一个自然数。因此，对于任意自然数 k，都可以找到一个自然数 m'，使得 k + 1 &lt; m' 成立。</p>
<p>综上所述，我们完成了对于任意自然数 n，存在自然数 m，使得 n &lt; m 的证明。</p>
<h2 id="结论-1"><a class="header" href="#结论-1">结论</a></h2>
<p>Lean 是一款强大的定理证明助手，可以帮助人们进行形式化证明。通过使用 Lean，我们可以确保证明的正确性和一致性，并充分发挥计算机的计算能力来辅助证明过程。Lean 的设计使得定理证明更加直观和可理解，同时也提供了丰富的工具和库来支持证明的开发和共享。</p>
<pre><code>  apply foo
  { &lt;proof of first goal&gt;  }
  { &lt;proof of second goal&gt; }
  { &lt;proof of third goal&gt;  }
  { &lt;proof of final goal&gt;  }
</code></pre>
<p><em>策略组合子</em>是从旧策略中生成新策略的操作。在“by”块中已经隐式包含了一个顺序组合子：</p>
<pre><code class="language-lean">example (p q : Prop) (hp : p) : p ∨ q :=
  by apply Or.inl; assumption
</code></pre>
<p>这里，<code>apply Or.inl; assumption</code> 的功能上等同于一个单一的策略，它首先应用 <code>apply Or.inl</code>，然后应用 <code>assumption</code>。</p>
<p>在 <code>t₁ &lt;;&gt; t₂</code> 中，<code>&lt;;&gt;</code> 运算符提供了一个<em>并行</em>版本的序列化操作：<code>t₁</code> 应用于当前目标，然后 <code>t₂</code> 应用于<em>所有</em>生成的子目标：</p>
<pre><code class="language-lean">example (p q : Prop) (hp : p) (hq : q) : p ∧ q :=
  by constructor &lt;;&gt; assumption
</code></pre>
<p>这在目标的结果可以以统一的方式完成或者至少在所有目标上可以统一取得进展时特别有用。</p>
<p><code>first | t₁ | t₂ | ... | tₙ</code> 依次应用每个 <code>tᵢ</code>，直到其中一个成功或全部失败为止：</p>
<pre><code class="language-lean">example (p q : Prop) (hp : p) : p ∨ q := by
  first | apply Or.inl; assumption | apply Or.inr; assumption

example (p q : Prop) (hq : q) : p ∨ q := by
  first | apply Or.inl; assumption | apply Or.inr; assumption
</code></pre>
<p>在第一个例子中，左分支成功，而在第二个例子中，右分支成功。
在接下来的三个例子中，相同的复合策略在每种情况下都成功。</p>
<pre><code class="language-lean">example (p q r : Prop) (hp : p) : p ∨ q ∨ r :=
  by repeat (first | apply Or.inl; assumption | apply Or.inr | assumption)

example (p q r : Prop) (hq : q) : p ∨ q ∨ r :=
  by repeat (first | apply Or.inl; assumption | apply Or.inr | assumption)

example (p q r : Prop) (hr : r) : p ∨ q ∨ r :=
  by repeat (first | apply Or.inl; assumption | apply Or.inr | assumption)
</code></pre>
<p>该策略试图立即通过假设来解决左边的析取；如果失败，则尝试专注于右边的析取；如果这也行不通，则调用假设策略。</p>
<p>到目前为止，你肯定已经注意到策略可能会失败。事实上，正是“失败”状态导致<em>第一个</em>组合子回溯并尝试下一个策略。<code>try</code>组合子构建了一种总是成功的策略，尽管可能是以一种微不足道的方式：<code>try t</code>执行<code>t</code>并报告成功，即使<code>t</code>失败。它等同于<code>first | t | skip</code>，其中<code>skip</code>是一个什么都不做的策略（但成功地这么做）。在下一个示例中，第二个<code>constructor</code>在右边的合取<code>q ∧ r</code>上成功（请记住，析取和合取与右结合），但在第一个上失败。<code>try</code>策略确保了顺序组合成功。</p>
<pre><code class="language-lean">example (p q r : Prop) (hp : p) (hq : q) (hr : r) : p ∧ q ∧ r := by
  constructor &lt;;&gt; (try constructor) &lt;;&gt; assumption
</code></pre>
<p>小心：<code>repeat (try t)</code> 将会无限循环，因为内部 tactic 永远不会失败。</p>
<p>在证明中，通常会有多个目标待证明。并行序列是一种可以将单个 tactic 应用于多个目标的方式，但也有其他的方式可以实现这一点。例如，<code>all_goals t</code> 将会将<code>t</code> 应用于所有待证明的目标：</p>
<pre><code class="language-lean">example (p q r : Prop) (hp : p) (hq : q) (hr : r) : p ∧ q ∧ r := by
  constructor
  all_goals (try constructor)
  all_goals assumption
</code></pre>
<p>在这种情况下，<code>any_goals</code>策略提供了一种更强大的解决方案。它类似于<code>all_goals</code>，但是只要其参数在至少一个目标上成功，它就会成功。</p>
<pre><code class="language-lean">example (p q r : Prop) (hp : p) (hq : q) (hr : r) : p ∧ q ∧ r := by
  constructor
  any_goals constructor
  any_goals assumption
</code></pre>
<p><code>by</code> 块下面的第一个策略是重复地分割连词：</p>
<pre><code class="language-lean">example (p q r : Prop) (hp : p) (hq : q) (hr : r) :
      p ∧ ((p ∧ q) ∧ r) ∧ (q ∧ r ∧ p) := by
  repeat (any_goals constructor)
  all_goals assumption
</code></pre>
<p>实际上，我们可以将完整的策略压缩为一行代码：</p>
<pre><code class="language-lean">example (p q r : Prop) (hp : p) (hq : q) (hr : r) :
      p ∧ ((p ∧ q) ∧ r) ∧ (q ∧ r ∧ p) := by
  repeat (any_goals (first | constructor | assumption))
</code></pre>
<p>组合子 <code>focus t</code> 确保 <code>t</code> 只影响当前的目标，暂时隐藏其他目标。因此，如果 <code>t</code> 通常只影响当前目标，那么 <code>focus (all_goals t)</code> 的效果与 <code>t</code> 相同。</p>
<h2 id="重写"><a class="header" href="#重写">重写</a></h2>
<p><code>rewrite</code> 策略（简写为 <code>rw</code>）和 <code>simp</code> 策略在 <a href="./quantifiers_and_equality.html#calculational-proofs">Calculational Proofs</a> 中简要介绍过。在本节和下一节中，我们将更详细地讨论它们。</p>
<p><code>rewrite</code> 策略提供了一种基本的机制，用于对目标和假设应用替换，方便且高效地处理等式。这个策略的最基本形式是 <code>rewrite [t]</code>，其中 <code>t</code> 是一个类型为等式的项。例如，<code>t</code> 可以是上下文中的一个假设 <code>h : x = y</code>，也可以是一个通用的引理，如 <code>add_comm : ∀ x y, x + y = y + x</code>，在这种情况下，rewrite 策略尝试找到适当的 <code>x</code> 和 <code>y</code> 的实例化；或者它可以是任何断言具体或通用等式的复合项。在下面的示例中，我们使用这种基本形式，使用一个假设来重写目标。</p>
<pre><code class="language-lean">example (f : Nat → Nat) (k : Nat) (h₁ : f 0 = 0) (h₂ : k = 0) : f k = 0 := by
  rw [h₂] -- replace k with 0
  rw [h₁] -- replace f 0 with 0
</code></pre>
<p>在上面的例子中，第一次使用 <code>rw</code> 将目标 <code>f k = 0</code> 中的 <code>k</code> 替换为 <code>0</code>。然后，第二次使用将 <code>f 0</code> 替换为 <code>0</code>。该策略会自动关闭形如 <code>t = t</code> 的目标。下面是使用复合表达式进行重写的一个例子：</p>
<pre><code class="language-lean">example (x y : Nat) (p : Nat → Prop) (q : Prop) (h : q → x = y)
        (h' : p y) (hq : q) : p x := by
  rw [h hq]; assumption
</code></pre>
<p>在这里，<code>h hq</code> 建立了方程 <code>x = y</code>。</p>
<p>多个重写可以使用表示法<code>rw [t_1, ..., t_n]</code>进行组合，
这只是 <code>rw [t_1]; ...; rw [t_n]</code> 的简写。前面的例子可以写成以下形式：</p>
<pre><code class="language-lean">example (f : Nat → Nat) (k : Nat) (h₁ : f 0 = 0) (h₂ : k = 0) : f k = 0 := by
  rw [h₂, h₁]
</code></pre>
<p>默认情况下，<code>rw</code>在前向推导中使用等式，将左手边与一个表达式匹配，并用右手边替换它。符号<code>←t</code>可以用来指示该策略在逆向推导中使用等式<code>t</code>。</p>
<pre><code class="language-lean">example (f : Nat → Nat) (a b : Nat) (h₁ : a = b) (h₂ : f a = 0) : f b = 0 := by
  rw [←h₁, h₂]
</code></pre>
<p>在这个例子中，术语 <code>←h₁</code> 指示重写器将 <code>b</code> 替换为 <code>a</code>。在编辑器中，您可以输入向后箭头 <code>\l</code>。您还可以使用 ascii 等价物 <code>&lt;-</code>。</p>
<p>有时，恒等式的左侧能够与模式中的多个子项匹配，此时 <code>rw</code> 策略会在遍历表达式时选择第一个匹配项。如果这不是您想要的那个，请使用额外的参数来指定适当的子项。</p>
<pre><code class="language-lean">example (a b c : Nat) : a + b + c = a + c + b := by
  rw [Nat.add_assoc, Nat.add_comm b, ← Nat.add_assoc]

example (a b c : Nat) : a + b + c = a + c + b := by
  rw [Nat.add_assoc, Nat.add_assoc, Nat.add_comm b]

example (a b c : Nat) : a + b + c = a + c + b := by
  rw [Nat.add_assoc, Nat.add_assoc, Nat.add_comm _ b]
</code></pre>
<p>在上面的第一个例子中，第一步将 <code>a + b + c</code> 重写为 <code>a + (b + c)</code>。接下来的步骤将交换律应用于项 <code>b + c</code>；如果不指定参数，该策略会将 <code>a + (b + c)</code> 重写为 <code>(b + c) + a</code>。最后一步将逆向应用结合律，将 <code>a + (c + b)</code> 重写为 <code>a + c + b</code>。接下来的两个例子将结合律应用于双方，将括号移至右边，然后交换<code>b</code>和<code>c</code>。请注意，最后一个例子通过指定 <code>Nat.add_comm</code> 的第二个参数来指定重写应该在右侧进行。</p>
<p>默认情况下，<code>rewrite</code> 策略只会影响目标。<code>rw [t] at h</code> 的符号将重写<code>t</code> 应用于假设<code>h</code>。</p>
<pre><code class="language-lean">example (f : Nat → Nat) (a : Nat) (h : a + 0 = 0) : f a = f 0 := by
  rw [Nat.add_zero] at h
  rw [h]
</code></pre>
<p>第一步，<code>rw [Nat.add_zero] at h</code>，将假设 <code>a + 0 = 0</code> 重写为 <code>a = 0</code>。
然后，使用新的假设 <code>a = 0</code> 将目标重写为 <code>f 0 = f 0</code>。</p>
<p><code>rewrite</code> 策略不仅限于命题。
在下面的例子中，我们使用 <code>rw [h] at t</code> 将假设 <code>t : Tuple α n</code> 重写为 <code>t : Tuple α 0</code>。</p>
<pre><code class="language-lean">def Tuple (α : Type) (n : Nat) :=
  { as : List α // as.length = n }

example (n : Nat) (h : n = 0) (t : Tuple α n) : Tuple α 0 := by
  rw [h] at t
  exact t
</code></pre>
<h2 id="使用化简器"><a class="header" href="#使用化简器">使用化简器</a></h2>
<p>而 <code>rewrite</code> 被设计为一个操作目标的手术工具，化简器则提供了一种更强大的自动化形式。Lean 库中的许多恒等式都被标记为 <code>[simp]</code> 属性，而 <code>simp</code> 策略则使用它们来迭代地重写表达式中的子项。</p>
<pre><code class="language-lean">example (x y z : Nat) : (x + 0) * (0 + y * 1 + z * 0) = x * y := by
  simp

example (x y z : Nat) (p : Nat → Prop) (h : p (x * y))
        : p ((x + 0) * (0 + y * 1 + z * 0)) := by
  simp; assumption
</code></pre>
<p>在第一个例子中，目标中的等式左边被简化为使用涉及0和1的常见等式，将目标减少为<code>x * y = x * y</code>。此时，<code>simp</code>应用了自反性来完成它。在第二个例子中，<code>simp</code>将目标减少为<code>p (x * y)</code>，此时假设<code>h</code>完成它。以下是一些关于列表的额外例子：</p>
<pre><code class="language-lean">open List

example (xs : List Nat)
        : reverse (xs ++ [1, 2, 3]) = [3, 2, 1] ++ reverse xs := by
  simp

example (xs ys : List α)
        : length (reverse (xs ++ ys)) = length xs + length ys := by
  simp [Nat.add_comm]
</code></pre>
<p>与<code>rw</code>一样，您可以使用关键字<code>at</code>来简化一个假设：</p>
<pre><code class="language-lean">example (x y z : Nat) (p : Nat → Prop)
        (h : p ((x + 0) * (0 + y * 1 + z * 0))) : p (x * y) := by
  simp at h; assumption
</code></pre>
<p>此外，您可以使用“通配符”星号来简化所有的假设和目标证明：</p>
<pre><code class="language-lean">attribute [local simp] Nat.mul_comm Nat.mul_assoc Nat.mul_left_comm
attribute [local simp] Nat.add_assoc Nat.add_comm Nat.add_left_comm

example (w x y z : Nat) (p : Nat → Prop)
        (h : p (x * y + z * w * x)) : p (x * w * z + y * x) := by
  simp at *; assumption

example (x y z : Nat) (p : Nat → Prop)
        (h₁ : p (1 * x + y)) (h₂ : p (x * z * 1))
        : p (y + 0 + x) ∧ p (z * x) := by
  simp at * &lt;;&gt; constructor &lt;;&gt; assumption
</code></pre>
<p>对于交换律和结合律可适用的操作，比如自然数的乘法，简化器使用这两个定理来重写表达式，以及<em>左交换律</em>。对于乘法操作来说，左交换律可以表示为：<code>x * (y * z) = y * (x * z)</code>。<em>local</em>修饰符告诉简化器在当前文件（或部分或命名空间）中使用这些规则。看起来交换律和左交换律可能会引发循环的问题。但是简化器可以检测到那些可以使它们的参数互换的恒等式，并使用一种被称为<em>有序重写</em>的技术。这意味着系统会维护一个内部的项排序，并且仅在应用恒等式后顺序会减少的情况下才使用它。对于上述提到的三个恒等式，这会使得表达式中所有的括号都与其右侧相关，并且表达式以一种规范（尽管有些主观）的方式进行排序。因此，关于结合性和交换性等价的两个表达式将被重写成相同的规范形式。</p>
<pre><code class="language-lean"># attribute [local simp] Nat.mul_comm Nat.mul_assoc Nat.mul_left_comm
# attribute [local simp] Nat.add_assoc Nat.add_comm Nat.add_left_comm
example (w x y z : Nat) (p : Nat → Prop)
        : x * y + z * w * x = x * w * z + y * x := by
  simp

example (w x y z : Nat) (p : Nat → Prop)
        (h : p (x * y + z * w * x)) : p (x * w * z + y * x) := by
  simp; simp at h; assumption
</code></pre>
<p>与 <code>rewrite</code> 类似，您可以向 <code>simp</code> 发送一个包含一般引理、局部假设、待展开的定义和复合表达式的事实列表。<code>simp</code> 策略还识别 <code>←t</code> 语法，就像 <code>rewrite</code> 一样。无论哪种情况，附加规则被添加到用于简化术语的标识集合中。</p>
<pre><code class="language-lean">def f (m n : Nat) : Nat :=
  m + n + m

example {m n : Nat} (h : n = 1) (h' : 0 = m) : (f m n) = n := by
  simp [h, ←h', f]
</code></pre>
<p>常见的一种方法是使用局部假设来简化目标：</p>
<pre><code class="language-lean">example (f : Nat → Nat) (k : Nat) (h₁ : f 0 = 0) (h₂ : k = 0) : f k = 0 := by
  simp [h₁, h₂]
</code></pre>
<p>当简化时使用在本地环境中出现的所有假设，我们可以使用通配符符号 <code>*</code> ：</p>
<pre><code class="language-lean">example (f : Nat → Nat) (k : Nat) (h₁ : f 0 = 0) (h₂ : k = 0) : f k = 0 := by
  simp [*]
</code></pre>
<p>下面是另一个例子：</p>
<pre><code class="language-lean">example (u w x y z : Nat) (h₁ : x = y + z) (h₂ : w = u + x)
        : w = z + y + u := by
  simp [*, Nat.add_assoc, Nat.add_comm, Nat.add_left_comm]
</code></pre>
<p>简化器还会进行命题重写。例如，使用前提<code>p</code>，它将<code>p ∧ q</code>重写为<code>q</code>，将<code>p ∨ q</code>重写为<code>true</code>，然后通过简单证明来证明这些重写。重复这样的重写可以产生非平凡的命题推理。</p>
<pre><code class="language-lean">example (p q : Prop) (hp : p) : p ∧ q ↔ q := by
  simp [*]

example (p q : Prop) (hp : p) : p ∨ q := by
  simp [*]

example (p q r : Prop) (hp : p) (hq : q) : p ∧ (q ∨ r) := by
  simp [*]
</code></pre>
<p>下面的示例会简化所有的假设，然后使用它们来证明目标。</p>
<pre><code class="language-lean">example (u w x x' y y' z : Nat) (p : Nat → Prop)
        (h₁ : x + 0 = x') (h₂ : y + 0 = y')
        : x + y + 0 = x' + y' := by
  simp at *
  simp [*]
</code></pre>
<p><strong>一件使得简化器特别有用的事情是它的功能可以随着库的发展而增长。举个例子，假设我们定义了一个列表操作，它通过将其输入的反向追加到结果中来将其对称化：</strong></p>
<pre><code class="language-lean">def symmetrize {α : Type} : list α → list α
| [] := []
| (h::t) := (h::t) ++ (symmetrize t)
</code></pre>
<p><strong>This operation can be used to define the symmetric closure of a
relation:</strong></p>
<p><strong>这个操作可以用来定义一个关系的对称闭包：</strong></p>
<pre><code class="language-lean">def symmetric_closure {α : Type} (r : α → α → Prop) : α → α → Prop :=
λ a b, symmetrize [(a, b)] ⊆ r
</code></pre>
<p><strong>The definition of <code>symmetric_closure</code> makes use of the <code>symmetrize</code>
operation to add all pairs of elements that are already related by <code>r</code>,
as well as all pairs related by <code>r</code> in reverse order.</strong></p>
<p><strong><code>symmetric_closure</code> 的定义使用了 <code>symmetrize</code> 操作，它通过添加所有在 <code>r</code> 中已经相关的元素对，以及所有按相反顺序相关的元素对，来生成对称闭包。</strong></p>
<p><strong>In Lean, we can prove that <code>symmetric_closure</code> is indeed the
smallest relation that is contained in <code>r</code> and is symmetric:</strong></p>
<p><strong>在 Lean 中，我们可以证明 <code>symmetric_closure</code> 确实是包含在 <code>r</code> 中且对称的最小关系：</strong></p>
<pre><code class="language-lean">lemma symmetric_closure_is_smallest {α : Type} (r : α → α → Prop)
(sr : symmetric_closure r ≤ r)
(h : symmetric r)
: symmetric_closure r ≤ r :=
begin
  intros a b hab,
  cases hab with hb hr,
  { exact sr hb },
  { have hba : (b, a) ∈ symmetric_closure r,
    { rw symmetrize_append,
      apply mem_union_right,
      exact hr },
    exact sr hba }
end
</code></pre>
<p><strong>The proof starts by assuming that <code>symmetric_closure r</code> is already a
subset of <code>r</code>. Then, for any pair of elements <code>a</code> and <code>b</code> that are in
<code>symmetric_closure r</code>, we need to show that <code>a</code> and <code>b</code> are related by
<code>r</code>. We consider two cases:</strong></p>
<p><strong>证明首先假设 <code>symmetric_closure r</code> 已经是 <code>r</code> 的子集。然后，对于任意在 <code>symmetric_closure r</code> 中的元素对 <code>a</code> 和 <code>b</code>，我们需要证明 <code>a</code> 和 <code>b</code> 是由 <code>r</code> 相关的。我们分两种情况讨论：</strong></p>
<ul>
<li><strong>If <code>a</code> and <code>b</code> are already related by <code>r</code>, then we can directly
conclude that <code>a</code> and <code>b</code> are related by <code>r</code>.</strong></li>
</ul>
<p><strong>如果 <code>a</code> 和 <code>b</code> 已经由 <code>r</code> 相关，则我们可以直接得出 <code>a</code> 和 <code>b</code> 是由 <code>r</code> 相关的。</strong></p>
<ul>
<li><strong>If <code>a</code> and <code>b</code> are not related by <code>r</code>, then we need to show that
<code>(b, a)</code> is in <code>symmetric_closure r</code>. This can be done by applying
the symmetrize operation to the pair <code>(a, b)</code> and using the fact that
<code>r</code> is symmetric.</strong></li>
</ul>
<p><strong>如果 <code>a</code> 和 <code>b</code> 没有被 <code>r</code> 相关，则我们需要证明 <code>(b, a)</code> 在 <code>symmetric_closure r</code> 中。这可以通过对元素对 <code>(a, b)</code> 应用 symmetrize 操作，并利用 <code>r</code> 是对称的事实来完成。</strong></p>
<pre><code class="language-lean">def mk_symm (xs : List α) :=
  xs ++ xs.reverse
</code></pre>
<p>对于任意列表 <code>xs</code>，<code>reverse (mk_symm xs)</code> 等于 <code>mk_symm xs</code>，可以通过展开定义很容易证明：</p>
<pre><code class="language-lean">lemma reverse_mk_symm {α : Type*} (xs : list α) :
  reverse (mk_symm xs) = mk_symm xs :=
begin
  -- 使用反转的定义展开目标
  unfold reverse,
  -- 我们需要对被反转的列表进行归纳
  induction xs with x xs ih,
  -- Base case: 空列表
  { refl },
  -- Inductive case: xs = x :: xs
  -- 我们需要简化（simplification）来处理理论项
  { simp only [mk_symm_cons, reverse_append, ih],
    -- 在获得感兴趣的等式之前简化，这里是反转一个列表的等式
    rw [reverse_singleton, append_nil] }
end
</code></pre>
<p>因此，我们通过对定义进行展开和归纳来证明这个结论。</p>
<pre><code class="language-lean"># def mk_symm (xs : List α) :=
#  xs ++ xs.reverse
theorem reverse_mk_symm (xs : List α)
        : (mk_symm xs).reverse = mk_symm xs := by
  simp [mk_symm]
</code></pre>
<p>我们现在可以使用该定理来证明新的结果：</p>
<pre><code class="language-lean"># def mk_symm (xs : List α) :=
#  xs ++ xs.reverse
# theorem reverse_mk_symm (xs : List α)
#        : (mk_symm xs).reverse = mk_symm xs := by
#  simp [mk_symm]
example (xs ys : List Nat)
        : (xs ++ mk_symm ys).reverse = mk_symm ys ++ xs.reverse := by
  simp [reverse_mk_symm]

example (xs ys : List Nat) (p : List Nat → Prop)
        (h : p (xs ++ mk_symm ys).reverse)
        : p (mk_symm ys ++ xs.reverse) := by
  simp [reverse_mk_symm] at h; assumption
</code></pre>
<p>但通常情况下，使用 <code>reverse_mk_symm</code> 是正确的做法，如果用户不必显式地调用它会很方便。你可以通过在定义定理时将其标记为简化规则来实现这一点：</p>
<pre><code class="language-lean"># def mk_symm (xs : List α) :=
#  xs ++ xs.reverse
@[simp] theorem reverse_mk_symm (xs : List α)
        : (mk_symm xs).reverse = mk_symm xs := by
  simp [mk_symm]

example (xs ys : List Nat)
        : (xs ++ mk_symm ys).reverse = mk_symm ys ++ xs.reverse := by
  simp

example (xs ys : List Nat) (p : List Nat → Prop)
        (h : p (xs ++ mk_symm ys).reverse)
        : p (mk_symm ys ++ xs.reverse) := by
  simp at h; assumption
</code></pre>
<p>符号<code>@[simp]</code>声明<code>reverse_mk_symm</code>具有<code>[simp]</code>属性，并可以更明确地拼写出来：</p>
<pre><code class="language-lean"># def mk_symm (xs : List α) :=
#  xs ++ xs.reverse
theorem reverse_mk_symm (xs : List α)
        : (mk_symm xs).reverse = mk_symm xs := by
  simp [mk_symm]

attribute [simp] reverse_mk_symm

example (xs ys : List Nat)
        : (xs ++ mk_symm ys).reverse = mk_symm ys ++ xs.reverse := by
  simp

example (xs ys : List Nat) (p : List Nat → Prop)
        (h : p (xs ++ mk_symm ys).reverse)
        : p (mk_symm ys ++ xs.reverse) := by
  simp at h; assumption
</code></pre>
<p>定理的属性可以在定理声明之后的任何时间应用：</p>
<pre><code class="language-lean"># def mk_symm (xs : List α) :=
#  xs ++ xs.reverse
theorem reverse_mk_symm (xs : List α)
        : (mk_symm xs).reverse = mk_symm xs := by
  simp [mk_symm]

example (xs ys : List Nat)
        : (xs ++ mk_symm ys).reverse = mk_symm ys ++ xs.reverse := by
  simp [reverse_mk_symm]

attribute [simp] reverse_mk_symm

example (xs ys : List Nat) (p : List Nat → Prop)
        (h : p (xs ++ mk_symm ys).reverse)
        : p (mk_symm ys ++ xs.reverse) := by
  simp at h; assumption
</code></pre>
<p>然而，一旦属性被应用，就没有办法永久地移除它；它会在引入该属性所在文件的任何文件中保持存在。正如我们将在<a href="./interacting_with_lean.html#attributes">属性</a>一节中进一步讨论的那样，可以使用<code>local</code>修饰符将属性的作用域限定为当前文件或部分。</p>
<pre><code class="language-lean"># def mk_symm (xs : List α) :=
#  xs ++ xs.reverse
theorem reverse_mk_symm (xs : List α)
        : (mk_symm xs).reverse = mk_symm xs := by
  simp [mk_symm]

section
attribute [local simp] reverse_mk_symm

example (xs ys : List Nat)
        : (xs ++ mk_symm ys).reverse = mk_symm ys ++ xs.reverse := by
  simp

example (xs ys : List Nat) (p : List Nat → Prop)
        (h : p (xs ++ mk_symm ys).reverse)
        : p (mk_symm ys ++ xs.reverse) := by
  simp at h; assumption
end
</code></pre>
<p>在该部分之外，简化器将不再默认使用 <code>reverse_mk_sym</code>。</p>
<p>请注意，我们讨论的各种 <code>simp</code> 选项 -- 给出一个明确的规则列表，使用 <code>at</code> 来指定位置 -- 可以结合使用，但它们列出的顺序是固定的。在编辑器中，您可以通过将光标置于 <code>simp</code> 标识符上以查看与之关联的文档字符串来查看正确的顺序。</p>
<p>还有两个有用的修饰符。默认情况下，<code>simp</code> 包含了所有使用 <code>[simp]</code> 属性标记过的定理。使用 <code>simp only</code> 可以排除这些默认规则，允许您使用更明确的规则列表。在下面的示例中，减号和 <code>only</code> 被用来阻止应用 <code>reverse_mk_sym</code>。</p>
<pre><code class="language-lean">def mk_symm (xs : List α) :=
  xs ++ xs.reverse
@[simp] theorem reverse_mk_symm (xs : List α)
        : (mk_symm xs).reverse = mk_symm xs := by
  simp [mk_symm]

example (xs ys : List Nat) (p : List Nat → Prop)
        (h : p (xs ++ mk_symm ys).reverse)
        : p (mk_symm ys ++ xs.reverse) := by
  simp at h; assumption

example (xs ys : List Nat) (p : List Nat → Prop)
        (h : p (xs ++ mk_symm ys).reverse)
        : p ((mk_symm ys).reverse ++ xs.reverse) := by
  simp [-reverse_mk_symm] at h; assumption

example (xs ys : List Nat) (p : List Nat → Prop)
        (h : p (xs ++ mk_symm ys).reverse)
        : p ((mk_symm ys).reverse ++ xs.reverse) := by
  simp only [List.reverse_append] at h; assumption
</code></pre>
<p><code>simp</code>策略有许多配置选项。例如，我们可以通过以下方式启用上下文简化。</p>
<pre><code class="language-lean">example : if x = 0 then y + x = y else x ≠ 0 := by
  simp (config := { contextual := true })
</code></pre>
<p>当 <code>contextual := true</code> 时，当简化 <code>y + x = y</code> 时，<code>simp</code> 使用了 <code>x = 0</code> 这一事实，而在简化另一分支时使用了 <code>x ≠ 0</code>。这里是另一个例子。</p>
<pre><code class="language-lean">import data.complex.basic

theorem complex.mul_zero (a : ℂ) : a * 0 = 0 :=
begin
  simp,
end
</code></pre>
<p>这个定理表明对于任意复数 <code>a</code>，<code>a * 0</code> 等于 <code>0</code>。在证明过程中，我们使用了 <code>simp</code> 策略，并设置 <code>contextual := true</code>。这样一来，在简化 <code>a * 0</code> 的过程中，<code>simp</code> 会使用 <code>0 = 0 * 0</code> 这一事实，从而将 <code>a * 0</code> 简化为 <code>0</code>。</p>
<pre><code class="language-lean">example : ∀ (x : Nat) (h : x = 0), y + x = y := by
  simp (config := { contextual := true })
</code></pre>
<p>另一个有用的配置选项是 <code>arith := true</code>，它可以启用算术化简。它非常有用，以至于 <code>simp_arith</code> 是 <code>simp (config := { arith := true })</code> 的缩写。</p>
<pre><code class="language-lean">example : 0 &lt; 1 + x ∧ x + y + 2 ≥ y + 1 := by
  simp_arith
</code></pre>
<h2 id="分割策略"><a class="header" href="#分割策略">分割策略</a></h2>
<p><code>split</code> 策略适用于拆分嵌套的 <code>if-then-else</code> 和 <code>match</code> 表达式。对于一个具有 <code>n</code> 个 case 的 <code>match</code> 表达式，<code>split</code> 策略最多生成 <code>n</code> 个子目标。下面是一个例子。</p>
<pre><code class="language-lean">def f (x y z : Nat) : Nat :=
  match x, y, z with
  | 5, _, _ =&gt; y
  | _, 5, _ =&gt; y
  | _, _, 5 =&gt; y
  | _, _, _ =&gt; 1

example (x y z : Nat) : x ≠ 5 → y ≠ 5 → z ≠ 5 → z = w → f x y w = 1 := by
  intros
  simp [f]
  split
  . contradiction
  . contradiction
  . contradiction
  . rfl
</code></pre>
<p>我们可以将上述证明的策略压缩如下。</p>
<pre><code>Proof.
  intros H.
  induction H as [x Hx|y Hy Hz].
  - apply Hx.
  - apply Hy.
Defined.
</code></pre>
<p>Proof.(证明)
intros H.
induction H as [x Hx|y Hy Hz].</p>
<ul>
<li>apply Hx.</li>
<li>apply Hy.
Defined.</li>
</ul>
<pre><code class="language-lean"># def f (x y z : Nat) : Nat :=
#  match x, y, z with
#  | 5, _, _ =&gt; y
#  | _, 5, _ =&gt; y
#  | _, _, 5 =&gt; y
#  | _, _, _ =&gt; 1
example (x y z : Nat) : x ≠ 5 → y ≠ 5 → z ≠ 5 → z = w → f x y w = 1 := by
  intros; simp [f]; split &lt;;&gt; first | contradiction | rfl
</code></pre>
<p>策略 <code>split &lt;;&gt; first | contradiction | rfl</code> 首先应用 <code>split</code> 策略，
然后对于每个生成的子目标，尝试 <code>contradiction</code>，如果 <code>contradiction</code> 失败，则尝试 <code>rfl</code>。
和 <code>simp</code> 类似，我们可以将 <code>split</code> 应用于特定的假设。</p>
<pre><code class="language-lean">def g (xs ys : List Nat) : Nat :=
  match xs, ys with
  | [a, b], _ =&gt; a+b+1
  | _, [b, c] =&gt; b+1
  | _, _      =&gt; 1

example (xs ys : List Nat) (h : g xs ys = 0) : False := by
  simp [g] at h; split at h &lt;;&gt; simp_arith at h
</code></pre>
<p><strong>可扩展的策略</strong></p>
<p>在下面的例子中，我们使用<code>syntax</code>命令来定义<code>triv</code>符号。然后，我们使用<code>macro_rules</code>命令来指定在使用<code>triv</code>时应该执行哪些操作。你可以提供不同的展开方式，策略解释器将尝试它们直到找到一个成功的。</p>
<pre><code class="language-lean">-- Define a new tactic notation
syntax &quot;triv&quot; : tactic

macro_rules
  | `(tactic| triv) =&gt; `(tactic| assumption)

example (h : p) : p := by
  triv

-- You cannot prove the following theorem using `triv`
-- example (x : α) : x = x := by
--  triv

-- Let's extend `triv`. The tactic interpreter
-- tries all possible macro extensions for `triv` until one succeeds
macro_rules
  | `(tactic| triv) =&gt; `(tactic| rfl)

example (x : α) : x = x := by
  triv

example (x : α) (h : p) : x = x ∧ p := by
  apply And.intro &lt;;&gt; triv

-- We now add a (recursive) extension
macro_rules | `(tactic| triv) =&gt; `(tactic| apply And.intro &lt;;&gt; triv)

example (x : α) (h : p) : x = x ∧ p := by
  triv
</code></pre>
<h2 id="习题"><a class="header" href="#习题">习题</a></h2>
<ol>
<li>
<p>回到 <a href="./propositions_and_proofs.html">Chapter Propositions and Proofs</a> 和 <a href="./quantifiers_and_equality.html">Chapter Quantifiers and Equality</a>，尽量用策略证明重新做一遍已有的习题，使用适当的 <code>rw</code> 和 <code>simp</code>。</p>
</li>
<li>
<p>使用策略组合器获得以下命题的一行证明：</p>
</li>
</ol>
<pre><code class="language-lean">example (p q r : Prop) (hp : p)
        : (p ∨ q ∨ r) ∧ (q ∨ p ∨ r) ∧ (q ∨ r ∨ p) := by
  admit
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="与lean的交互"><a class="header" href="#与lean的交互">与Lean的交互</a></h1>
<p>您现在已经熟悉了依赖类型理论的基本知识，既作为定义数学对象的语言，也作为构建证明的语言。您唯一缺少的是定义新数据类型的机制。在下一章中，我们将填补这个空白，引入“归纳数据类型”的概念。但是首先，在本章中，我们暂时离开类型论的机制，探索与Lean交互的一些实用方面。</p>
<p>这里的信息并不都是对您立即有用的。我们建议您快速浏览本节以了解Lean的功能，并根据需要再回头查看。</p>
<h2 id="导入文件"><a class="header" href="#导入文件">导入文件</a></h2>
<p>Lean的前端目标是解释用户输入，构造形式化表达式，并检查其形式是否正确。Lean还支持使用各种编辑器，提供持续的检查和反馈。更多信息可以在 <a href="https://leanprover.github.io/documentation/">Lean文档页</a>上找到。</p>
<p>Lean标准库中的定义和定理分布在多个文件中。用户可能还希望使用其他库，或者跨多个文件开发自己的项目。当Lean启动时，它会自动导入<code>Init</code>文件夹中的库内容，其中包括一些基本定义和构造。因此，我们在这里介绍的大部分示例都可以直接使用。</p>
<p>但是，如果要使用其他文件，您需要手动导入它们，即在文件开头使用<code>import</code>语句。例如，命令</p>
<pre><code>import data.nat.basic
</code></pre>
<p>导入了Lean的标准库中的<code>data.nat.basic</code>文件中的内容。</p>
<pre><code>import Bar.Baz.Blah
</code></pre>
<p>引入文件 <code>Bar/Baz/Blah.olean</code>，其中描述被解释为相对于 Lean 的 <em>搜索路径</em> 的路径。关于如何确定搜索路径的信息可以在<a href="https://leanprover.github.io/documentation/">文档页</a>上找到。默认情况下，它包括标准库目录以及（在一些上下文中）用户本地项目的根目录。也可以指定相对于当前目录的导入；例如，导入是传递的。换句话说，如果你导入了 <code>Foo</code> 和 <code>Foo</code> 导入了 <code>Bar</code>，那么你也可以访问 <code>Bar</code> 的内容，不需要显式导入它。</p>
<h2 id="关于节的更多信息"><a class="header" href="#关于节的更多信息">关于节的更多信息</a></h2>
<p>Lean 提供了各种节区的机制来帮助结构化一个理论。你在<a href="./dependent_type_theory.html#variables-and-sections">变量和节区</a>中看到，<code>section</code> 命令不仅可以将理论的相关元素进行分组，还可以声明作为定义和定理的参数的变量，根据需要插入。请记住，“variable”命令的目的是声明用于定理的变量，如下面的例子所示：</p>
<pre><code class="language-lean">section
variable (x y : Nat)

def double := x + x

#check double y
#check double (2 * x)

attribute [local simp] Nat.add_assoc Nat.add_comm Nat.add_left_comm

theorem t1 : double (x + y) = double x + double y := by
  simp [double]

#check t1 y
#check t1 (2 * x)

theorem t2 : double (x * y) = double x * y := by
  simp [double, Nat.add_mul]

end
</code></pre>
<p>&quot;double&quot;的定义不需要将&quot;x&quot;声明为参数；LEAN会自动检测到这种依赖并自动插入。同样，LEAN也会自动检测到在&quot;t1&quot;和&quot;t2&quot;中出现的&quot;x&quot;，并在那里自动插入。请注意，&quot;double&quot;的参数中没有&quot;y&quot;。变量仅在实际使用它们的声明中包含。</p>
<h2 id="更多关于命名空间"><a class="header" href="#更多关于命名空间">更多关于命名空间</a></h2>
<p>在LEAN中，标识符由分层的<em>名称</em>表示，例如&quot;Foo.Bar.baz&quot;。在<a href="./dependent_type_theory.html#namespaces">命名空间</a>中，我们看到LEAN提供了处理层级名称的机制。命令&quot;namespace foo&quot;会在每个定义和定理的名称前面加上&quot;foo&quot;，直到遇到&quot;end foo&quot;为止。然后，命令&quot;open foo&quot;会为以&quot;foo&quot;为前缀的定义和定理创建临时的<em>别名</em>。</p>
<pre><code class="language-lean">namespace Foo
def bar : Nat := 1
end Foo

open Foo

#check bar
#check Foo.bar
</code></pre>
<p>下面是LEAN 定理证明定义的翻译:</p>
<h5 id="定义11-定理"><a class="header" href="#定义11-定理"><strong>定义1.1 定理</strong></a></h5>
<p>一个“定理”是一个希望通过具体推演来证明的断言。我们在一个解释内容的上下文中讨论定理，在这个上下文中，我们相信至少有一种方法可以根据定理是否正确的情况来评判。一个定理的“证明”是一个使定理被普遍接受的论据。</p>
<h5 id="定义12-命题"><a class="header" href="#定义12-命题"><strong>定义1.2 命题</strong></a></h5>
<p>一个“命题”是一个可以被证明为真或假的断言。在一段特定的解释内容的上下文中，我们可以根据命题是否正确对其进行判断。命题的证明是一个论据，通过该论据我们可以得出命题的真实性或虚假性。</p>
<h5 id="定义13-假设"><a class="header" href="#定义13-假设"><strong>定义1.3 假设</strong></a></h5>
<p>一个“假设”是一个我们暂时认为是真的断言，但我们并不确定它是否真实。当我们提出假设时，我们接受它的约束，并将其用于进一步的推理和论证。在证明中，我们会明确列出所有的假设，并在推理的每一步中采用恰当的假设。</p>
<h5 id="定义14-定理证明的结构"><a class="header" href="#定义14-定理证明的结构"><strong>定义1.4 定理证明的结构</strong></a></h5>
<p>一个定理证明由以下几个部分组成：</p>
<ol>
<li>证明的起点(基础)：一个证明的起点是一个已知的、被普遍接受的事实或真理，它不需要被证明。我们可以从一个证明的起点开始进行推理。</li>
<li>步骤：一个证明是由一系列有条理的步骤组成的。每一步都使用推理规则将某个断言转化为另一个断言。每一步的正确性都可以被证明，并且必须根据前一步的结果建立。</li>
<li>结论：一个证明的结论是一个表明定理确认为真的最后的断言。存在许多可能的推理路径可以得出同一个结论，但是在证明中我们只需要关注一个。</li>
</ol>
<h5 id="定义15-推理规则"><a class="header" href="#定义15-推理规则"><strong>定义1.5 推理规则</strong></a></h5>
<p>推理规则是一种逻辑工具，用于在论证过程中从给定断言推导出新的断言。常见的推理规则包括引入和排除规则。推理规则必须合乎逻辑并且正确使用。</p>
<h5 id="定义16-证明的策略"><a class="header" href="#定义16-证明的策略"><strong>定义1.6 证明的策略</strong></a></h5>
<p>证明的策略是指在证明过程中应用的推理规则和方法。选择一个适当的策略是证明定理的关键。了解不同的策略和如何运用它们对于有效的证明是至关重要的。</p>
<h5 id="定义17-反证法"><a class="header" href="#定义17-反证法"><strong>定义1.7 反证法</strong></a></h5>
<p>反证法是一种证明方法，其中我们假设定理不成立，然后通过推理证明这个假设是不可行的。如果我们最终得出了一个矛盾的结论或违反已知事实的结果，则我们可以确定定理是成立的。</p>
<h5 id="定义18-归纳证明"><a class="header" href="#定义18-归纳证明"><strong>定义1.8 归纳证明</strong></a></h5>
<p>归纳证明是一种证明方法，其中我们首先证明一个断言在某个基础情形下成立，然后在递归地证明该断言在所有后续情形下也成立。归纳证明常用于处理具有可复制结构的问题，并且需要通过基础情形的推理来逐步扩展到更复杂的情形。</p>
<h5 id="定义19-直接证明"><a class="header" href="#定义19-直接证明"><strong>定义1.9 直接证明</strong></a></h5>
<p>直接证明是一种证明方法，其中我们根据定理的前提使用推理规则逐步推导出结论。直接证明通常是最常见和直观的证明方法之一。</p>
<h5 id="补充说明"><a class="header" href="#补充说明"><em>补充说明：</em></a></h5>
<p>上述定义和解释是根据 LEAN 定理证明的一些常见术语和概念进行描述。这些定义和概念为理解证明的结构和方法提供了基础。在实际应用中，根据具体问题的特点和要求，证明的方法和策略可能会有所不同。在进行定理证明时，确保逻辑正确性、严谨性和清晰性是非常重要的。</p>
<pre><code class="language-lean">def Foo.bar : Nat := 1
</code></pre>
<p>在LEAN中，&quot;LEAN&quot;被视为一个宏，并展开为</p>
<pre><code class="language-lean">namespace Foo
def bar : Nat := 1
end Foo
</code></pre>
<p>尽管定理和定义的名称必须是唯一的，但用于标识它们的别名可以不唯一。当我们打开一个命名空间时，标识符可能是模糊的。Lean试图使用类型信息来消除上下文中的歧义，但您始终可以通过给出完整的名称来消除歧义。为此，字符串 <code>_root_</code> 是对空前缀的显式描述。</p>
<pre><code class="language-lean">def String.add (a b : String) : String :=
  a ++ b

def Bool.add (a b : Bool) : Bool :=
  a != b

def add (α β : Type) : Type := Sum α β

open Bool
open String
-- #check add -- ambiguous
#check String.add           -- String → String → String
#check Bool.add             -- Bool → Bool → Bool
#check _root_.add           -- Type → Type → Type

#check add &quot;hello&quot; &quot;world&quot;  -- String
#check add true false       -- Bool
#check add Nat Nat          -- Type
</code></pre>
<p>我们可以使用 <code>protected</code> 关键字阻止创建较短的别名：</p>
<pre><code class="language-lean">protected def Foo.bar : Nat := 1

open Foo

-- #check bar -- error
#check Foo.bar
</code></pre>
<p>这通常用于像 <code>Nat.rec</code> 和 <code>Nat.recOn</code> 这样的名称，以防止常见名称的重载。</p>
<p><code>open</code> 命令允许多种变体。命令可以接受以下参数：</p>
<pre><code class="language-lean">open Nat (succ zero gcd)
#check zero     -- Nat
#eval gcd 15 6  -- 3
</code></pre>
<p>创建仅对列出的标识符创建别名。命令</p>
<pre><code class="language-lean">open Nat hiding succ gcd
#check zero     -- Nat
-- #eval gcd 15 6  -- error
#eval Nat.gcd 15 6  -- 3
</code></pre>
<p>在 <code>Nat</code> 命名空间中为除了所列标识符之外的所有内容创建别名。</p>
<pre><code class="language-lean">open Nat renaming mul → times, add → plus
#eval plus (times 2 2) 3  -- 7
</code></pre>
<p>创建别名把 <code>Nat.mul</code> 重命名为 <code>times</code>，把 <code>Nat.add</code> 重命名为 <code>plus</code>。</p>
<p>有时候从一个命名空间导出别名到另一个命名空间或顶层是很有用的。这个命令可以实现：</p>
<pre><code class="language-lean">export Nat (succ add sub)
</code></pre>
<p>在当前命名空间中为 <code>succ</code>，<code>add</code> 和 <code>sub</code> 创建别名，以便在打开命名空间时可以使用这些别名。如果该命令在命名空间之外使用，则这些别名将导出到顶层命名空间。</p>
<h2 id="属性"><a class="header" href="#属性">属性</a></h2>
<p>Lean 的主要功能是将用户输入转换为形式化表达式，然后通过内核进行检查，最后存储在环境中以供以后使用。但是，一些命令对环境产生其他影响，例如为环境中的对象分配属性、定义符号表示法或声明类型类的实例，如 <a href="./type_classes.html">Type Classes 章节</a> 中所述。这些命令大多具有全局影响，也就是说，它们不仅在当前文件中生效，而且在导入了该文件的任何文件中都生效。但是，这种命令通常支持 <code>local</code> 修饰符，表示它们仅在当前<code>section</code> 或 <code>namespace</code> 关闭之前，或当前文件结束之前生效。</p>
<p>在 <a href="./tactics.html#using-the-simplifier">Using the Simplifier 章节</a> 中，我们看到定理可以使用 <code>[simp]</code> 属性进行注释，这样它们就可以被简化器使用。下面的例子定义了列表上的前缀关系，证明了该关系是自反的，并将 <code>[simp]</code> 属性赋予了该定理。</p>
<pre><code class="language-lean">def isPrefix (l₁ : List α) (l₂ : List α) : Prop :=
  ∃ t, l₁ ++ t = l₂

@[simp] theorem List.isPrefix_self (as : List α) : isPrefix as as :=
  ⟨[], by simp⟩

example : isPrefix [1, 2, 3] [1, 2, 3] := by
  simp
</code></pre>
<p>之后，简化器通过将 <code>isPrefix [1, 2, 3] [1, 2, 3]</code> 重写为 <code>True</code> 来证明它。</p>
<p>也可以在定义之后的任何时候分配属性：</p>
<pre><code class="language-lean"># def isPrefix (l₁ : List α) (l₂ : List α) : Prop :=
#  ∃ t, l₁ ++ t = l₂
theorem List.isPrefix_self (as : List α) : isPrefix as as :=
  ⟨[], by simp⟩

attribute [simp] List.isPrefix_self
</code></pre>
<p>在所有这些情况下，属性在引入声明所在文件的任何文件中都保持有效。添加<code>local</code>修饰符限制了作用域：</p>
<pre><code class="language-lean"># def isPrefix (l₁ : List α) (l₂ : List α) : Prop :=
#  ∃ t, l₁ ++ t = l₂
section

theorem List.isPrefix_self (as : List α) : isPrefix as as :=
  ⟨[], by simp⟩

attribute [local simp] List.isPrefix_self

example : isPrefix [1, 2, 3] [1, 2, 3] := by
  simp

end

-- Error:
-- example : isPrefix [1, 2, 3] [1, 2, 3] := by
--  simp
</code></pre>
<p>另一个例子中，我们可以使用 <code>instance</code> 命令将符号 <code>≤</code> 赋予关系 <code>isPrefix</code>。该命令将在 <a href="./type_classes.html">第10章 类型类</a> 中详细解释，它通过向关联的定义添加一个 <code>[instance]</code> 属性来实现。</p>
<pre><code class="language-lean">def isPrefix (l₁ : List α) (l₂ : List α) : Prop :=
  ∃ t, l₁ ++ t = l₂

instance : LE (List α) where
  le := isPrefix

theorem List.isPrefix_self (as : List α) : as ≤ as :=
  ⟨[], by simp⟩
</code></pre>
<p>该定理的证明也可以是本地的：</p>
<pre><code class="language-md">**定理：LEAN 定理证明可以在本地完成。**

*证明：*
为了证明这个定理，我们需要展示一个本地证明的步骤。假设我们有一个 LEAN 环境设置在我们的本地计算机上。

1. 在本地计算机上安装 LEAN 环境。可以从 LEAN 的官方网站下载并按照说明进行安装。

2. 创建一个 LEAN 项目。可以使用 LEAN 提供的命令行工具 `leanproject` 来创建一个新的项目。

3. 在项目中创建一个新的 LEAN 文件并命名为 `proof.lean`。

4. 在 `proof.lean` 文件中，导入需要用到的 LEAN 库。

   ```lean
   import tactic
</code></pre>
<ol start="5">
<li>
<p>添加一个定理声明并给定其名称和陈述。例如：</p>
<pre><code class="language-lean">theorem my_theorem : 1 + 1 = 2 :=
begin
  sorry
end
</code></pre>
<p>这个定理声明声明了 &quot;1 + 1 = 2&quot;。</p>
</li>
<li>
<p>编写证明脚本。使用 tactic 编写证明脚本的过程类似于将传统的数学证明转化为形式化证明的步骤。例如：</p>
<pre><code class="language-lean">theorem my_theorem : 1 + 1 = 2 :=
begin
  exact rfl
end
</code></pre>
<p>这个证明脚本使用了 <code>exact rfl</code> 来表示证明是显然的。</p>
</li>
<li>
<p>运行 LEAN 环境中的验证器。使用 LEAN 提供的命令行工具 <code>lean</code> 来验证证明脚本的正确性。</p>
</li>
<li>
<p>如果验证通过，那么我们成功地在本地完成了 LEAN 定理证明。如果验证失败，可以根据错误提示进行修正。</p>
</li>
</ol>
<p>因此，我们证明了该定理可以在本地完成，只需在本地计算机设置 LEAN 环境并按照上述步骤进行操作即可。</p>
<pre><code>
通过以上步骤，我们证明了该定理可以在本地完成。

```lean
# def isPrefix (l₁ : List α) (l₂ : List α) : Prop :=
#   ∃ t, l₁ ++ t = l₂
def instLe : LE (List α) :=
  { le := isPrefix }

section
attribute [local instance] instLe

example (as : List α) : as ≤ as :=
  ⟨[], by simp⟩

end

-- Error:
-- example (as : List α) : as ≤ as :=
--  ⟨[], by simp⟩
</code></pre>
<p>在下面的 <a href="interacting_with_lean.html#notation">注释</a> 部分，我们将讨论 Lean 的定义符号的机制，并且可以看到它们也支持 <code>local</code> 修饰符。然而，在 <a href="interacting_with_lean.html#setting-options">设置选项</a> 部分中，我们将讨论 Lean 的设置选项的机制，它不遵循这个模式：选项<strong>只能</strong>在局部范围内进行设置，也就是说，它们的作用域始终限定在当前节或当前文件中。</p>
<h2 id="更多关于隐含参数"><a class="header" href="#更多关于隐含参数">更多关于隐含参数</a></h2>
<p>在 <a href="./dependent_type_theory.html#implicit-arguments">隐含参数</a> 部分中，我们看到如果 Lean 将一个项 <code>t</code> 的类型显示为 <code>{x : α} → β x</code>，那么花括号表示 <code>x</code> 已被标记为 <em>隐含参数</em>。这意味着每当你写下 <code>t</code> 时，会插入一个占位符或者说“空洞”，这样 <code>t</code> 就会被替换为 <code>@t _</code>。如果你不希望这样发生，你必须写成 <code>@t</code>。</p>
<p>请注意，隐含参数会被急切地插入。假设我们定义一个带有如上所示参数的函数 <code>f (x : Nat) {y : Nat} (z : Nat)</code>。然后，当我们不带其他参数写出表达式 <code>f 7</code> 时，它将被解析为 <code>f 7 _</code>。Lean 提供了一个更弱的注解 <code>{{y : Nat}}</code>，它指定一个占位符只能在后续的显式参数之前添加。这个注解还可以用 <code>⦃y : Nat⦄</code> 的形式来写，其中 unicode 括号分别键入为 <code>\{{</code> 和 <code>\}}</code>。使用这个注解，表达式 <code>f 7</code> 将被解析为原样，而 <code>f 7 3</code> 将被解析为 <code>f 7 _ 3</code>，正如使用强注解时一样。</p>
<p>为了说明这种差异，考虑下面的例子，它展示了一个自反的欧几里得关系既是对称的又是传递的。</p>
<pre><code class="language-lean">def reflexive {α : Type u} (r : α → α → Prop) : Prop :=
  ∀ (a : α), r a a

def symmetric {α : Type u} (r : α → α → Prop) : Prop :=
  ∀ {a b : α}, r a b → r b a

def transitive {α : Type u} (r : α → α → Prop) : Prop :=
  ∀ {a b c : α}, r a b → r b c → r a c

def euclidean {α : Type u} (r : α → α → Prop) : Prop :=
  ∀ {a b c : α}, r a b → r a c → r b c

theorem th1 {α : Type u} {r : α → α → Prop}
            (reflr : reflexive r) (euclr : euclidean r)
            : symmetric r :=
  fun {a b : α} =&gt;
  fun (h : r a b) =&gt;
  show r b a from euclr h (reflr _)

theorem th2 {α : Type u} {r : α → α → Prop}
            (symmr : symmetric r) (euclr : euclidean r)
            : transitive r :=
  fun {a b c : α} =&gt;
  fun (rab : r a b) (rbc : r b c) =&gt;
  euclr (symmr rab) rbc

theorem th3 {α : Type u} {r : α → α → Prop}
            (reflr : reflexive r) (euclr : euclidean r)
            : transitive r :=
 @th2 _ _ (@th1 _ _ reflr @euclr) @euclr

variable (r : α → α → Prop)
variable (euclr : euclidean r)

#check euclr  -- r ?m1 ?m2 → r ?m1 ?m3 → r ?m2 ?m3
</code></pre>
<p>结果被分解为以下几个小步骤：<code>th1</code> 证明了一个既是反身性又是欧几里得性的关系是对称的，而 <code>th2</code> 证明了一个既是对称性又是欧几里得性的关系是传递的。然后 <code>th3</code> 结合了这两个结果。但请注意，我们必须手动禁用 <code>th1</code>、<code>th2</code> 和 <code>euclr</code> 中的隐式参数，否则会插入太多的隐式参数。如果使用弱隐式参数，问题将得到解决：</p>
<pre><code class="language-lean">def reflexive {α : Type u} (r : α → α → Prop) : Prop :=
  ∀ (a : α), r a a

def symmetric {α : Type u} (r : α → α → Prop) : Prop :=
  ∀ {{a b : α}}, r a b → r b a

def transitive {α : Type u} (r : α → α → Prop) : Prop :=
  ∀ {{a b c : α}}, r a b → r b c → r a c

def euclidean {α : Type u} (r : α → α → Prop) : Prop :=
  ∀ {{a b c : α}}, r a b → r a c → r b c

theorem th1 {α : Type u} {r : α → α → Prop}
            (reflr : reflexive r) (euclr : euclidean r)
            : symmetric r :=
  fun {a b : α} =&gt;
  fun (h : r a b) =&gt;
  show r b a from euclr h (reflr _)

theorem th2 {α : Type u} {r : α → α → Prop}
            (symmr : symmetric r) (euclr : euclidean r)
            : transitive r :=
  fun {a b c : α} =&gt;
  fun (rab : r a b) (rbc : r b c) =&gt;
  euclr (symmr rab) rbc

theorem th3 {α : Type u} {r : α → α → Prop}
            (reflr : reflexive r) (euclr : euclidean r)
            : transitive r :=
  th2 (th1 reflr euclr) euclr

variable (r : α → α → Prop)
variable (euclr : euclidean r)

#check euclr  -- euclidean r
</code></pre>
<p>有一种隐式参数用方括号 <code>[</code> 和 <code>]</code> 表示，它们用于类型类，如在<a href="./type_classes.html">类型类章节</a>中所解释的。</p>
<h2 id="表示法"><a class="header" href="#表示法">表示法</a></h2>
<p>Lean 中的标识符可以包含任何字母数字字符，包括希腊字符（除了 ∀ , Σ 和 λ ，它们在依赖类型理论中有特殊含义）。它们还可以包含下标，在输入所需的下标字符之后输入 <code>\_</code>。</p>
<p>Lean 的解析器是可扩展的，也就是说，我们可以定义新的表示法。</p>
<p>Lean 的语法可以在每个级别上由用户进行扩展和定制，从基本的“mixfix”表示法到定制的展开器。实际上，所有内置的语法都是使用相同的机制和 API 进行解析和处理的。在本节中，我们将描述和解释各种扩展点。</p>
<p>虽然引入新的表示法在编程语言中是相对少见的特性，有时甚至因其可能模糊代码而受到批评，但它是形式化的无价工具，可以简洁地表示所述领域的已建立惯例和表示法。超越基本表示法，Lean 的能力通过 (行为良好的) 宏将常见的样板代码分解出来，并嵌入整个定制的领域专用语言（DSL）来以文本方式高效和可读地编码子问题，可以极大地有益于程序员和证明工程师。</p>
<h3 id="表示法和优先级"><a class="header" href="#表示法和优先级">表示法和优先级</a></h3>
<p>最基本的语法扩展命令允许引入新的（或重载现有的）前缀、中缀和后缀运算符。</p>
<pre><code class="language-lean">infixl:65   &quot; + &quot; =&gt; HAdd.hAdd  -- left-associative
infix:50    &quot; = &quot; =&gt; Eq         -- non-associative
infixr:80   &quot; ^ &quot; =&gt; HPow.hPow  -- right-associative
prefix:100  &quot;-&quot;   =&gt; Neg.neg
# set_option quotPrecheck false
postfix:max &quot;⁻¹&quot;  =&gt; Inv.inv
</code></pre>
<p>在描述运算符类型（其 &quot;结合性&quot;）的初始命令名称后，我们给出了由冒号 <code>:</code> 隔开的运算符的 <em>解析优先级</em>，然后是用双引号括起的新的或现有的标记（空格用于漂亮的打印），然后是箭头 <code>=&gt;</code> 后该运算符应该转换为的函数。</p>
<p>优先级是一个自然数，描述运算符与其参数的&quot;紧密程度&quot;，编码了操作的顺序。我们可以通过查看上述展开的命令来更清楚地说明这一点：</p>
<pre><code class="language-lean">notation:65 lhs:65 &quot; + &quot; rhs:66 =&gt; HAdd.hAdd lhs rhs
notation:50 lhs:51 &quot; = &quot; rhs:51 =&gt; Eq lhs rhs
notation:80 lhs:81 &quot; ^ &quot; rhs:80 =&gt; HPow.hPow lhs rhs
notation:100 &quot;-&quot; arg:100 =&gt; Neg.neg arg
# set_option quotPrecheck false
notation:1024 arg:1024 &quot;⁻¹&quot; =&gt; Inv.inv arg  -- `max` is a shorthand for precedence 1024
</code></pre>
<p>原来，第一个代码块中的所有命令实际上都是将更通用的 <code>notation</code> 命令转换为命令 <em>宏</em>。我们将在下面学习如何编写这样的宏。<code>notation</code> 命令不仅接受单个令牌，还接受带有优先级的令牌序列和命名的术语占位符，这些占位符可以在 <code>=&gt;</code> 的右侧引用，并将被在那个位置解析的相应术语替换掉。具有优先级 <code>p</code> 的占位符只接受至少在该位置具有优先级 <code>p</code> 的记法。因此，字符串 <code>a + b + c</code> 不能被解析为等同于 <code>a + (b + c)</code>，因为 <code>infixl</code> 记法的右手操作数的优先级比记法本身大 1。相反，<code>infixr</code> 使用记法的优先级作为右手操作数的优先级，因此 <code>a ^ b ^ c</code> <em>可以</em> 被解析为 <code>a ^ (b ^ c)</code>。请注意，如果我们直接使用 <code>notation</code> 来引入中缀记法，例如</p>
<pre><code class="language-lean"># set_option quotPrecheck false
notation:65 lhs:65 &quot; ~ &quot; rhs:65 =&gt; wobble lhs rhs
</code></pre>
<p>当优先级无法足够确定结合性时，Lean 的解析器将默认为右结合性。更准确地说，当存在歧义的文法时，Lean 的解析器遵循本地的<em>最长解析</em>规则：在解析 <code>a ~</code> 中的右侧时，在当前优先级允许的情况下，它将继续解析，不仅停留在 <code>b</code>，还会解析 <code>~ c</code>。因此，该术语等价于 <code>a ~ (b ~ c)</code>。</p>
<p>如上所述，<code>notation</code> 命令允许我们自由地定义任意的<em>混合采用</em>语法，可以自由地混合标记和占位符。</p>
<pre><code class="language-lean"># set_option quotPrecheck false
notation:max &quot;(&quot; e &quot;)&quot; =&gt; e
notation:10 Γ &quot; ⊢ &quot; e &quot; : &quot; τ =&gt; Typing Γ e τ
</code></pre>
<p>如果两个符号重叠，我们再次应用最长的解析规则：</p>
<pre><code class="language-lean">notation:65 a &quot; + &quot; b:66 &quot; + &quot; c:66 =&gt; a + b - c
#eval 1 + 2 + 3  -- 0
</code></pre>
<p>Lean中，自然数类型<code>Nat</code>与整数类型<code>Int</code>不同。但是有一个名为<code>Int.ofNat</code>的函数，它将自然数嵌入整数中，也就是说我们可以在需要时将任何自然数视为整数。Lean有机制来检测和插入这种类型的<em>强制转换</em>。</p>
<pre><code class="language-lean">variable (m n : Nat)
variable (i j : Int)

#check i + m      -- i + Int.ofNat m : Int
#check i + m + j  -- i + Int.ofNat m + j : Int
#check i + m + n  -- i + Int.ofNat m + Int.ofNat n : Int
</code></pre>
<h2 id="显示信息"><a class="header" href="#显示信息">显示信息</a></h2>
<p>有多种方式可以查询 Lean 的当前状态以及当前上下文中可用的对象和定理的信息。你已经见过其中两种最常见的方式，<code>#check</code> 和 <code>#eval</code>。请记住，<code>#check</code> 通常与 <code>@</code> 运算符一起使用，该运算符使定理或定义的所有参数显式。此外，你还可以使用 <code>#print</code> 命令来获取有关任何标识符的信息。如果标识符表示定义或定理，Lean 将打印符号的类型和定义。如果它是一个常量或一个公理，Lean 将指示这个事实，并显示类型。</p>
<pre><code class="language-lean">-- examples with equality
#check Eq
#check @Eq
#check Eq.symm
#check @Eq.symm

#print Eq.symm

-- examples with And
#check And
#check And.intro
#check @And.intro

-- a user-defined function
def foo {α : Type u} (x : α) : α := x

#check foo
#check @foo
#print foo
</code></pre>
<h2 id="设置选项"><a class="header" href="#设置选项">设置选项</a></h2>
<p>Lean维护了许多内部变量，用户可以通过设置这些变量来控制其行为。设置语法如下所示：</p>
<pre><code>set_option &lt;name&gt; &lt;value&gt;
</code></pre>
<p>一组非常有用的选项可以控制 Lean 的 <em>pretty-printer</em> 显示项的方式。以下选项接受 true 或 false 作为输入：</p>
<pre><code>pp.explicit  : display implicit arguments
pp.universes : display hidden universe parameters
pp.notation  : display output using defined notations
</code></pre>
<p>作为一个例子，以下设置会产生更长的输出：</p>
<pre><code class="language-lean">set_option pp.explicit true
set_option pp.universes true
set_option pp.notation false

#check 2 + 2 = 4
#reduce (fun x =&gt; x + 2) = (fun x =&gt; x + 3)
#check (fun x =&gt; x + 1) 1
</code></pre>
<p>命令“<code>set_option pp.all true</code>”一次性进行了这些设置，而“<code>set_option pp.all false</code>”则恢复到先前的值。在调试证明或理解晦涩的错误信息时，Pretty Printing（美化输出）附加信息通常非常有用。然而，太多的信息可能会让人不知所措，在普通交互中，Lean的默认设置通常就足够了。</p>
<!--
扩展提示
-----------------

当你要求Lean处理表达式，例如``λ x y z, f (x + y) z``，你会隐含一些信息。例如，``x``，``y``和``z``的类型必须从上下文中推断出来，符号``+``可能是重载的，并且``f``可能有一些需要填入的隐式参数。而且我们将在 :numref:`第%s章 <type_classes>` 中看到，一些隐式参数是通过一种称为“类型类解析”（*type class resolution*）的过程来合成的。我们也在上一章中已经看到，一些表达式的部分可以通过策略框架来构造。

推断一些隐式参数是很直接的。例如，假设函数``f``的类型是``Π {α : Type*}, α → α → α``，而Lean正在尝试解析表达式``f n``，其中``n``可以被推断为类型``nat``。那么，隐式参数``α``就必须是``nat``。然而，某些推断问题是*高阶的*。例如，等式的替换操作``eq.subst``具有以下类型：

.. code-block:: text

    eq.subst : ∀ {α : Sort u} {p : α → Prop} {a b : α},
                 a = b → p a → p b

现在假设我们给出了``a b : ℕ``和``h₁ : a = b``和``h₂ : a * b > a``。那么，在表达式``eq.subst h₁ h₂``中，``p``可以是以下任何一个：

-  ``λ x, x * b > x``
-  ``λ x, x * b > a``
-  ``λ x, a * b > x``
-  ``λ x, a * b > a``

换句话说，我们的意图可能是要替换``h₂``中的第一个或第二个``a``，或者两者都替换，或者都不替换。在推断归纳谓词或推断函数参数时也会出现类似的歧义。甚至第二阶单一化已知是不可判定的。因此，Lean依靠启发式方法来填充此类参数，当它无法猜测出正确参数时，需要显式提供。
更糟糕的是，有时需要展开定义，有时需要根据底层逻辑框架的计算规则进行表达式约简。这时，Lean不得不依靠启发式算法来确定何时展开或者约简。

然而，有一些属性可以用来向展开器提供一些提示。其中一类属性确定了定义的展开程度：常量可以用属性“[reducible]”、“[semireducible]”或“[irreducible]”标记。定义默认被标记为“[semireducible]”。带有“[reducible]”属性的定义会被立即展开；如果你将定义视为缩写，那么这个属性是合适的。展开器避免展开带有“[irreducible]”属性的定义。定理默认被标记为“[irreducible]”，因为通常证明与展开过程无关。

值得强调的是，这些属性只是对展开器的提示。在检查展开后的项的正确性时，Lean的内核会展开它需要展开的所有定义。与其他属性一样，上述属性可以使用“local”修饰符，这样它们只在当前章节或文件中生效。

Lean还有一族属性来控制推导策略。一个定义或定理可以被标记为“[elab_with_expected_type]”、“[elab_simple]”或“[elab_as_eliminator]”。当应用于一个定义“f”时，这些属性影响到应用于参数的表达式“f a b c ...”的推导过程。默认情况下，使用“[elab_with_expected_type]”属性，参数“a”、“b”、“c”等根据它们的期望类型进行推导，该类型可以从“f”和前面的参数推断出来。相反，使用“[elab_simple]”属性，参数从左到右进行推导，不传播它们的类型信息。最后一个属性“[elab_as_eliminator]”通常用于递归器、归纳原理和“eq.subst”等消去器。它使用一个单独的启发式算法来推断高阶参数。我们将在下一章节中详细讨论这类操作。

这些属性可以在定义后进行赋值和重新赋值，你可以使用“local”修饰符限定它们的作用范围。此外，在表达式中在一个标识符前加上“@”符号会让展开器使用“[elab_simple]”策略；这样做的想法是，当你显式提供复杂的参数时，你希望展开器更加重视这些信息。实际上，Lean提供了另一种注解“@@”，它使得第一个高阶参数之前的参数保持隐式。例如，“@@eq.subst”使得等式的类型隐式，但是让替换的上下文变得显式。
使用库
-----------------

要有效地使用 Lean，您将不可避免地需要使用库中的定义和定理。回想一下，在文件开头的 ``import`` 命令可以导入其他文件中先前编译的结果，并且导入是可传递的；如果您导入 ``Foo``，而 ``Foo`` 导入了 ``Bar``，那么 ``Bar`` 的定义和定理也就会对您可用。但打开一个命名空间的操作，提供了更短的名称，这种操作不会传递。在每个文件中，您需要打开您希望使用的命名空间。

一般来说，您需要熟悉库及其内容，这样您就会知道有哪些定理、定义、符号和资源可供您使用。下面我们将看到，Lean 的编辑器模式也可以帮助您找到所需的内容，但是直接研究库的内容往往是不可避免的。Lean 的标准库可以在网上找到，位于 GitHub 上：

- [https://github.com/leanprover/lean4/tree/master/src/Init](https://github.com/leanprover/lean4/tree/master/src/Init)
- [https://github.com/leanprover/std4/tree/main/Std](https://github.com/leanprover/std4/tree/main/Std)

您可以使用 GitHub 的浏览器界面查看这些目录和文件的内容。如果您在自己的计算机上安装了 Lean，可以在 ``lean`` 文件夹中找到库，并通过文件管理器进行探索。每个文件顶部的注释标头提供了额外的信息。

Lean 的库开发人员遵循通用的命名准则，以便更容易猜出您所需的定理的名称，或者在支持此功能的 Lean 模式编辑器中使用制表符补全来找到它，这将在下一节中讨论。标识符通常是 `camelCase`，类型是 `CamelCase`。对于定理名称，我们依赖于描述性的名称，其中不同的组件由 `_` 分隔：

```lean
#check Nat.succ_ne_zero
#check Nat.zero_add
#check Nat.mul_one
#check Nat.le_of_succ_le_succ
```

在 Lean 中，标识符可以组织成层次化的命名空间。例如，命名空间 ``Nat`` 中名为 ``le_of_succ_le_succ`` 的定理的完整名称为 ``Nat.le_of_succ_le_succ``，但通过命令 ``open Nat``（对于未标记为 `protected` 的名称）可以使用较短的名称。我们将在[归纳类型章节](./inductive_types.md)和[结构体和记录章节](./structures_and_records.md)中看到，在 Lean 中定义结构体和归纳数据类型会生成相关的操作，并且这些操作存储在与定义类型同名的命名空间中。例如，乘积类型带有以下操作：

```lean
#check @Prod.mk
#check @Prod.fst
#check @Prod.snd
#check @Prod.rec
```

第一个用于构造一对，而后两个 `Prod.fst` 和 `Prod.snd` 用于分别投射两个元素。最后一个 `Prod.rec` 提供了另一种机制，可以根据两个组件上的一个函数来定义关于产品上的函数。像 `Prod.rec` 这样的名称是 *protected* 的，这意味着即使 `Prod` 命名空间打开，仍然必须使用完整的名称。

通过命题作为类型的对应关系，逻辑连词也是归纳类型的实例，因此我们也倾向于对它们使用点符号表示法：

```lean
#check @And.intro
#check @And.casesOn
#check @And.left
#check @And.right
#check @Or.inl
#check @Or.inr
#check @Or.elim
#check @Exists.intro
#check @Exists.elim
#check @Eq.refl
#check @Eq.subst
```

自动绑定隐式参数
--------------

在前一节中，我们展示了隐式参数如何使函数的使用更方便。然而，像 `compose` 这样的函数仍然很冗长。请注意，本节中的宇宙多态 `compose` 比之前定义的版本还要冗长。

```lean
universe u v w
def compose {α : Type u} {β : Type v} {γ : Type w}
            (g : β → γ) (f : α → β) (x : α) : γ :=
  g (f x)
```

你可以在定义 `compose` 时提供宇宙参数来避免使用 `universe` 命令。

```lean
def compose.{u, v, w}
            {α : Type u} {β : Type v} {γ : Type w}
            (g : β → γ) (f : α → β) (x : α) : γ :=
  g (f x)
```

Lean 4 支持一项名为*auto bound implicit arguments*的新功能。它使得像`compose`这样的函数更加方便地编写。当 Lean 处理声明的头部时，任何未绑定的标识符如果是一个单个小写字母或希腊字母，它将自动添加为隐式参数。有了这个特性，我们可以将`compose`写成下面这样：

```lean
def compose (g : β → γ) (f : α → β) (x : α) : γ :=
  g (f x)

#check @compose
-- {β : Sort u_1} → {γ : Sort u_2} → {α : Sort u_3} → (β → γ) → (α → β) → α → γ
```

请注意，Lean 使用 `Sort` 而不是 `Type` 推断出更一般的类型。

尽管我们喜欢这个功能，并且在实现 Lean 时广泛使用它，
但我们意识到一些用户可能对此感到不舒服。因此，您可以使用命令 `set_option autoImplicit false` 来禁用它。

```lean
set_option autoImplicit false
/- The following definition produces `unknown identifier` errors -/
-- def compose (g : β → γ) (f : α → β) (x : α) : γ :=
--   g (f x)
```

隐式 Lambda 函数
---------------

在 Lean 3 的标准库中，我们经常会遇到可怕的 `@`+`_` 的写法的[实例](https://github.com/leanprover/lean/blob/master/library/init/category/reader.lean#L39)。这种写法通常用于期望类型是带有隐式参数的函数类型，并且我们有一个同样带有隐式参数的常量（例如在示例中的 `reader_t.pure`）。在 Lean 4 中，解析器会自动引入 Lambda 函数来消耗隐式参数。我们仍在探索此功能并分析其影响，但到目前为止，体验非常积极。以下是使用 Lean 4 隐式 Lambda 函数的上述链接中的示例。

```lean
# variable (ρ : Type) (m : Type → Type) [Monad m]
instance : Monad (ReaderT ρ m) where
  pure := ReaderT.pure
  bind := ReaderT.bind
```

用户可以通过使用 `@` 或在 lambda 表达式中使用 `{}` 或 `[]` 的 binder 注释来禁用隐式 lambda 功能。以下是一些示例:

```lean
# namespace ex2
def id1 : {α : Type} → α → α :=
  fun x => x

def listId : List ({α : Type} → α → α) :=
  (fun x => x) :: []

-- In this example, implicit lambda introduction has been disabled because
-- we use `@` before `fun`
def id2 : {α : Type} → α → α :=
  @fun α (x : α) => id1 x

def id3 : {α : Type} → α → α :=
  @fun α x => id1 x

def id4 : {α : Type} → α → α :=
  fun x => id1 x

-- In this example, implicit lambda introduction has been disabled
-- because we used the binder annotation `{...}`
def id5 : {α : Type} → α → α :=
  fun {α} x => id1 x
# end ex2
```

对于简单函数的糖语法
-------------------------

在 Lean 3 中，我们可以使用括号将中缀运算符转化为简单函数。例如，`(+1)` 是 `fun x, x + 1` 的一种糖语法。在 Lean 4 中，我们使用 `·` 作为占位符来推广这种表示法。下面是几个例子：

```lean
# namespace ex3
#check (· + 1)
-- fun a => a + 1
#check (2 - ·)
-- fun a => 2 - a
#eval [1, 2, 3, 4, 5].foldl (·*·) 1
-- 120

def f (x y z : Nat) :=
  x + y + z

#check (f · 1 ·)
-- fun a b => f a 1 b

#eval [(1, 2), (3, 4), (5, 6)].map (·.1)
-- [1, 3, 5]
# end ex3
```

与Lean 3中一样，符号需要用括号激活，并且通过收集嵌套的 `·` 来创建 lambda 抽象。收集过程会被嵌套的括号打断。在下面的例子中，会创建两个不同的 lambda 表达式。

```lean
#check (Prod.mk · (· + 1))
-- fun a => (a, fun b => b + 1)
```

命名参数
---------------

命名参数让您可以通过与其在参数列表中的位置相匹配而不是位置指定参数的值。如果您不记得参数的顺序但知道它们的名称，您可以以任何顺序发送参数。您还可以在 Lean 无法推断参数的值时为隐式参数提供值。命名参数还通过标识每个参数表示的内容来提高代码的可读性。

```lean
def sum (xs : List Nat) :=
  xs.foldl (init := 0) (·+·)

#eval sum [1, 2, 3, 4]
-- 10

example {a b : Nat} {p : Nat → Nat → Nat → Prop} (h₁ : p a b b) (h₂ : b = a)
    : p a a b :=
  Eq.subst (motive := fun x => p a x b) h₂ h₁
```

在下面的例子中，我们将说明命名参数和默认参数之间的交互作用。

```python
def greet(name, greeting='Hello'):
    print(f"{greeting}, {name}!")

# 通过位置参数调用函数
greet('Alice')
# 输出: Hello, Alice!

# 通过命名参数调用函数
greet(greeting='Hi', name='Bob')
# 输出: Hi, Bob!

# 结合使用位置参数和命名参数
greet('Charlie', greeting='Hey')
# 输出: Hey, Charlie!
```

在上面的示例中，我们定义了一个名为 `greet` 的函数，它接受两个参数 `name` 和 `greeting`，其中 `greeting` 的默认值为 `'Hello'`。当我们调用这个函数时，可以根据位置或名称提供参数的值。

第一个示例中，我们只提供了一个位置参数 `'Alice'`，因此函数会使用默认的 `greeting` 值 `'Hello'`，输出结果为 `'Hello, Alice!'`。

第二个示例中，我们使用了命名参数来调用函数，即通过指定参数的名称来提供参数的值。在这种情况下，我们通过 `'Hi'` 和 `'Bob'` 分别为 `greeting` 和 `name` 参数提供了值，输出结果为 `'Hi, Bob!'`。

第三个示例中，我们展示了如何结合使用位置参数和命名参数。我们通过位置参数 `'Charlie'` 为 `name` 参数提供了值，同时通过命名参数 `greeting='Hey'` 为 `greeting` 参数提供了值，输出结果为 `'Hey, Charlie!'`。

通过这些示例，我们可以看到名为 `greet` 的函数如何利用命名参数和默认参数的交互作用，使得函数调用更加灵活和易读。

```lean
def f (x : Nat) (y : Nat := 1) (w : Nat := 2) (z : Nat) :=
  x + y + w - z

example (x z : Nat) : f (z := z) x = x + 1 + 2 - z := rfl

example (x z : Nat) : f x (z := z) = x + 1 + 2 - z := rfl

example (x y : Nat) : f x y = fun z => x + y + 2 - z := rfl

example : f = (fun x z => x + 1 + 2 - z) := rfl

example (x : Nat) : f x = fun z => x + 1 + 2 - z := rfl

example (y : Nat) : f (y := 5) = fun x z => x + 5 + 2 - z := rfl

def g {α} [Add α] (a : α) (b? : Option α := none) (c : α) : α :=
  match b? with
  | none   => a + c
  | some b => a + b + c

variable {α} [Add α]

example : g = fun (a c : α) => a + c := rfl

example (x : α) : g (c := x) = fun (a : α) => a + x := rfl

example (x : α) : g (b? := some x) = fun (a c : α) => a + x + c := rfl

example (x : α) : g x = fun (c : α) => x + c := rfl

example (x y : α) : g x y = fun (c : α) => x + y + c := rfl
```

您可以使用 `..` 作为 `_` 提供缺少的显式参数。
此功能与命名参数结合使用，非常适用于模式匹配。以下是一个例子：

```lean
def foo (x y z : ℕ) : ℕ :=
x + y + z

def bar : ℕ :=
let args : Σ'(x y z : ℕ), x = y ∧ y = z := ⟨2, _, _⟩,
    ⟨x, y, z⟩ := args in
foo x y z

#reduce bar -- 6
```

在这个示例中，我们定义了 `foo` 函数，该函数接受三个自然数参数 `x`、`y` 和 `z`，并返回它们的总和。然后我们定义了 `bar` 函数，它使用命名参数的优势在调用 `foo` 时仅提供了部分参数。`args` 是一个 `Σ'` 类型的变量，它具有类型 `(x y z : ℕ), x = y ∧ y = z`，即它包含了一个自然数三元组以及两个相等的条件。通过使用 `_`，我们省略了 `args` 的 `y` 和 `z` 参数。然后，我们解构 `args` 并将 `x`、`y` 和 `z` 绑定到其对应的值上。最后，我们调用 `foo` 函数，并传递解构出的参数 `x`、`y` 和 `z`。最终，我们通过 `#reduce` 验证了 `bar` 函数的输出结果为 6。

这个示例展示了 Lean 的 `..` 和命名参数的强大功能，通过使用这些特性，我们可以在编写模式时更加灵活和简洁。

```lean
inductive Term where
  | var    (name : String)
  | num    (val : Nat)
  | add    (fn : Term) (arg : Term)
  | lambda (name : String) (type : Term) (body : Term)

def getBinderName : Term → Option String
  | Term.lambda (name := n) .. => some n
  | _ => none

def getBinderType : Term → Option Term
  | Term.lambda (type := t) .. => some t
  | _ => none
```

当 Lean 能够自动推断出明确的参数时，省略号也是很有用的，这样我们就可以避免使用一系列的 `_`。

```lean
example (f : Nat → Nat) (a b c : Nat) : f (a + b + c) = f (a + (b + c)) :=
  congrArg f (Nat.add_assoc ..)
```

<div style="break-before: page; page-break-before: always;"></div><h1 id="归纳类型"><a class="header" href="#归纳类型">归纳类型</a></h1>
<p>我们已经看到，Lean 的形式基础包括基本类型 <code>Prop, Type 0, Type 1, Type 2, ...</code>，并且允许形成依赖函数类型 <code>(x : α) → β</code>。在示例中，我们还使用了其他类型，如 <code>Bool</code>, <code>Nat</code>, <code>Int</code>，以及类型构造函数，如 <code>List</code> 和乘积 <code>×</code>。实际上，在 Lean 的库中，除了宇宙和依赖箭头之外的每个具体类型，以及除了依赖箭头之外的每个类型构造函数，都是归纳类型的一个实例。令人惊讶的是，可以仅基于类型宇宙、依赖箭头类型和归纳类型来构建数学的实质性结构；其他所有内容都是从这些基础上推导出来的。</p>
<p>直观地说，归纳类型是从指定的构造函数列表构建起来的。在 Lean 中，指定此类类型的语法如下：</p>
<pre><code>inductive Foo where
  | constructor₁ : ... → Foo
  | constructor₂ : ... → Foo
  ...
  | constructorₙ : ... → Foo
</code></pre>
<p>直观地说，每个构造函数都指定了一种从<code>Foo</code>的先前构造值中构建新对象的方式。类型<code>Foo</code>仅由以这种方式构建的对象组成。归纳声明中的第一个字符<code>|</code>是可选的。我们还可以使用逗号而不是<code>|</code>来分隔构造函数。</p>
<p>我们将在下面看到，构造函数的参数可以包括类型为<code>Foo</code>的对象，但需要满足一定的“正性”约束，这保证了<code>Foo</code>的元素从底部向上构建。粗略地说，每个<code>...</code>可以是从<code>Foo</code>和先前定义的类型构造的任何箭头类型，其中<code>Foo</code>（如果存在）仅出现为依赖箭头类型的“目标”。</p>
<p>我们将提供一些归纳类型的示例。我们还将考虑上面方案的轻微推广，即相互定义的归纳类型和所谓的<em>归纳族</em>。</p>
<p>与逻辑联结词一样，每个归纳类型都具有引入规则，显示如何构造该类型的元素，并具有消除规则，显示如何在另一构造中“使用”该类型的元素。与逻辑联结词的类比应该不会令人惊讶；正如我们将在下面看到的，它们也是归纳类型构造的例子。您已经见过归纳类型的引入规则：它们只是在类型定义中指定的构造函数。消除规则提供了对该类型的递归原则，其中包括归纳原则作为一种特殊情况。</p>
<p>在下一章中，我们将介绍Lean的函数定义包，它提供了更方便的方式来定义在归纳类型上的函数并进行归纳证明。但是由于归纳类型的概念非常基础，我们认为从一个低级的、亲身实践的理解开始是很重要的。我们将先从一些基本的归纳类型示例开始，然后逐步提升到更复杂和复杂的示例。</p>
<h2 id="枚举类型"><a class="header" href="#枚举类型">枚举类型</a></h2>
<p>最简单的归纳类型是具有有限、枚举列表的类型。</p>
<pre><code class="language-lean">inductive Weekday where
  | sunday : Weekday
  | monday : Weekday
  | tuesday : Weekday
  | wednesday : Weekday
  | thursday : Weekday
  | friday : Weekday
  | saturday : Weekday
</code></pre>
<p><code>inductive</code> 命令创建了一个新的类型 <code>Weekday</code>。所有的构造函数都存在于 <code>Weekday</code> 命名空间中。</p>
<pre><code class="language-lean"># inductive Weekday where
#  | sunday : Weekday
#  | monday : Weekday
#  | tuesday : Weekday
#  | wednesday : Weekday
#  | thursday : Weekday
#  | friday : Weekday
#  | saturday : Weekday
#check Weekday.sunday
#check Weekday.monday

open Weekday

#check sunday
#check monday
</code></pre>
<p>当声明<code>Weekday</code>归纳类型时，可以省略<code>：Weekday</code>。</p>
<pre><code class="language-lean">inductive Weekday where
  | sunday
  | monday
  | tuesday
  | wednesday
  | thursday
  | friday
  | saturday
</code></pre>
<p>将<code>sunday</code>，<code>monday</code>，...，<code>saturday</code>视为<code>Weekday</code>的互不相同的元素，并且没有其他区别性质。消除原则<code>Weekday.rec</code>与类型<code>Weekday</code>及其构造函数一起定义。它也被称为一个<em>递归器</em>，它使得类型“归纳”:它允许我们通过为每个构造器分配值来在<code>Weekday</code>上定义一个函数。直观上讲，归纳类型完全由构造器生成，并且没有超出其构造器构造的元素。</p>
<p>我们将使用<code>match</code>表达式来定义一个从<code>Weekday</code>到自然数的函数：</p>
<pre><code class="language-lean"># inductive Weekday where
#  | sunday : Weekday
#  | monday : Weekday
#  | tuesday : Weekday
#  | wednesday : Weekday
#  | thursday : Weekday
#  | friday : Weekday
#  | saturday : Weekday
open Weekday

def numberOfDay (d : Weekday) : Nat :=
  match d with
  | sunday    =&gt; 1
  | monday    =&gt; 2
  | tuesday   =&gt; 3
  | wednesday =&gt; 4
  | thursday  =&gt; 5
  | friday    =&gt; 6
  | saturday  =&gt; 7

#eval numberOfDay Weekday.sunday  -- 1
#eval numberOfDay Weekday.monday  -- 2
#eval numberOfDay Weekday.tuesday -- 3
</code></pre>
<p>注意，<code>match</code> 表达式是使用在声明归纳类型时生成的 <em>递归体</em> <code>Weekday.rec</code> 进行编译的。</p>
<pre><code class="language-lean"># inductive Weekday where
#  | sunday : Weekday
#  | monday : Weekday
#  | tuesday : Weekday
#  | wednesday : Weekday
#  | thursday : Weekday
#  | friday : Weekday
#  | saturday : Weekday
open Weekday

def numberOfDay (d : Weekday) : Nat :=
  match d with
  | sunday    =&gt; 1
  | monday    =&gt; 2
  | tuesday   =&gt; 3
  | wednesday =&gt; 4
  | thursday  =&gt; 5
  | friday    =&gt; 6
  | saturday  =&gt; 7

set_option pp.all true
#print numberOfDay
-- ... numberOfDay.match_1
#print numberOfDay.match_1
-- ... Weekday.casesOn ...
#print Weekday.casesOn
-- ... Weekday.rec ...
#check @Weekday.rec
/-
@Weekday.rec.{u}
 : {motive : Weekday → Sort u} →
    motive Weekday.sunday →
    motive Weekday.monday →
    motive Weekday.tuesday →
    motive Weekday.wednesday →
    motive Weekday.thursday →
    motive Weekday.friday →
    motive Weekday.saturday →
    (t : Weekday) → motive t
-/
</code></pre>
<p>在声明归纳数据类型时，可以使用 <code>deriving Repr</code> 来指导 Lean 自动生成一个将 <code>Weekday</code> 对象转换为文本的函数。这个函数被 <code>#eval</code> 命令用于显示 <code>Weekday</code> 对象。</p>
<pre><code class="language-lean">inductive Weekday where
  | sunday
  | monday
  | tuesday
  | wednesday
  | thursday
  | friday
  | saturday
  deriving Repr

open Weekday

#eval tuesday   -- Weekday.tuesday
</code></pre>
<p>通常情况下，将与一个结构相关的定义和定理分组放在具有相同名称的命名空间中非常有用。例如，我们可以将<code>numberOfDay</code>函数放在<code>Weekday</code>命名空间中。然后，在打开命名空间时，我们可以使用更短的名称。</p>
<p>我们可以定义从<code>Weekday</code>到<code>Weekday</code>的函数：</p>
<pre><code class="language-lean"># inductive Weekday where
#  | sunday : Weekday
#  | monday : Weekday
#  | tuesday : Weekday
#  | wednesday : Weekday
#  | thursday : Weekday
#  | friday : Weekday
#  | saturday : Weekday
#  deriving Repr
namespace Weekday
def next (d : Weekday) : Weekday :=
  match d with
  | sunday    =&gt; monday
  | monday    =&gt; tuesday
  | tuesday   =&gt; wednesday
  | wednesday =&gt; thursday
  | thursday  =&gt; friday
  | friday    =&gt; saturday
  | saturday  =&gt; sunday

def previous (d : Weekday) : Weekday :=
  match d with
  | sunday    =&gt; saturday
  | monday    =&gt; sunday
  | tuesday   =&gt; monday
  | wednesday =&gt; tuesday
  | thursday  =&gt; wednesday
  | friday    =&gt; thursday
  | saturday  =&gt; friday

#eval next (next tuesday)      -- Weekday.thursday
#eval next (previous tuesday)  -- Weekday.tuesday

example : next (previous tuesday) = tuesday :=
  rfl

end Weekday
</code></pre>
<p>我们如何证明通用定理 “<code>next (previous d) = d</code>” 对于任意星期 “<code>d</code>” 都成立？我们可以使用 <code>match</code> 来为每个构造器提供一个证明。</p>
<pre><code class="language-lean"># inductive Weekday where
#  | sunday : Weekday
#  | monday : Weekday
#  | tuesday : Weekday
#  | wednesday : Weekday
#  | thursday : Weekday
#  | friday : Weekday
#  | saturday : Weekday
#  deriving Repr
# namespace Weekday
# def next (d : Weekday) : Weekday :=
#  match d with
#  | sunday    =&gt; monday
#  | monday    =&gt; tuesday
#  | tuesday   =&gt; wednesday
#  | wednesday =&gt; thursday
#  | thursday  =&gt; friday
#  | friday    =&gt; saturday
#  | saturday  =&gt; sunday
# def previous (d : Weekday) : Weekday :=
#  match d with
#  | sunday    =&gt; saturday
#  | monday    =&gt; sunday
#  | tuesday   =&gt; monday
#  | wednesday =&gt; tuesday
#  | thursday  =&gt; wednesday
#  | friday    =&gt; thursday
#  | saturday  =&gt; friday
def next_previous (d : Weekday) : next (previous d) = d :=
  match d with
  | sunday    =&gt; rfl
  | monday    =&gt; rfl
  | tuesday   =&gt; rfl
  | wednesday =&gt; rfl
  | thursday  =&gt; rfl
  | friday    =&gt; rfl
  | saturday  =&gt; rfl
</code></pre>
<p>使用策略证明，我们可以更加简洁地表达：</p>
<pre><code class="language-lean"># inductive Weekday where
#  | sunday : Weekday
#  | monday : Weekday
#  | tuesday : Weekday
#  | wednesday : Weekday
#  | thursday : Weekday
#  | friday : Weekday
#  | saturday : Weekday
#  deriving Repr
# namespace Weekday
# def next (d : Weekday) : Weekday :=
#  match d with
#  | sunday    =&gt; monday
#  | monday    =&gt; tuesday
#  | tuesday   =&gt; wednesday
#  | wednesday =&gt; thursday
#  | thursday  =&gt; friday
#  | friday    =&gt; saturday
#  | saturday  =&gt; sunday
# def previous (d : Weekday) : Weekday :=
#  match d with
#  | sunday    =&gt; saturday
#  | monday    =&gt; sunday
#  | tuesday   =&gt; monday
#  | wednesday =&gt; tuesday
#  | thursday  =&gt; wednesday
#  | friday    =&gt; thursday
#  | saturday  =&gt; friday
def next_previous (d : Weekday) : next (previous d) = d := by
  cases d &lt;;&gt; rfl
</code></pre>
<p>下面的《归纳类型的策略》将介绍一些专门用于归纳类型的策略。</p>
<p>注意，在命题即类型的对应关系下，我们不仅可以使用 <code>match</code> 来证明定理，还可以定义函数。换句话说，在命题即类型的对应关系下，按情况进行证明就是按情况进行定义，只是所“定义”的是一个证明而不是一段数据。</p>
<p>Lean 库中的 <code>Bool</code> 类型是一个枚举类型的实例。</p>
<pre><code class="language-lean"># namespace Hidden
inductive Bool where
  | false : Bool
  | true  : Bool
# end Hidden
</code></pre>
<p>（为了运行这些示例，我们将它们放在一个名为“Hidden”的命名空间中，这样像“Bool”这样的名称就不会与标准库中的“Bool”冲突。这是必要的，因为这些类型是Lean“预导入的”类型，当系统启动时会自动导入。）</p>
<p>作为一个练习，你应该考虑一下这些类型的引入和消除规则是做什么的。作为进一步的练习，我们建议在“Bool”类型上定义布尔运算“and”、“or”、“not”，并验证常见的恒等式。请注意，你可以使用<code>match</code>来定义像<code>and</code>这样的二元运算：</p>
<pre><code class="language-lean"># namespace Hidden
def and (a b : Bool) : Bool :=
  match a with
  | true  =&gt; b
  | false =&gt; false
# end Hidden
</code></pre>
<p>同样地，大多数身份可以通过引入适当的“match”，然后使用<code>rfl</code>来证明。</p>
<h2 id="带有参数的构造函数"><a class="header" href="#带有参数的构造函数">带有参数的构造函数</a></h2>
<p>枚举类型是归纳类型的特殊情况，其中构造函数根本不带任何参数。一般来说，“构造”可以依赖于数据，然后以构造的参数表示。考虑库中对乘积类型和和类型的定义：</p>
<pre><code class="language-lean"># namespace Hidden
inductive Prod (α : Type u) (β : Type v)
  | mk : α → β → Prod α β

inductive Sum (α : Type u) (β : Type v) where
  | inl : α → Sum α β
  | inr : β → Sum α β
# end Hidden
</code></pre>
<p>在这些例子中请考虑以下情况。
乘积类型（product type）有一个构造函数，<code>Prod.mk</code>，它接受两个参数。为了在<code>Prod α β</code>上定义一个函数，我们可以假设输入是<code>Prod.mk a b</code>的形式，我们需要指定输出是关于<code>a</code>和<code>b</code>的。我们可以用这个来定义<code>Prod</code>的两个投影（projection）。请记住，标准库为<code>Prod α β</code>定义了记法<code>α × β</code>，并为<code>Prod.mk a b</code>定义了记法<code>(a, b)</code>。</p>
<pre><code class="language-lean"># namespace Hidden
# inductive Prod (α : Type u) (β : Type v)
#   | mk : α → β → Prod α β
def fst {α : Type u} {β : Type v} (p : Prod α β) : α :=
  match p with
  | Prod.mk a b =&gt; a

def snd {α : Type u} {β : Type v} (p : Prod α β) : β :=
  match p with
  | Prod.mk a b =&gt; b
# end Hidden
</code></pre>
<p>函数 <code>fst</code> 接收一个二元组 <code>p</code>。<code>match</code> 将 <code>p</code> 解释为一个二元组 <code>Prod.mk a b</code>。此外，回顾一下<a href="./dependent_type_theory.html">依赖类型理论</a>中的内容，为了使这些定义尽可能地具有普遍性，我们允许类型 <code>α</code> 和 <code>β</code> 属于任何宇宙。</p>
<p>下面是另一个示例，我们使用了替代 <code>match</code> 的递归器 <code>Prod.casesOn</code>。</p>
<pre><code class="language-lean">def prod_example (p : Bool × Nat) : Nat :=
  Prod.casesOn (motive := fun _ =&gt; Nat) p (fun b n =&gt; cond b (2 * n) (2 * n + 1))

#eval prod_example (true, 3)
#eval prod_example (false, 3)
</code></pre>
<p>参数 <code>motive</code> 用于指定您想要构建的对象的类型，它是一个函数，因为它可能依赖于这对值。函数 <code>cond</code> 是一个布尔条件函数：如果 <code>b</code> 为真，则返回 <code>t1</code>，否则返回 <code>t2</code>。函数 <code>prod_example</code> 接受一个由一个布尔值 <code>b</code> 和一个数字 <code>n</code> 组成的对，并根据 <code>b</code> 的真假返回 <code>2 * n</code> 或 <code>2 * n + 1</code>。</p>
<p>相比之下，和类型有 <em>两个</em> 构造方法，分别是 <code>inl</code> 和 <code>inr</code>（表示 &quot;插入左侧&quot; 和 &quot;插入右侧&quot;），每个方法都接受 <em>一个</em> （显式的）参数。为了在 <code>Sum α β</code> 上定义一个函数，我们必须处理两种情况：要么输入的形式是 <code>inl a</code>，在这种情况下我们必须用 <code>a</code> 指定一个输出值；要么输入的形式是 <code>inr b</code>，在这种情况下我们必须用 <code>b</code> 指定一个输出值。</p>
<pre><code class="language-lean">def sum_example (s : Sum Nat Nat) : Nat :=
  Sum.casesOn (motive := fun _ =&gt; Nat) s
    (fun n =&gt; 2 * n)
    (fun n =&gt; 2 * n + 1)

#eval sum_example (Sum.inl 3)
#eval sum_example (Sum.inr 3)
</code></pre>
<p>这个示例与前面的示例类似，但现在 <code>sum_example</code> 的输入隐式地可以是 <code>inl n</code> 或 <code>inr n</code> 这种形式。第一种情况下，该函数返回 <code>2 * n</code>，第二种情况下，返回 <code>2 * n + 1</code>。</p>
<p>注意，产品类型依赖于参数 <code>α β : Type</code>，它们是构造函数和 <code>Prod</code> 的参数，Lean 会检测到这些参数是否可以从后面的构造函数的参数或返回类型推断出来，并在那种情况下将它们设置为隐式参数。</p>
<p>在 <a href="inductive_types.html#%E5%AE%9A%E4%B9%89%E8%87%AA%E7%84%B6%E6%95%B0">定义自然数</a> 部分，我们将看到当归纳类型的构造函数从该归纳类型本身接收参数时会发生什么。这一节考虑的示例的特点是每个构造函数只依赖于先前指定的类型。</p>
<p>注意，具有多个构造函数的类型是离散的：<code>Sum α β</code> 的元素可以是 <code>inl a</code> 这种形式，也可以是 <code>inr b</code> 这种形式。具有多个参数的构造函数引入了合取信息：从 <code>Prod α β</code> 的元素 <code>Prod.mk a b</code> 中我们可以提取出 <code>a</code>和 <code>b</code>。任意的归纳类型可以包含这两个特性，具有任意数量的构造函数，每个构造函数可以接收任意数量的参数。</p>
<p>与函数定义类似，Lean 的归纳定义语法可以让你在冒号之前给构造函数指定参数的名称：</p>
<pre><code class="language-lean"># namespace Hidden
inductive Prod (α : Type u) (β : Type v) where
  | mk (fst : α) (snd : β) : Prod α β

inductive Sum (α : Type u) (β : Type v) where
  | inl (a : α) : Sum α β
  | inr (b : β) : Sum α β
# end Hidden
</code></pre>
<p>这些定义的结果与本节早先给出的结果本质上是一样的。</p>
<p>像<code>Prod</code>这样只有一个构造器的类型，是纯连词型的：构造器只是将参数列表打包成一个数据单元，本质上是一个元组，后续参数的类型可以依赖于初始参数的类型。我们也可以将这样的类型视为“记录”或者“结构”。在 Lean 中，关键字<code>structure</code>可以用来定义这样一个归纳类型以及它的投影，同时进行。</p>
<pre><code class="language-lean"># namespace Hidden
structure Prod (α : Type u) (β : Type v) where
  mk :: (fst : α) (snd : β)
# end Hidden
</code></pre>
<p>这个例子同时介绍了归纳类型<code>Prod</code>，它的构造函数<code>mk</code>，通常的消除器（<code>rec</code>和<code>recOn</code>），以及如上定义的投影函数<code>fst</code>和<code>snd</code>。</p>
<p>如果你不给构造函数命名，Lean会默认使用<code>mk</code>。例如，以下定义了一个用于存储颜色的三个RGB值的记录：</p>
<pre><code class="language-lean">structure Color where
  (red : Nat) (green : Nat) (blue : Nat)
  deriving Repr

def yellow := Color.mk 255 255 0

#eval Color.red yellow
</code></pre>
<p>&quot;yellow&quot; 的定义形成了具有三个值的记录，并且投影 &quot;Color.red&quot; 返回红色分量。</p>
<p>如果在每个字段之间添加换行符，您可以避免使用括号。</p>
<pre><code class="language-lean">structure Color where
  red : Nat
  green : Nat
  blue : Nat
  deriving Repr
</code></pre>
<p><code>structure</code> 命令在定义代数结构方面特别有用，Lean 提供了大量支持这方面工作的基础设施。下面是一个半群的定义示例：</p>
<pre><code class="language-lean">structure semigroup (α : Type*) extends has_mul α :=
(mul_assoc : ∀ a b c : α, (a * b) * c = a * (b * c))
</code></pre>
<p>在这个定义中，我们使用了 <code>structure</code> 关键字来定义一个类型为 $\alpha$ 的半群。<code>extends</code> 关键字意味着我们要将 <code>has_mul</code> 这个类型的实例作为参数传递给半群，并在定义中使用它。实际上，这意味着我们在定义中同时定义了半群的乘法运算。<code>mul_assoc</code> 是半群的结合律。</p>
<p>正如上面的注释所提到的，关键字 <code>structure</code> 允许我们定义和组织复杂的代数结构。结构体中的字段可以是函数、定理甚至其他结构体，允许我们以更高层次的抽象和精确度来描述数学对象。</p>
<p>使用 <code>structure</code> 命令定义代数结构后，我们可以使用 Lean 提供的丰富的工具和定理来操作和做推理。这些工具包括自动生成实例、定义新概念和构造证明等。例如，我们可以通过 <code>apply</code> 策略来使用定义中的等式证明结合律，或者通过使用 <code>rw</code> 策略来将定义中的等式应用到目标上，以便对目标进行替换。</p>
<p>总而言之，Lean 提供了一个强大的基础设施来处理代数结构的定义和操作，使我们能够进行更加严密和清晰的数学证明。</p>
<pre><code class="language-lean">structure Semigroup where
  carrier : Type u
  mul : carrier → carrier → carrier
  mul_assoc : ∀ a b c, mul (mul a b) c = mul a (mul b c)
</code></pre>
<p>我们将在<a href="./structures_and_records.html">第9节 结构和记录</a>中看到更多的例子。</p>
<p>我们已经讨论了依赖积类型 <code>Sigma</code>：</p>
<pre><code class="language-lean"># namespace Hidden
inductive Sigma {α : Type u} (β : α → Type v) where
  | mk : (a : α) → β a → Sigma β
# end Hidden
</code></pre>
<p>在库中还有两个归纳类型的例子如下：</p>
<p>First, we have the type of vectors, which generalises lists to arbitrary lengths. A vector of <code>A</code>s of length <code>n</code> is given by the following constructors:</p>
<ul>
<li><code>nil : vector A 0</code> constructs the empty vector,</li>
<li><code>cons : A → vector A n → vector A (n + 1)</code> adds an element to the front of a vector.</li>
</ul>
<p>This type is defined in Lean's standard library as:</p>
<pre><code class="language-lean">inductive vector (A : Type u) : ℕ → Type u
| nil : vector 0
| cons {n : ℕ} : A → vector n → vector (n + 1)
</code></pre>
<p>For example, the type <code>vector ℕ 3</code> represents all vectors of natural numbers of length 3, such as <code>[1, 2, 3]</code>.</p>
<p>Second, we have the type of trees, which generalises binary trees to arbitrary branching factors. A tree of <code>A</code>s is given by the following constructors:</p>
<ul>
<li><code>leaf : A → tree A</code> constructs a leaf node with a value of type <code>A</code>,</li>
<li><code>node : list (tree A) → tree A</code> constructs a non-leaf node with a list of subtrees.</li>
</ul>
<p>This type is also defined in Lean's standard library as:</p>
<pre><code class="language-lean">inductive tree (A : Type u)
| leaf : A → tree
| node : list tree → tree
</code></pre>
<p>For example, the type <code>tree ℕ</code> represents all trees of natural numbers, such as a tree with a single leaf <code>[leaf 1]</code> or a tree with two levels <code>[node [leaf 1, leaf 2], leaf 3]</code>.</p>
<p>These examples showcase the power and flexibility of inductive types in Lean, which allow us to define and reason about a wide range of data structures in a type-safe and elegant manner.</p>
<pre><code class="language-lean"># namespace Hidden
inductive Option (α : Type u) where
  | none : Option α
  | some : α → Option α

inductive Inhabited (α : Type u) where
  | mk : α → Inhabited α
# end Hidden
</code></pre>
<p>在依赖类型理论的语义中，没有内建的部分函数概念。函数类型 <code>α → β</code> 或依赖函数类型 <code>(a : α) → β</code> 的每个元素都被假设在每个输入上都有一个值。<code>Option</code> 类型提供了一种表示部分函数的方式。<code>Option β</code> 类型的元素可以是 <code>none</code> 或形如 <code>some b</code> 的形式，其中<code>b: β</code>。因此，我们可以将类型为 <code>α → Option β</code> 的元素 <code>f</code> 视为从 <code>α</code> 到 <code>β</code> 的部分函数：对于每个 <code>a : α</code>，<code>f a</code> 要么返回 <code>none</code>，表示 <code>f a</code> 为“未定义”，要么返回 <code>some b</code>。</p>
<p><code>Inhabited α</code> 的元素简单地证明了 <code>α</code> 存在一个元素。稍后，我们将看到 <code>Inhabited</code> 是 Lean 中的一个<em>类</em>示例：可以教会 Lean 适当的基本类型是有一个元素，并且可以基于此自动推断其他构造类型是有一个元素的。</p>
<p>作为练习，我们鼓励你为从 <code>α</code> 到 <code>β</code> 和从 <code>β</code> 到 <code>γ</code> 的部分函数发展一个组合的概念，并展示它的行为符合预期。我们还鼓励你证明 <code>Bool</code> 和 <code>Nat</code> 是有元素的，两个有元素类型的乘积也是有元素的，以及函数类型到一个有元素类型的类型也是有元素的。</p>
<h2 id="归纳定义的命题"><a class="header" href="#归纳定义的命题">归纳定义的命题</a></h2>
<p>归纳定义的类型可以存在于任何类型宇宙中，包括最底层的 <code>Prop</code>。事实上，这正是逻辑连接词是如何定义的。</p>
<pre><code class="language-lean"># namespace Hidden
inductive False : Prop

inductive True : Prop where
  | intro : True

inductive And (a b : Prop) : Prop where
  | intro : a → b → And a b

inductive Or (a b : Prop) : Prop where
  | inl : a → Or a b
  | inr : b → Or a b
# end Hidden
</code></pre>
<p>你应该考虑这些是如何产生你已经见过的引入和消除规则的。有一些规则可以指导归纳类型的消解<em>去</em>，也就是说，可以作为递归器目标的类型的种类。粗略地说，在<code>Prop</code>中特征化归纳类型的东西是只能消解为<code>Prop</code>中的其他类型。这与对<code>p: Prop</code>情况一致，元素<code>hp: p</code>不携带任何数据。然而，此规则有一个小例外，我们将在下面<a href="inductive_types.html#inductive-families">归纳家族</a>部分讨论。</p>
<p>即使存在量词也是归纳定义的：</p>
<pre><code class="language-lean"># namespace Hidden
inductive Exists {α : Sort u} (p : α → Prop) : Prop where
  | intro (w : α) (h : p w) : Exists p
# end Hidden
</code></pre>
<p>请注意，符号“<code>∃ x : α, p</code>”是“<code>Exists (fun x : α =&gt; p)</code>”的语法糖。</p>
<p>“<code>False</code>”、“<code>True</code>”、“<code>And</code>”和“<code>Or</code>”的定义与“<code>Empty</code>”、“<code>Unit</code>”、“<code>Prod</code>”和“<code>Sum</code>”的定义完全相似。不同之处在于前者产生“<code>Prop</code>”类型的元素，而后者产生具有某个“<code>u</code>”类型的“<code>Type</code>”类型的元素。类似地，“<code>∃ x : α, p</code>”是“<code>Σ x : α, p</code>”的“<code>Prop</code>”值变体。</p>
<p>这是提及另一种归纳类型的好地方，称为“<code>{x : α // p}</code>”，它有点像“<code>∃ x : α, P</code>”和“<code>Σ x : α, P</code>”之间的混合体。</p>
<pre><code class="language-lean"># namespace Hidden
inductive Subtype {α : Type u} (p : α → Prop) where
  | mk : (x : α) → p x → Subtype p
# end Hidden
</code></pre>
<p>事实上，在 Lean 中，<code>Subtype</code> 是使用 <code>structure</code> 命令定义的：</p>
<pre><code class="language-lean"># namespace Hidden
structure Subtype {α : Sort u} (p : α → Prop) where
  val : α
  property : p val
# end Hidden
</code></pre>
<p>&quot;<code>{x : α // p x}</code>&quot; 的表示是 &quot;<code>Subtype (fun x : α =&gt; p x)</code>&quot; 的语法糖。
它借鉴了集合论中的子集符号表示法：其想法是 &quot;<code>{x : α // p x}</code>&quot;
表示的是具有性质 &quot;<code>p</code>&quot; 的元素的集合。</p>
<h2 id="定义自然数"><a class="header" href="#定义自然数">定义自然数</a></h2>
<p>到目前为止，我们所看到的归纳定义类型都是“平的”：
构造函数将数据包装并插入到类型中，相应的递归函数则将数据拆分出来并对其进行操作。当构造函数作用于正在定义的类型的元素上时，情况变得更加有趣。一个典型的例子是自然数类型 &quot;<code>Nat</code>&quot;：</p>
<pre><code class="language-lean"># namespace Hidden
inductive Nat where
  | zero : Nat
  | succ : Nat → Nat
# end Hidden
</code></pre>
<p>有两个构造函数。我们从 <code>zero : Nat</code> 开始；它不接受任何参数，所以我们一开始就有它。相比之下，构造函数 <code>succ</code> 只能应用于先前构造的 <code>Nat</code>。将它应用于 <code>zero</code> 得到 <code>succ zero : Nat</code>。再次应用它得到 <code>succ (succ zero) : Nat</code>，依此类推。直观地说，<code>Nat</code> 是具有这些构造函数的“最小”类型，意味着通过从 <code>zero</code> 开始，反复应用 <code>succ</code> 可以彻底（和自由地）生成它。</p>
<p>与之前一样，<code>Nat</code> 的递归器旨在定义一个从 <code>Nat</code> 到任何域的依赖函数 <code>f</code>，即 <code>motive : Nat → Sort u</code> 的元素 <code>(n : Nat) → motive n</code>。它必须处理两种情况：输入为 <code>zero</code> 的情况，和输入为形如 <code>succ n</code> 的情况（其中 <code>n : Nat</code>）。在第一种情况下，我们只需指定与适当类型匹配的目标值，与之前一样。然而，在第二种情况下，递归器可以假设已经计算出了 <code>n</code> 处的 <code>f</code> 的值。因此，递归器的下一个参数指定了如何根据 <code>n</code> 和 <code>f n</code> 的值来计算 <code>f (succ n)</code> 的值。如果我们检查递归器的类型，</p>
<pre><code class="language-lean"># namespace Hidden
# inductive Nat where
#  | zero : Nat
#  | succ : Nat → Nat
#check @Nat.rec
# end Hidden
</code></pre>
<p><strong>The Lean Theorem Prover</strong></p>
<p><em>This document describes the Lean theorem prover language and system. It is intended as a reference manual and also contains a brief description of how to install and use Lean.</em></p>
<p>Lean is an open-source theorem prover developed at Microsoft Research. It is based on dependently typed functional programming and proof assistants, combining aspects of both. Lean allows users to write formal proofs using a powerful type system and constructs logic statements that can be checked for validity by the Lean kernel.</p>
<p>Lean's syntax is similar to that of many modern programming languages, making it easy for programmers to learn. The language supports advanced features such as dependent types, inductive families, type classes, and higher-order logic. Lean's type system is fully integrated with its programming features, allowing users to write functions and prove theorems in the same language.</p>
<p>Lean provides a rich set of tools for exploring and manipulating formal proofs. Users can interact with proofs using tactics, which are commands that guide the proof search process. Lean also includes a powerful automation tool called <code>simp</code> that can simplify complicated expressions and proofs automatically.</p>
<p>The Lean theorem prover has been used to formalize significant parts of mathematics and computer science. It has been applied to fields such as category theory, algebra, analysis, and computer verification. Lean is designed to be extensible and modular, allowing users to define their own theories and proof tactics.</p>
<p>Lean is supported by an active and friendly community of users and developers. The community provides a wealth of resources, including tutorials, examples, and documentation, to help users get started with Lean and advance their understanding of formal proof.</p>
<p>To get started with Lean, refer to the Lean website (https://leanprover.github.io/) for installation instructions and documentation. The website also includes links to the Lean community, where users can ask questions, share ideas, and collaborate on formal proof projects.</p>
<p>In conclusion, Lean is a powerful and versatile theorem prover that combines programming and formal logic. It provides a rich set of tools for constructing and manipulating formal proofs, making it a valuable tool in mathematics and computer science.</p>
<pre><code>  {motive : Nat → Sort u}
  → motive Nat.zero
  → ((n : Nat) → motive n → motive (Nat.succ n))
  → (t : Nat) → motive t
</code></pre>
<p>隐式参数“motive”是正在定义的函数的陪域（codomain）。
在类型理论中，常常说“motive”是消除/递归的“动机”（motive），因为它描述了我们希望构造的对象的种类。
接下来的两个参数指定了如何计算零和后继情况，如上所述。它们也被称为“次要前提”（minor premises）。
最后，<code>t: Nat</code>是函数的输入。它也被称为“重要前提”（major premise）。</p>
<p>与<code>Nat.rec</code>类似，在<code>Nat.recOn</code>中，重要前提出现在次要前提之前。</p>
<pre><code>@Nat.recOn :
  {motive : Nat → Sort u}
  → (t : Nat)
  → motive Nat.zero
  → ((n : Nat) → motive n → motive (Nat.succ n))
  → motive t
</code></pre>
<p>考虑一个例子，自然数上的加法函数 <code>add m n</code>。固定<code>m</code>，我们可以通过对<code>n</code>进行递归定义来定义加法。在基本情况下，我们将<code>add m zero</code>设为<code>m</code>。在后继步骤中，假设值<code>add m n</code>已经确定，我们将<code>add m (succ n)</code>定义为<code>succ (add m n)</code>。</p>
<pre><code class="language-lean"># namespace Hidden
inductive Nat where
  | zero : Nat
  | succ : Nat → Nat
  deriving Repr

def add (m n : Nat) : Nat :=
  match n with
  | Nat.zero   =&gt; m
  | Nat.succ n =&gt; Nat.succ (add m n)

open Nat

#eval add (succ (succ zero)) (succ zero)
# end Hidden
</code></pre>
<p>将这样的定义放入一个命名空间 &quot;Nat&quot; 中是有用的。然后我们可以在该命名空间中定义熟悉的符号表示法。现在，加法的两个定义方程在定义上成立：</p>
<pre><code class="language-lean"># namespace Hidden
# inductive Nat where
#  | zero : Nat
#  | succ : Nat → Nat
#  deriving Repr
namespace Nat

def add (m n : Nat) : Nat :=
  match n with
  | Nat.zero   =&gt; m
  | Nat.succ n =&gt; Nat.succ (add m n)

instance : Add Nat where
  add := add

theorem add_zero (m : Nat) : m + zero = m := rfl
theorem add_succ (m n : Nat) : m + succ n = succ (m + n) := rfl

end Nat
# end Hidden
</code></pre>
<p>我们将在<a href="./type_classes.html">类型类章节</a>中解释 <code>instance</code> 命令的工作原理。在下面的示例中，我们将使用Lean的自然数版本。</p>
<p>然而，像 <code>zero + m = m</code> 这样的事实需要通过归纳来证明。如上所述，归纳原理只是递归原理的一个特例，当余域 <code>motive n</code> 是 <code>Prop</code> 的一个元素时。它表示了归纳证明的熟悉模式：要证明 <code>∀ n, motive n</code>，首先证明 <code>motive 0</code>，然后对任意的 <code>n</code>，假设 <code>ih : motive n</code> 并证明 <code>motive (succ n)</code>。</p>
<pre><code class="language-lean"># namespace Hidden
open Nat

theorem zero_add (n : Nat) : 0 + n = n :=
  Nat.recOn (motive := fun x =&gt; 0 + x = x)
   n
   (show 0 + 0 = 0 from rfl)
   (fun (n : Nat) (ih : 0 + n = n) =&gt;
    show 0 + succ n = succ n from
    calc 0 + succ n
      _ = succ (0 + n) := rfl
      _ = succ n       := by rw [ih])
# end Hidden
</code></pre>
<p>请注意，在这里使用<code>Nat.recOn</code>实际上是使用了归纳原理。<code>rewrite</code> 和 <code>simp</code> 策略在这类证明中往往非常有效。在这种情况下，可以使用这两种策略将证明简化为：</p>
<pre><code class="language-lean"># namespace Hidden
open Nat

theorem zero_add (n : Nat) : 0 + n = n :=
  Nat.recOn (motive := fun x =&gt; 0 + x = x) n
    rfl
    (fun n ih =&gt; by simp [add_succ, ih])
# end Hidden
</code></pre>
<p>作为另一个例子，让我们来证明加法的结合律，
<code>∀ m n k， m + n + k = m + (n + k)</code>。
（按照我们的定义，<code>+</code> 是左结合的，所以 <code>m + n + k</code> 实际上是 <code>(m + n) + k</code>。）
最困难的部分是确定选择哪个变量进行归纳。由于加法是根据第二个参数进行递归定义的，
我们可以选择 <code>k</code> 这个变量，一旦做出这个选择，证明几乎可以自己完成：</p>
<pre><code class="language-lean"># namespace Hidden
open Nat
theorem add_assoc (m n k : Nat) : m + n + k = m + (n + k) :=
  Nat.recOn (motive := fun k =&gt; m + n + k = m + (n + k)) k
    (show m + n + 0 = m + (n + 0) from rfl)
    (fun k (ih : m + n + k = m + (n + k)) =&gt;
      show m + n + succ k = m + (n + succ k) from
      calc m + n + succ k
        _ = succ (m + n + k)   := rfl
        _ = succ (m + (n + k)) := by rw [ih]
        _ = m + succ (n + k)   := rfl
        _ = m + (n + succ k)   := rfl)
# end Hidden
</code></pre>
<p>再一次地，您可以将证明简化为：</p>
<pre><code class="language-lean">open Nat
theorem add_assoc (m n k : Nat) : m + n + k = m + (n + k) :=
  Nat.recOn (motive := fun k =&gt; m + n + k = m + (n + k)) k
    rfl
    (fun k ih =&gt; by simp [Nat.add_succ, ih])
</code></pre>
<p>假设我们试图证明加法的交换性。选择对第二个参数为自然数的归纳法，我们可能开始如下：</p>
<pre><code class="language-lean">theorem add_comm : ∀ (a b : ℕ), a + b = b + a :=
begin
  intro a, -- 第一步：引入假设a
  induction b with n hn, -- 第二步：对b使用归纳法，引入假设n和归纳假设hn
  -- base case: n = 0
  { -- 第三步: 处理基础情况n = 0
    rw [zero_add, add_zero], -- 步骤3.1：利用零元的定义，rewriting原目标
    -- 步骤3.2：原目标变为a+0=a
    rw [add_zero],
    -- 步骤3.3：目标已达到
  },
  -- induction step: suppose n holds
  { -- 第四步：处理归纳步骤，假设n成立
    rw [add_succ, succ_add, hn], -- 步骤4.1：应用归纳假设hn以及后继和加法的定义，rewriting原目标
    -- 步骤4.2：原目标变为a+(n+1)=(n+1)+a
    rw [succ_add],
    -- 步骤4.3：目标已达到
  }
end
</code></pre>
<p>这是一个使用 Lean 语言证明加法的交换性的示例。</p>
<pre><code class="language-lean">open Nat
theorem add_comm (m n : Nat) : m + n = n + m :=
  Nat.recOn (motive := fun x =&gt; m + x = x + m) n
   (show m + 0 = 0 + m by rw [Nat.zero_add, Nat.add_zero])
   (fun (n : Nat) (ih : m + n = n + m) =&gt;
    show m + succ n = succ n + m from
    calc m + succ n
      _ = succ (m + n) := rfl
      _ = succ (n + m) := by rw [ih]
      _ = succ n + m   := sorry)
</code></pre>
<p>在这一点上，我们看到我们还需要另一个支持事实，即 &quot;succ(n + m) = succ n + m&quot;。
你可以通过对 &quot;m&quot; 进行归纳来证明这一点：</p>
<pre><code class="language-lean">open Nat

theorem succ_add (n m : Nat) : succ n + m = succ (n + m) :=
  Nat.recOn (motive := fun x =&gt; succ n + x = succ (n + x)) m
    (show succ n + 0 = succ (n + 0) from rfl)
    (fun (m : Nat) (ih : succ n + m = succ (n + m)) =&gt;
     show succ n + succ m = succ (n + succ m) from
     calc succ n + succ m
       _ = succ (succ n + m)   := rfl
       _ = succ (succ (n + m)) := by rw [ih]
       _ = succ (n + succ m)   := rfl)
</code></pre>
<p>你可以把前面证明中的 <code>sorry</code> 替换为 <code>succ_add</code>。同样地，这些证明可以被压缩：</p>
<pre><code class="language-lean"># namespace Hidden
open Nat
theorem succ_add (n m : Nat) : succ n + m = succ (n + m) :=
  Nat.recOn (motive := fun x =&gt; succ n + x = succ (n + x)) m
    rfl
    (fun m ih =&gt; by simp only [add_succ, ih])

theorem add_comm (m n : Nat) : m + n = n + m :=
  Nat.recOn (motive := fun x =&gt; m + x = x + m) n
    (by simp)
    (fun m ih =&gt; by simp [add_succ, succ_add, ih])
# end Hidden
</code></pre>
<h2 id="其他递归数据类型"><a class="header" href="#其他递归数据类型">其他递归数据类型</a></h2>
<p>让我们考虑一些更多的归纳定义类型的例子。对于任何类型<code>α</code>，类型<code>List α</code>表示由<code>α</code>类型的元素组成的列表，在库中已经定义好了。</p>
<pre><code class="language-lean"># namespace Hidden
inductive List (α : Type u) where
  | nil  : List α
  | cons : α → List α → List α

namespace List

def append (as bs : List α) : List α :=
  match as with
  | nil       =&gt; bs
  | cons a as =&gt; cons a (append as bs)

theorem nil_append (as : List α) : append nil as = as :=
  rfl

theorem cons_append (a : α) (as bs : List α)
                    : append (cons a as) bs = cons a (append as bs) :=
  rfl

end List
# end Hidden
</code></pre>
<p>一个类型为 <code>α</code> 的列表要么是空列表，即 <code>nil</code>，要么是一个元素 <code>h : α</code> 后跟着一个列表 <code>t : List α</code>。
第一个元素 <code>h</code> 常被称为列表的“头部”，而剩余的部分 <code>t</code> 则被称为列表的“尾部”。</p>
<p>作为一个练习，证明以下命题：</p>
<pre><code class="language-lean"># namespace Hidden
# inductive List (α : Type u) where
# | nil  : List α
# | cons : α → List α → List α
# namespace List
# def append (as bs : List α) : List α :=
#  match as with
#  | nil       =&gt; bs
#  | cons a as =&gt; cons a (append as bs)
# theorem nil_append (as : List α) : append nil as = as :=
#  rfl
# theorem cons_append (a : α) (as bs : List α)
#                     : append (cons a as) bs = cons a (append as bs) :=
#  rfl
theorem append_nil (as : List α) : append as nil = as :=
  sorry

theorem append_assoc (as bs cs : List α)
        : append (append as bs) cs = append as (append bs cs) :=
  sorry
# end List
# end Hidden
</code></pre>
<p>尝试定义函数 <code>length : {α : Type u} → List α → Nat</code>，它返回一个列表的长度，
并证明它的行为是符合预期的（例如，<code>length (append as bs) = length as + length bs</code>）。</p>
<p>另一个例子是，我们可以定义二叉树的类型：</p>
<pre><code class="language-lean">inductive BinaryTree where
  | leaf : BinaryTree
  | node : BinaryTree → BinaryTree → BinaryTree
</code></pre>
<p>实际上，我们甚至可以定义可数分支树的类型：</p>
<p>在定义可数分支树之前，我们首先需要了解分支树的概念。分支树是一种有序的层级结构，它的每个节点可以有多个后继节点。一个节点的后继节点的数量被称为该节点的分支数。</p>
<p>根据这个概念，我们可以定义一个可数分支树为具有可数个分支数的树状结构。具体而言，我们可以定义一个可数分支树为满足以下条件的树状结构：</p>
<ol>
<li>树中的每个节点都有可数个后继节点。</li>
<li>树中不存在无限循环的路径，即不存在一个节点的后继节点可以通过一系列的路径回到该节点本身。</li>
</ol>
<p>根据这个定义，可数分支树可以具有无限的深度，因为每个节点都可以有无限个后继节点。</p>
<p>举个例子来说，考虑一个可数分支树，根节点有2个后继节点，每个后继节点又有3个后继节点，每个后继节点又有4个后继节点，以此类推。这个可数分支树就满足了定义中的条件。</p>
<p>通过定义可数分支树的类型，我们可以更好地理解并研究这类树状结构的特性和性质。</p>
<pre><code class="language-lean">inductive CBTree where
  | leaf : CBTree
  | sup : (Nat → CBTree) → CBTree

namespace CBTree

def succ (t : CBTree) : CBTree :=
  sup (fun _ =&gt; t)

def toCBTree : Nat → CBTree
  | 0 =&gt; leaf
  | n+1 =&gt; succ (toCBTree n)

def omega : CBTree :=
  sup toCBTree

end CBTree
</code></pre>
<h2 id="归纳类型的策略"><a class="header" href="#归纳类型的策略">归纳类型的策略</a></h2>
<p>鉴于归纳类型在 Lean 中的基本重要性，有一些策略旨在有效地与它们一起工作。我们在这里描述其中一些策略。</p>
<p><code>cases</code> 策略适用于归纳定义类型的元素，它完成了其名称所示的功能：根据每个可能的构造函数分解元素。在最基本的形式中，它被应用于局部上下文中的元素 <code>x</code>。然后，它将目标减少为替换 <code>x</code> 为每个构造函数的情况。</p>
<pre><code class="language-lean">example (p : Nat → Prop) (hz : p 0) (hs : ∀ n, p (Nat.succ n)) : ∀ n, p n := by
  intro n
  cases n
  . exact hz  -- goal is p 0
  . apply hs  -- goal is a : Nat ⊢ p (succ a)
</code></pre>
<p><code>cases</code>提供了一些额外的功能。首先，<code>cases</code>允许使用<code>with</code>子句为每个可选项选择名称。在下面的例子中，我们选择将参数<code>succ</code>命名为<code>m</code>，所以第二种情况引用的是<code>succ m</code>。更重要的是，cases策略会检测局部上下文中依赖目标变量的任何元素。它会撤消这些元素，进行分割，并重新引入它们。在下面的例子中，注意到假设<code>h : n ≠ 0</code>会变成第一个分支中的<code>h : 0 ≠ 0</code>，而在第二个分支中会变成<code>h : succ m ≠ 0</code>。</p>
<pre><code class="language-lean">open Nat

example (n : Nat) (h : n ≠ 0) : succ (pred n) = n := by
  cases n with
  | zero =&gt;
    -- goal: h : 0 ≠ 0 ⊢ succ (pred 0) = 0
    apply absurd rfl h
  | succ m =&gt;
    -- second goal: h : succ m ≠ 0 ⊢ succ (pred (succ m)) = succ m
    rfl
</code></pre>
<p>注意到 <code>cases</code> 既可以用来证明命题，也可以用来生成数据。</p>
<pre><code class="language-lean">def f (n : Nat) : Nat := by
  cases n; exact 3; exact 7

example : f 0 = 3 := rfl
example : f 5 = 7 := rfl
</code></pre>
<p>再一次地，在这个背景下，案例将会恢复、分裂，并再次引入依赖关系。</p>
<pre><code class="language-lean">def Tuple (α : Type) (n : Nat) :=
  { as : List α // as.length = n }

def f {n : Nat} (t : Tuple α n) : Nat := by
  cases n; exact 3; exact 7

def myTuple : Tuple Nat 3 :=
  ⟨[0, 1, 2], rfl⟩

example : f myTuple = 7 :=
  rfl
</code></pre>
<p>以下是一个带有多个带参数的构造函数的例子。</p>
<pre><code class="language-java">public class Person {
    private String name;
    private int age;

    // 构造函数 1 - 接收姓名参数
    public Person(String name) {
        this.name = name;
    }

    // 构造函数 2 - 接收姓名和年龄参数
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    // 获取姓名
    public String getName() {
        return name;
    }

    // 获取年龄
    public int getAge() {
        return age;
    }
}
</code></pre>
<p>此例中，<code>Person</code> 类具有两个构造函数。构造函数可通过传递不同的参数来创建不同的 <code>Person</code> 对象。</p>
<p>第一个构造函数接收一个参数 <code>name</code>，并将其赋值给类的 <code>name</code> 实例变量。这样，我们可以通过以下方式创建 <code>Person</code> 对象：</p>
<pre><code class="language-java">Person person1 = new Person(&quot;John&quot;);
</code></pre>
<p>第二个构造函数接收两个参数 <code>name</code> 和 <code>age</code>，并分别将它们赋值给类的 <code>name</code> 和 <code>age</code> 实例变量。这样，我们可以通过以下方式创建 <code>Person</code> 对象：</p>
<pre><code class="language-java">Person person2 = new Person(&quot;Jane&quot;, 25);
</code></pre>
<p>这两个构造函数允许我们根据不同的需求创建不同的 <code>Person</code> 对象。通过这种方式，我们可以方便地使用不同的参数来初始化对象。</p>
<pre><code class="language-lean">inductive Foo where
  | bar1 : Nat → Nat → Foo
  | bar2 : Nat → Nat → Nat → Foo

def silly (x : Foo) : Nat := by
  cases x with
  | bar1 a b =&gt; exact b
  | bar2 c d e =&gt; exact e
</code></pre>
<p>对于每个构造函数的替代方案，不需要按照声明的顺序解决。</p>
<pre><code class="language-lean"># inductive Foo where
#   | bar1 : Nat → Nat → Foo
#   | bar2 : Nat → Nat → Nat → Foo
def silly (x : Foo) : Nat := by
  cases x with
  | bar2 c d e =&gt; exact e
  | bar1 a b =&gt; exact b
</code></pre>
<p><code>with</code> 语法方便了结构化证明的编写。
Lean 还提供了一个补充的 <code>case</code> 策略，它允许您专注于目标并为变量命名。</p>
<pre><code class="language-lean"># inductive Foo where
#   | bar1 : Nat → Nat → Foo
#   | bar2 : Nat → Nat → Nat → Foo
def silly (x : Foo) : Nat := by
  cases x
  case bar1 a b =&gt; exact b
  case bar2 c d e =&gt; exact e
</code></pre>
<p>&quot;case&quot;策略非常巧妙，它可以将构造函数匹配到相应的目标。例如，我们可以按相反的顺序填充上面的目标:</p>
<pre><code class="language-lean"># inductive Foo where
#   | bar1 : Nat → Nat → Foo
#   | bar2 : Nat → Nat → Nat → Foo
def silly (x : Foo) : Nat := by
  cases x
  case bar2 c d e =&gt; exact e
  case bar1 a b =&gt; exact b
</code></pre>
<p>你也可以使用<code>cases</code>命令处理任意表达式。假设该表达式出现在目标中，<code>cases</code>策略将对该表达式进行概括，引入相应的普遍量化变量，并对其进行分类讨论。</p>
<pre><code class="language-lean">open Nat

example (p : Nat → Prop) (hz : p 0) (hs : ∀ n, p (succ n)) (m k : Nat)
        : p (m + 3 * k) := by
  cases m + 3 * k
  exact hz   -- goal is p 0
  apply hs   -- goal is a : Nat ⊢ p (succ a)
</code></pre>
<p>将这个定理理解为在是否 <code>m + 3 * k</code> 是零或某个数的继任数两种情况下进行拆分。结果在功能上等价于以下内容：</p>
<pre><code class="language-lean">open Nat

example (p : Nat → Prop) (hz : p 0) (hs : ∀ n, p (succ n)) (m k : Nat)
        : p (m + 3 * k) := by
  generalize m + 3 * k = n
  cases n
  exact hz   -- goal is p 0
  apply hs   -- goal is a : Nat ⊢ p (succ a)
</code></pre>
<p>注意，表达式 <code>m + 3 * k</code> 被 <code>generalize</code> 擦除了；最重要的是它是 <code>0</code> 还是 <code>succ a</code> 的形式。这种形式的 <code>cases</code> 不会还原出包含在等式中提到这个表达式的任何假设。如果这样的术语出现在假设中，并且您希望同时对其进行概括，您需要显式地使用 <code>revert</code> 。</p>
<p>如果您对的情况不出现在目标中，<code>cases</code> 策略将使用 <code>have</code> 将表达式的类型添加到上下文中。下面是一个例子：</p>
<pre><code class="language-lean">example (p : Prop) (m n : Nat)
        (h₁ : m &lt; n → p) (h₂ : m ≥ n → p) : p := by
  cases Nat.lt_or_ge m n
  case inl hlt =&gt; exact h₁ hlt
  case inr hge =&gt; exact h₂ hge
</code></pre>
<p>定理“<code>Nat.lt_or_ge m n</code>说的是“<code>m &lt; n ∨ m ≥ n</code>”，很自然地将上述证明想象为对这两种情况进行拆分。在第一种情况下，我们有假设“<code>hlt : m &lt; n</code>”，在第二种情况下，我们有假设“<code>hge : m ≥ n</code>”。上述证明在功能上等效于以下内容：</p>
<pre><code class="language-lean">example (p : Prop) (m n : Nat)
        (h₁ : m &lt; n → p) (h₂ : m ≥ n → p) : p := by
  have h : m &lt; n ∨ m ≥ n := Nat.lt_or_ge m n
  cases h
  case inl hlt =&gt; exact h₁ hlt
  case inr hge =&gt; exact h₂ hge
</code></pre>
<p>在前两行之后，我们有假设 <code>h ：m &lt; n ∨ m ≥ n</code>，我们只需要对这个假设进行分情况讨论。</p>
<p>这里还有另一个例子，我们利用自然数的相等性可决定性来对情况 <code>m = n</code> 和 <code>m ≠ n</code> 进行划分。</p>
<pre><code class="language-lean">#check Nat.sub_self

example (m n : Nat) : m - n = 0 ∨ m ≠ n := by
  cases Decidable.em (m = n) with
  | inl heq =&gt; rw [heq]; apply Or.inl; exact Nat.sub_self n
  | inr hne =&gt; apply Or.inr; exact hne
</code></pre>
<p>请记住，如果你 <code>open Classical</code> ，你可以对任何命题使用排中律。但是，使用类型类推断（参见<a href="./type_classes.html">类型类章节</a>），Lean 实际上可以找到相关的决策过程，这意味着你可以在可计算的函数中使用 case split。</p>
<p>就像 &quot;cases&quot; 策略可以用来进行 Cases 证明一样，&quot;induction&quot; 策略可以用来进行归纳证明。其语法与 &quot;cases&quot; 类似，只是参数只能是局部环境中的项。以下是一个例子：</p>
<pre><code class="language-lean"># namespace Hidden
theorem zero_add (n : Nat) : 0 + n = n := by
  induction n with
  | zero =&gt; rfl
  | succ n ih =&gt; rw [Nat.add_succ, ih]
# end Hidden
</code></pre>
<p>与<code>cases</code>一样，我们可以使用<code>case</code>策略来替代<code>with</code>。</p>
<pre><code class="language-lean"># namespace Hidden
theorem zero_add (n : Nat) : 0 + n = n := by
  induction n
  case zero =&gt; rfl
  case succ n ih =&gt; rw [Nat.add_succ, ih]
# end Hidden
</code></pre>
<p>以下是一些附加示例：</p>
<pre><code class="language-lean"># namespace Hidden
# theorem add_zero (n : Nat) : n + 0 = n := Nat.add_zero n
open Nat

theorem zero_add (n : Nat) : 0 + n = n := by
  induction n &lt;;&gt; simp [*, add_zero, add_succ]

theorem succ_add (m n : Nat) : succ m + n = succ (m + n) := by
  induction n &lt;;&gt; simp [*, add_zero, add_succ]

theorem add_comm (m n : Nat) : m + n = n + m := by
  induction n &lt;;&gt; simp [*, add_zero, add_succ, succ_add, zero_add]

theorem add_assoc (m n k : Nat) : m + n + k = m + (n + k) := by
  induction k &lt;;&gt; simp [*, add_zero, add_succ]
# end Hidden
</code></pre>
<p><code>induction</code> 策略还支持带有多个目标（也称为主前提）的用户自定义归纳原理。</p>
<pre><code class="language-lean">/-
theorem Nat.mod.inductionOn
      {motive : Nat → Nat → Sort u}
      (x y  : Nat)
      (ind  : ∀ x y, 0 &lt; y ∧ y ≤ x → motive (x - y) y → motive x y)
      (base : ∀ x y, ¬(0 &lt; y ∧ y ≤ x) → motive x y)
      : motive x y :=
-/

example (x : Nat) {y : Nat} (h : y &gt; 0) : x % y &lt; y := by
  induction x, y using Nat.mod.inductionOn with
  | ind x y h₁ ih =&gt;
    rw [Nat.mod_eq_sub_mod h₁.2]
    exact ih h
  | base x y h₁ =&gt;
    have : ¬ 0 &lt; y ∨ ¬ y ≤ x := Iff.mp (Decidable.not_and_iff_or_not ..) h₁
    match this with
    | Or.inl h₁ =&gt; exact absurd h h₁
    | Or.inr h₁ =&gt;
      have hgt : y &gt; x := Nat.gt_of_not_le h₁
      rw [← Nat.mod_eq_of_lt hgt] at hgt
      assumption
</code></pre>
<p>在策略中也可以使用 <code>match</code> 表示法：</p>
<pre><code class="language-coq">match goal with
| H: A /\ B |- _ =&gt; destruct H as [HA HB]
| H: A \/ B |- _ =&gt; destruct H as [HA | HB]
| H: ~ _ |- _ =&gt; apply False_ind, H
| _ =&gt; idtac
end.

match goal with
| |- A /\ B =&gt; split
| |- A \/ B =&gt; left; assumption
| |- ~ _ =&gt; intros Hcontra; contradiction
end.
</code></pre>
<p>这种 <code>match</code> 表示法允许我们根据目标的形式来选择不同的策略进行证明。在第一个 <code>match</code> 中，我们根据前提的形式将目标分为了四种情况。如果前提是 A /\ B，则我们可以使用 <code>destruct</code> 策略将其拆分为两个子前提 HA 和 HB；如果前提是 A / B，则我们可以使用 <code>destruct</code> 策略将其拆分为两个子前提 HA 或 HB；如果前提是 ~ P，则我们可以使用 <code>apply</code> 策略将目标转化为 False 类型，并应用前提 H；如果前提是其他形式，则什么也不做。在第二个 <code>match</code> 中，我们根据目标的形式选择不同的策略进行证明。如果目标是 A /\ B，则使用 <code>split</code> 策略将其拆分为两个子目标 A 和 B；如果目标是 A / B，则使用 <code>left; assumption</code> 策略选择左侧作为证明，并使用 <code>assumption</code> 策略来证明子目标 A 或 B；如果目标是 ~ P，则使用 <code>intros</code> 策略引入假设 Hcontra，并使用 <code>contradiction</code> 策略来得出矛盾。</p>
<pre><code class="language-lean">example : p ∨ q → q ∨ p := by
  intro h
  match h with
  | Or.inl _  =&gt; apply Or.inr; assumption
  | Or.inr h2 =&gt; apply Or.inl; exact h2
</code></pre>
<p>为了方便起见，模式匹配已经集成到<code>intro</code>和<code>funext</code>等策略中。</p>
<pre><code class="language-lean">example : s ∧ q ∧ r → p ∧ r → q ∧ p := by
  intro ⟨_, ⟨hq, _⟩⟩ ⟨hp, _⟩
  exact ⟨hq, hp⟩

example :
    (fun (x : Nat × Nat) (y : Nat × Nat) =&gt; x.1 + y.2)
    =
    (fun (x : Nat × Nat) (z : Nat × Nat) =&gt; z.2 + x.1) := by
  funext (a, b) (c, d)
  show a + d = d + a
  rw [Nat.add_comm]
</code></pre>
<p>我们在本节中介绍最后一种策略，它旨在方便使用归纳类型，即 <code>injection</code> 策略。按设计，归纳类型的元素是自由生成的，也就是说，构造函数是单射的，且范围不相交。<code>injection</code> 策略的设计就是为了利用这一事实：</p>
<pre><code class="language-lean">open Nat

example (m n k : Nat) (h : succ (succ m) = succ (succ n))
        : n + k = m + k := by
  injection h with h'
  injection h' with h''
  rw [h'']
</code></pre>
<p>该策略的第一个实例将“h' : succ m = succ n”添加到上下文中，而第二个实例将“h'' : m = n”添加到上下文中。</p>
<p><code>injection</code> 策略还会检测到当不同的构造函数相等时产生的矛盾，并使用它们来关闭目标。</p>
<pre><code class="language-lean">open Nat

example (m n : Nat) (h : succ m = 0) : n = n + 7 := by
  injection h

example (m n : Nat) (h : succ m = 0) : n = n + 7 := by
  contradiction

example (h : 7 = 4) : False := by
  contradiction
</code></pre>
<p>正如第二个例子展示的那样，<code>contradiction</code> 策略也可以检测到这种形式的矛盾。</p>
<h2 id="归纳家族"><a class="header" href="#归纳家族">归纳家族</a></h2>
<p>我们几乎已经描述完 Lean 可接受的归纳定义的全部范围。到目前为止，您已经看到 Lean 允许您引入具有任意数量的递归构造器的归纳类型。实际上，单个归纳定义可以引入一个索引化的<em>家族</em>归纳类型，我们将在下面进行描述。</p>
<p>一个归纳家族是由以下形式的同时归纳定义所定义的索引化类型族：</p>
<pre><code>inductive foo : ... → Sort u where
  | constructor₁ : ... → foo ...
  | constructor₂ : ... → foo ...
  ...
  | constructorₙ : ... → foo ...
</code></pre>
<p>与普通的归纳定义不同，普通的归纳定义构造了某个 <code>Sort u</code> 的元素，而更一般的版本构造了一个函数 <code>... → Sort u</code>，其中 &quot;<code>...</code>&quot; 表示一系列参数类型，也被称为<em>指标</em>。然后，每个构造函数构造了一个家族成员的元素。一个例子是 <code>Vector α n</code> 的定义，它是长度为 <code>n</code> 的 <code>α</code> 元素向量类型：</p>
<pre><code class="language-lean"># namespace Hidden
inductive Vector (α : Type u) : Nat → Type u where
  | nil  : Vector α 0
  | cons : α → {n : Nat} → Vector α n → Vector α (n+1)
# end Hidden
</code></pre>
<p>注意，<code>cons</code> 构造器接受一个属于 <code>Vector α n</code> 的元素，并返回一个属于 <code>Vector α (n+1)</code> 的元素，因此它使用了一个家族成员的元素来构建另一个成员的元素。</p>
<p>一个更为奇特的例子是 Lean 中等号类型的定义：</p>
<pre><code class="language-lean"># namespace Hidden
inductive Eq {α : Sort u} (a : α) : α → Prop where
  | refl : Eq a a
# end Hidden
</code></pre>
<p>对于固定的 <code>α : Sort u</code> 和 <code>a : α</code>，这个定义构造了一个类型族 <code>Eq a x</code>，其中 <code>x : α</code> 是索引。
然而需要注意的是，这个类型族只有一个构造器，即 <code>refl</code>，它是 <code>Eq a a</code> 的一个元素。
直观地说，构造 <code>Eq a x</code> 的证明的唯一方法是在 <code>x</code> 是 <code>a</code> 的情况下使用自反性。
需要注意的是，<code>Eq a a</code> 是类型族 <code>Eq a x</code> 中唯一有元素的类型。
Lean 生成的消除原则如下：</p>
<pre><code class="language-lean">universe u v

#check (@Eq.rec : {α : Sort u} → {a : α} → {motive : (x : α) → a = x → Sort v}
                  → motive a rfl → {b : α} → (h : a = b) → motive b h)
</code></pre>
<p>值得注意的是，所有关于相等性的基本公理都可以从构造子“refl”和消除子“Eq.rec”中推导出来。然而，相等性的定义是非典型的；请参阅<a href="inductive_types.html#axiomatic-details">公理细节部分</a>中的讨论。</p>
<p>消除子“Eq.rec”也用于定义替换：</p>
<pre><code class="language-lean"># namespace Hidden
theorem subst {α : Type u} {a b : α} {p : α → Prop} (h₁ : Eq a b) (h₂ : p a) : p b :=
  Eq.rec (motive := fun x _ =&gt; p x) h₂ h₁
# end Hidden
</code></pre>
<p>你还可以使用<code>match</code>定义<code>subst</code>。</p>
<pre><code class="language-lean"># namespace Hidden
theorem subst {α : Type u} {a b : α} {p : α → Prop} (h₁ : Eq a b) (h₂ : p a) : p b :=
  match h₁ with
  | rfl =&gt; h₂
# end Hidden
</code></pre>
<p>实际上，Lean 使用基于 <code>Eq.rec</code> 的定义来编译 <code>match</code> 表达式。</p>
<pre><code class="language-lean"># namespace Hidden
theorem subst {α : Type u} {a b : α} {p : α → Prop} (h₁ : Eq a b) (h₂ : p a) : p b :=
  match h₁ with
  | rfl =&gt; h₂

set_option pp.all true
#print subst
  -- ... subst.match_1 ...
#print subst.match_1
  -- ... Eq.casesOn ...
#print Eq.casesOn
  -- ... Eq.rec ...
# end Hidden
</code></pre>
<p>使用递归器或 <code>match</code>，假设有 <code>h₁ : a = b</code>，我们可以假设 <code>a</code> 和 <code>b</code> 是相同的，这样 <code>p b</code> 和 <code>p a</code> 也是相同的。</p>
<p>证明<code>Eq</code>是对称和传递的并不难。
在以下示例中，我们证明了<code>symm</code>，并将<code>trans</code>和<code>congr</code>（相容性）定理留为练习。</p>
<pre><code class="language-lean"># namespace Hidden
theorem symm {α : Type u} {a b : α} (h : Eq a b) : Eq b a :=
  match h with
  | rfl =&gt; rfl

theorem trans {α : Type u} {a b c : α} (h₁ : Eq a b) (h₂ : Eq b c) : Eq a c :=
  sorry

theorem congr {α β : Type u} {a b : α} (f : α → β) (h : Eq a b) : Eq (f a) (f b) :=
  sorry
# end Hidden
</code></pre>
<p>在类型理论文献中，还有进一步的归纳定义的一般化，比如“归纳递归”和“归纳归纳”的原理。但这些并不被 Lean 支持。</p>
<h2 id="公理细节"><a class="header" href="#公理细节">公理细节</a></h2>
<p>我们已经通过例子描述了归纳类型及其语法。本节提供了关于公理基础的额外信息。</p>
<p>我们已经看到归纳类型的构造子接受“参数”（在归纳构造过程中保持不变的参数）和“索引”（参数化正在同时构造的类型族的参数）作为输入。每个构造子应该有一个类型，其中的参数类型是由之前定义的类型、参数和索引类型以及当前正在定义的归纳族类型构建起来的。要求是如果后者存在，则它仅以<em>严格正变形</em>的形式出现。这简单地意味着构造子中出现的任何与之相关的参数都是依赖箭头类型，其中正在定义的归纳类型仅作为结果类型出现，在其中索引以常数和前面的参数的形式给出。</p>
<p>由于归纳类型位于某个<code>Sort u</code>中，因此合理地询问<code>u</code>可以被实例化为哪个宇宙层级。定义一族归纳类型<code>C</code>中的每个构造子<code>c</code>的形式为</p>
<pre><code>  c : (a : α) → (b : β[a]) → C a p[a,b]
</code></pre>
<p>其中 <code>a</code> 是数据类型参数的序列，<code>b</code> 是构造函数的参数序列，<code>p[a, b]</code> 是索引，用于确定构造的元素属于归纳族中的哪个部分。（需要注意的是，这个描述有点误导性，因为构造函数的参数可以以任何顺序出现，只要依赖关系合理即可。）对于 <code>C</code> 的宇宙级别的约束分为两种情况，取决于归纳类型是否被指定为落在 <code>Prop</code>（即 <code>Sort 0</code>）中。</p>
<p>首先考虑归纳类型不指定落在 <code>Prop</code> 中的情况。那么宇宙级别 <code>u</code> 需要满足以下约束：</p>
<blockquote>
<p>对于上述每个构造函数 <code>c</code>，以及序列 <code>β[a]</code> 的每个 <code>βk[a]</code>，如果 <code>βk[a] : Sort v</code>，则有 <code>u</code> ≥ <code>v</code>。</p>
</blockquote>
<p>换句话说，宇宙级别 <code>u</code> 要求至少与表示构造函数参数的每个类型的宇宙级别一样大。</p>
<p>当归纳类型被指定为落在 <code>Prop</code> 中时，对于构造函数参数的宇宙级别没有约束。但是这些宇宙级别确实对消除规则有影响。一般来说，对于落在 <code>Prop</code> 中的归纳类型，消除规则的动机必须落在 <code>Prop</code> 中。</p>
<p>在最后一条规则中有一个例外：当只有一个构造函数，并且每个构造函数参数要么在 <code>Prop</code> 中，要么是一个指数时，我们可以将归纳定义的 <code>Prop</code> 逐步消除为任意 <code>Sort</code>。直观上，这种情况下消除不需要使用任何除了类型被实例化之外的额外信息。这种特殊情况被称为<em>单例消除</em>。</p>
<p>我们已经在归纳定义的等式类型的<code>Eq.rec</code>使用中看到了单例消除的作用。我们可以使用元素<code>h : Eq a b</code>将元素<code>t' : p a</code>转换为<code>p b</code>，即使<code>p a</code>和<code>p b</code>是任意类型，
由于 cast 不生成新数据；它只是重新解释我们已经拥有的数据。单例消除也与异构相等和基于良基的递归一起使用，这将在《归纳和递归》一章中详细讨论。</p>
<h2 id="相互和嵌套的归纳类型"><a class="header" href="#相互和嵌套的归纳类型">相互和嵌套的归纳类型</a></h2>
<p>现在，我们考虑两个常用的归纳类型的一般化，Lean 通过将它们“编译”成上面描述的更原始的归纳类型来支持它们。换句话说，Lean 解析更一般的定义，基于它们定义辅助归纳类型，然后使用这些辅助类型来定义我们真正想要的类型。Lean 的等式编译器，将在下一章中描述，需要有效地使用这些类型。尽管如此，在这里描述这些声明是有意义的，因为它们是普通归纳定义的直接变体。</p>
<p>首先，Lean 支持 <em>相互定义的</em> 归纳类型。思想是我们可以同时定义两个（或更多）归纳类型，其中每个类型都引用其他类型。</p>
<pre><code class="language-lean">mutual
  inductive Even : Nat → Prop where
    | even_zero : Even 0
    | even_succ : (n : Nat) → Odd n → Even (n + 1)

  inductive Odd : Nat → Prop where
    | odd_succ : (n : Nat) → Even n → Odd (n + 1)
end
</code></pre>
<p>在这个例子中，同时定义了两种类型：自然数“n”是“Even”（偶数），如果它是“0”或者是一个“Odd”（奇数）加一，而且也是“Odd”（奇数），如果它是一个“Even”（偶数）加一。
在下面的练习中，你需要详细说明细节。</p>
<p>互相彼此的归纳定义也可以用来定义具有由“α”元素标记的节点的有限树的符号。</p>
<pre><code class="language-lean">mutual
    inductive Tree (α : Type u) where
      | node : α → TreeList α → Tree α

    inductive TreeList (α : Type u) where
      | nil  : TreeList α
      | cons : Tree α → TreeList α → TreeList α
end
</code></pre>
<p>根据这个定义，可以通过给出一个α类型的元素和一个可能为空的子树列表来构造一个<code>Tree α</code>的元素。子树列表由<code>TreeList α</code>类型表示，定义为空列表<code>nil</code>或者树和<code>TreeList α</code>的元素的<code>cons</code>。</p>
<p>然而，这个定义并不方便使用。如果子树列表由<code>List (Tree α)</code>类型给出，会更好，特别是因为Lean的库中包含了许多用于处理列表的函数和定理。可以证明<code>TreeList α</code>类型与<code>List (Tree α)</code>是<em>同构</em>的，但在这个同构之间来回转换结果很繁琐。</p>
<p>事实上，Lean允许我们定义真正想要的归纳类型：</p>
<pre><code class="language-lean">inductive Tree (α : Type u) where
  | mk : α → List (Tree α) → Tree α
</code></pre>
<p>这被称为<em>嵌套</em>归纳类型。它不完全符合上一节中给出的归纳类型的严格规定，因为<code>Tree</code>在<code>mk</code>的参数中不是严格正向出现的，而是嵌套在<code>List</code>类型构造子中。Lean内核会自动在<code>TreeList α</code>和<code>List (Tree α)</code>之间建立同构，并基于同构定义<code>Tree</code>的构造函数。</p>
<h2 id="练习-2"><a class="header" href="#练习-2">练习</a></h2>
<ol>
<li>
<p>尝试定义其他关于自然数的运算，如乘法、前驱函数（满足<code>pred 0 = 0</code>）、截断减法（当<code>m</code>大于等于<code>n</code>时，<code>n - m = 0</code>）和指数运算。然后，尝试证明它们的一些基本性质，基于我们已经证明的定理。</p>
<p>由于许多这些在Lean的核心库中已经定义好，您应该在一个名为&quot;Hidden&quot;的命名空间中工作，以避免名称冲突。</p>
</li>
<li>
<p>定义一些关于列表的操作，如 <code>length</code> 函数或 <code>reverse</code> 函数。证明一些属性，比如以下的性质：</p>
<p>a. <code>length (s ++ t) = length s + length t</code></p>
<p>b. <code>length (reverse t) = length t</code></p>
<p>c. <code>reverse (reverse t) = t</code></p>
</li>
<li>
<p>定义一个归纳数据类型，由以下构造子构建的项组成：</p>
<ul>
<li><code>const n</code>，表示自然数<code>n</code>的常数</li>
<li><code>var n</code>，表示编号为<code>n</code>的变量</li>
<li><code>plus s t</code>，表示<code>s</code>和<code>t</code>的和</li>
<li><code>times s t</code>，表示<code>s</code>和<code>t</code>的乘积</li>
</ul>
<p>递归地定义一个函数，对于变量的赋值，可以计算出任何这样的项。</p>
</li>
<li>
<p>同样，定义命题公式的类型，以及该类型上的函数：一个评估函数，度量公式复杂性的函数，以及用另一个给定的变量替换公式的函数。</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="归纳和递归"><a class="header" href="#归纳和递归">归纳和递归</a></h1>
<p>在前一章中，我们看到归纳定义为在 Lean 中引入新类型提供了一种强大的方式。此外，构造函数和递归器是定义在这些类型上的函数的唯一方法。通过命题即类型的对应关系，这意味着归纳是证明的基本方法。</p>
<p>Lean 提供了自然的方式来定义递归函数，进行模式匹配，并编写归纳证明。它允许您通过指定函数应满足的方程来定义函数，它还允许您通过指定如何处理可能出现的各种情况来证明定理。在幕后，这些描述被&quot;编译&quot;成原始递归器，使用我们称之为&quot;方程式编译器&quot;的过程。方程式编译器不是可信代码库的一部分；其输出由核心独立检查的项组成。</p>
<h2 id="模式匹配"><a class="header" href="#模式匹配">模式匹配</a></h2>
<p>模式的解释是编译过程的第一步。我们已经看到 <code>casesOn</code> 递归器可以根据所涉及的构造函数在归纳定义类型上定义函数和证明定理。但是，复杂的定义可能使用多个嵌套的<code>casesOn</code> 应用，并且可能很难阅读和理解。模式匹配提供了一种更方便、更熟悉于函数式编程语言的方法。</p>
<p>考虑归纳定义的自然数类型。每个自然数要么是 <code>zero</code> ，要么是 <code>succ x</code> ，因此您可以通过在每种情况下指定一个值来定义从自然数到任意类型的函数：</p>
<pre><code class="language-lean">open Nat

def sub1 : Nat → Nat
  | zero   =&gt; zero
  | succ x =&gt; x

def isZero : Nat → Bool
  | zero   =&gt; true
  | succ x =&gt; false
</code></pre>
<p>这些函数的定义方程在定义上成立：</p>
<pre><code class="language-lean"># open Nat
# def sub1 : Nat → Nat
#   | zero   =&gt; zero
#   | succ x =&gt; x
# def isZero : Nat → Bool
#   | zero   =&gt; true
#   | succ x =&gt; false
example : sub1 0 = 0 := rfl
example (x : Nat) : sub1 (succ x) = x := rfl

example : isZero 0 = true := rfl
example (x : Nat) : isZero (succ x) = false := rfl

example : sub1 7 = 6 := rfl
example (x : Nat) : isZero (x + 3) = false := rfl
</code></pre>
<p>与 <code>zero</code> 和 <code>succ</code> 相比，我们可以使用更熟悉的符号表示：</p>
<pre><code class="language-lean">def sub1 : Nat → Nat
  | 0   =&gt; 0
  | x+1 =&gt; x

def isZero : Nat → Bool
  | 0   =&gt; true
  | x+1 =&gt; false
</code></pre>
<p>因为加法和零符号被赋予了<code>[match_pattern]</code>属性，所以它们可以在模式匹配中使用。Lean会将这些表达式标准化，直到构造函数<code>zero</code>和<code>succ</code>被暴露出来。</p>
<p>模式匹配适用于任何归纳类型，比如乘积类型和可选类型：</p>
<pre><code class="language-lean">def swap : α × β → β × α
  | (a, b) =&gt; (b, a)

def foo : Nat × Nat → Nat
  | (m, n) =&gt; m + n

def bar : Option Nat → Nat
  | some n =&gt; n + 1
  | none   =&gt; 0
</code></pre>
<p>在这里，我们不仅使用它来定义一个函数，还用它来进行分情况证明：</p>
<pre><code class="language-lean"># namespace Hidden
def not : Bool → Bool
  | true  =&gt; false
  | false =&gt; true

theorem not_not : ∀ (b : Bool), not (not b) = b
  | true  =&gt; rfl  -- proof that not (not true) = true
  | false =&gt; rfl  -- proof that not (not false) = false
# end Hidden
</code></pre>
<p>模式匹配还可以用于解构归纳定义的命题：</p>
<p>Given an inductive proposition, we can use pattern matching to analyze its form and extract information from it. In Coq, one way to represent inductive propositions is through the use of constructors. Each constructor represents a different case of the proposition.</p>
<p>For example, let's consider the natural numbers defined in Coq as an inductive proposition:</p>
<pre><code class="language-coq">Inductive nat : Set :=
  | O : nat
  | S : nat -&gt; nat.
</code></pre>
<p>Here, <code>nat</code> is an inductive type that consists of two constructors. The <code>O</code> constructor represents zero, and the <code>S</code> constructor represents the successor of a natural number.</p>
<p>We can use pattern matching to analyze the form of a <code>nat</code> value. For instance, if we want to define a function <code>pred</code> that returns the predecessor of a given natural number, we can use pattern matching on the <code>nat</code> value:</p>
<pre><code class="language-coq">Definition pred (n : nat) : nat :=
  match n with
  | O =&gt; O
  | S m =&gt; m
  end.
</code></pre>
<p>In this function, we match on the argument <code>n</code> using the <code>match</code> keyword. We have two cases: if <code>n</code> is <code>O</code>, we return <code>O</code>. If <code>n</code> is of the form <code>S m</code>, we return <code>m</code>. Through pattern matching, we are able to destructure the inductive proposition <code>nat</code> and extract the necessary information.</p>
<p>Pattern matching can be extended to more complex inductive propositions as well. We can define more constructors and use pattern matching to handle each possible case. This allows us to reason about and work with inductively defined propositions in a structured way.</p>
<pre><code class="language-lean">example (p q : Prop) : p ∧ q → q ∧ p
  | And.intro h₁ h₂ =&gt; And.intro h₂ h₁

example (p q : Prop) : p ∨ q → q ∨ p
  | Or.inl hp =&gt; Or.inr hp
  | Or.inr hq =&gt; Or.inl hq
</code></pre>
<p>这提供了一种紧凑的方式来拆分使用逻辑连接词的假设。</p>
<p>在所有这些例子中，模式匹配被用于进行单个案例的区分。更有趣的是，模式可以涉及嵌套构造函数，就像以下的例子中那样。</p>
<pre><code class="language-lean">def sub2 : Nat → Nat
  | 0   =&gt; 0
  | 1   =&gt; 0
  | x+2 =&gt; x
</code></pre>
<p>方程编译器首先根据输入是否为 <code>zero</code> 或者 <code>succ x</code> 进行分割。然后它对 <code>x</code> 是否为 <code>zero</code> 或者 <code>succ x</code> 进行情况分割。它根据所提供的模式确定必要的情况分割，并在模式未能穷尽情况时引发错误。再次强调，我们可以使用下面的算术符号表示。无论哪种情况，这些定义方程都是定义上成立的。</p>
<pre><code class="language-lean"># def sub2 : Nat → Nat
#   | 0   =&gt; 0
#   | 1   =&gt; 0
#   | x+2 =&gt; x
example : sub2 0 = 0 := rfl
example : sub2 1 = 0 := rfl
example : sub2 (x+2) = x := rfl

example : sub2 5 = 3 := rfl
</code></pre>
<p>你可以写<code>#print sub2</code>来查看该函数如何编译为递归函数。(Lean将告诉你<code>sub2</code>是通过一个内部辅助函数<code>sub2.match_1</code>定义的，但你也可以打印出来。) Lean使用这些辅助函数来编译<code>match</code>表达式。实际上，上面的定义被展开为：</p>
<pre><code class="language-lean">def sub2 : Nat → Nat :=
  fun x =&gt;
    match x with
    | 0   =&gt; 0
    | 1   =&gt; 0
    | x+2 =&gt; x
</code></pre>
<p>下面是一些嵌套模式匹配的例子：</p>
<pre><code class="language-lean">example (p q : α → Prop)
        : (∃ x, p x ∨ q x) → (∃ x, p x) ∨ (∃ x, q x)
  | Exists.intro x (Or.inl px) =&gt; Or.inl (Exists.intro x px)
  | Exists.intro x (Or.inr qx) =&gt; Or.inr (Exists.intro x qx)

def foo : Nat × Nat → Nat
  | (0, n)     =&gt; 0
  | (m+1, 0)   =&gt; 1
  | (m+1, n+1) =&gt; 2
</code></pre>
<p>方程编译器可以按顺序处理多个参数。例如，将先前的示例定义为带有两个参数的函数会更自然：</p>
<pre><code class="language-lean">def foo : Nat → Nat → Nat
  | 0,   n   =&gt; 0
  | m+1, 0   =&gt; 1
  | m+1, n+1 =&gt; 2
</code></pre>
<p>这里是另一个例子：</p>
<pre><code class="language-lean">def bar : List Nat → List Nat → Nat
  | [],      []      =&gt; 0
  | a :: as, []      =&gt; a
  | [],      b :: bs =&gt; b
  | a :: as, b :: bs =&gt; a + b
</code></pre>
<p>请注意，这些模式被逗号分隔。</p>
<p>在下面的示例中，拆分仅发生在第一个参数上，尽管其他参数也包含在模式列表中。</p>
<pre><code class="language-lean"># namespace Hidden
def and : Bool → Bool → Bool
  | true,  a =&gt; a
  | false, _ =&gt; false

def or : Bool → Bool → Bool
  | true,  _ =&gt; true
  | false, a =&gt; a

def cond : Bool → α → α → α
  | true,  x, y =&gt; x
  | false, x, y =&gt; y
# end Hidden
</code></pre>
<p>注意，当定义中不需要参数的值时，可以使用下划线代替。这个下划线被称为 <em>通配模式</em> 或者 <em>匿名变量</em>。与方程编译器之外的使用不同，在这里下划线并不表示隐式参数。在函数式编程语言中使用下划线作为通配符是常见的，因此 Lean 采用了这种表示法。<a href="induction_and_recursion.html#%E9%80%9A%E9%85%8D%E7%AC%A6%E5%92%8C%E9%87%8D%E5%8F%A0%E6%A8%A1%E5%BC%8F">通配符和重叠模式</a>这一节详细介绍了通配符的概念，<a href="induction_and_recursion.html#%E4%B8%8D%E5%8F%AF%E8%AE%BF%E9%97%AE%E6%A8%A1%E5%BC%8F">不可访问模式</a>则解释了如何在模式中使用隐式参数。</p>
<p>正如在 <a href="./inductive_types.html">归纳型</a> 中所述，归纳数据类型可以依赖于参数。下面的例子使用模式匹配定义了 <code>tail</code> 函数。参数 <code>α : Type u</code> 是一个参数，并且出现在冒号之前，表示它不参与模式匹配。Lean 还允许参数出现在冒号之后，但不能在它们上进行模式匹配。</p>
<pre><code class="language-lean">def tail1 {α : Type u} : List α → List α
  | []      =&gt; []
  | a :: as =&gt; as

def tail2 : {α : Type u} → List α → List α
  | α, []      =&gt; []
  | α, a :: as =&gt; as
</code></pre>
<p>尽管在这两个示例中，参数 <code>α</code> 的位置不同，但在两种情况下它的处理方式相同，即它不参与到案例分析中。</p>
<p>Lean 还可以处理更复杂形式的模式匹配，其中依赖类型的参数对各种情况施加额外约束。这种 <em>依赖模式匹配</em> 的示例在 <a href="induction_and_recursion.html#dependent-pattern-matching">Dependent Pattern Matching</a> 章节中进行了探讨。</p>
<h2 id="通配符和重叠模式"><a class="header" href="#通配符和重叠模式">通配符和重叠模式</a></h2>
<p>考虑上一节中的一个示例：</p>
<pre><code class="language-lean">def foo : Nat → Nat → Nat
  | 0,   n   =&gt; 0
  | m+1, 0   =&gt; 1
  | m+1, n+1 =&gt; 2
</code></pre>
<p>另一种展示方法是：</p>
<pre><code class="language-lean">def foo : Nat → Nat → Nat
  | 0, n =&gt; 0
  | m, 0 =&gt; 1
  | m, n =&gt; 2
</code></pre>
<p>在第二个例子中，模式存在重叠；例如，参数对 <code>0 0</code> 适配了三个情况。但是 Lean 使用第一个匹配的方程来处理歧义，因此在这个例子中，最终的结果是相同的。特别地，以下等式在定义上是成立的：</p>
<pre><code class="language-lean"># def foo : Nat → Nat → Nat
#   | 0, n =&gt; 0
#   | m, 0 =&gt; 1
#   | m, n =&gt; 2
example : foo 0     0     = 0 := rfl
example : foo 0     (n+1) = 0 := rfl
example : foo (m+1) 0     = 1 := rfl
example : foo (m+1) (n+1) = 2 := rfl
</code></pre>
<p>因为不需要<code>m</code>和<code>n</code>的值，我们可以使用通配符模式来代替。</p>
<pre><code class="language-lean">def foo : Nat → Nat → Nat
  | 0, _ =&gt; 0
  | _, 0 =&gt; 1
  | _, _ =&gt; 2
</code></pre>
<p>您可以检查这个对 <code>foo</code> 的定义是否满足之前的定义特性。</p>
<p>一些函数式编程语言支持<em>不完整模式</em>。在这些语言中，解释器对于不完整模式可能会产生异常或返回任意值。我们可以使用 <code>Inhabited</code> 类型类模拟任意值的方法。粗略地说，<code>Inhabited α</code> 类型的元素是证明了存在 <code>α</code> 类型元素的见证；在<a href="./type_classes.html">类型类章节</a>中我们将看到，在 Lean 中可以指示适当的基本类型是有元素的，并且可以自动推断出其他构造类型也是有元素的。基于这个基础，标准库提供了任意有元素类型的默认元素 <code>default</code>。</p>
<p>我们也可以使用类型 <code>Option α</code> 来模拟不完整模式。思路是对于已有的模式返回 <code>some a</code>，对于不完整的情况返回 <code>none</code>。以下示例演示了两种方法。</p>
<pre><code class="language-lean">def f1 : Nat → Nat → Nat
  | 0, _  =&gt; 1
  | _, 0  =&gt; 2
  | _, _  =&gt; default  -- the &quot;incomplete&quot; case

example : f1 0     0     = 1       := rfl
example : f1 0     (a+1) = 1       := rfl
example : f1 (a+1) 0     = 2       := rfl
example : f1 (a+1) (b+1) = default := rfl

def f2 : Nat → Nat → Option Nat
  | 0, _  =&gt; some 1
  | _, 0  =&gt; some 2
  | _, _  =&gt; none     -- the &quot;incomplete&quot; case

example : f2 0     0     = some 1 := rfl
example : f2 0     (a+1) = some 1 := rfl
example : f2 (a+1) 0     = some 2 := rfl
example : f2 (a+1) (b+1) = none   := rfl
</code></pre>
<p>这个方程编译器非常聪明。如果你在下面的定义中漏掉了任何一种情况，错误信息将会告诉你哪些情况没有被覆盖到。</p>
<pre><code class="language-lean">def bar : Nat → List Nat → Bool → Nat
  | 0,   _,      false =&gt; 0
  | 0,   b :: _, _     =&gt; b
  | 0,   [],     true  =&gt; 7
  | a+1, [],     false =&gt; a
  | a+1, [],     true  =&gt; a + 1
  | a+1, b :: _, _     =&gt; a + b
</code></pre>
<p>在适当的情况下，它还会使用“if ... then ... else”而不是 <code>casesOn</code>。</p>
<p>使用<code>if ... then ... else</code>是一种在逻辑推理中常见的方式，它允许根据条件的不同结果采取不同的行动。它的一般形式是：</p>
<pre><code>if 条件 then 操作1 else 操作2
</code></pre>
<p>其中，条件是一个布尔表达式，操作1和操作2是具体的操作或表达式。</p>
<p>使用<code>if ... then ... else</code>语句可以代替<code>casesOn</code>，因为它提供了一种更加简洁和灵活的方式来描述不同情况下的操作。</p>
<p>例如，在证明一个关于自然数的命题时，我们可以使用<code>if ... then ... else</code>来区分两种不同的情况。假设我们要证明如果一个自然数是偶数，则它可以被2整除，否则它不能被2整除。我们可以这样写：</p>
<pre><code>Lemma even_divide_two : forall n : nat,
  (even n -&gt; exists k : nat, n = 2 * k) /\
  (~ even n -&gt; ~ exists k : nat, n = 2 * k).
Proof.
  intro n.
  destruct (even_dec n) as [Heven | Hnot_even].
  - (* Case: even n *)
    apply even_divide_two_helper.
    assumption.
  - (* Case: ~ even n *)
    split.
    + (* Subcase: ~ even n -&gt; exists k : nat, n = 2 * k *)
      intros Hexists.
      contradiction Hnot_even.
      apply even_divide_two_helper.
      assumption.
    + (* Subcase: ~ even n -&gt; ~ exists k : nat, n = 2 * k *)
      intros Hexists.
      inversion Hexists.
Qed`
</code></pre>
<p>在这个证明中，我们首先使用<code>destruct</code>来分解自然数<code>n</code>是否为偶数的假设，得到两种情况:<code>Heven</code>表示<code>n</code>是偶数，<code>Hnot_even</code>表示<code>n</code>不是偶数。然后我们使用<code>if ... then ... else</code>来处理两种情况。在第一种情况下，我们应用了一个辅助定理<code>even_divide_two_helper</code>来证明结论。而在第二种情况下，我们使用<code>split</code>将目标分为两个子目标，并使用<code>contradiction</code>和<code>inversion</code>来得到矛盾。</p>
<p>总之，<code>if ... then ... else</code>是一种有用的替代<code>casesOn</code>的方式，它提供了更简洁和灵活的方法来处理不同情况下的操作。</p>
<pre><code class="language-lean">def foo : Char → Nat
  | 'A' =&gt; 1
  | 'B' =&gt; 2
  | _   =&gt; 3

#print foo.match_1
</code></pre>
<h2 id="结构递归和归纳"><a class="header" href="#结构递归和归纳">结构递归和归纳</a></h2>
<p>使得等式编译器强大的是它还支持递归定义。在接下来的三个部分中，我们将分别描述：</p>
<ul>
<li>结构递归定义</li>
<li>依恋递归定义</li>
<li>互递归定义</li>
</ul>
<p>一般来说，等式编译器处理以下形式的输入：</p>
<pre><code>def foo (a : α) : (b : β) → γ
  | [patterns₁] =&gt; t₁
  ...
  | [patternsₙ] =&gt; tₙ
</code></pre>
<p>在这里 <code>(a:α)</code> 是一个参数序列，<code>(b:β)</code> 是模式匹配所依赖的参数序列，<code>γ</code> 是任意类型，可以依赖于<code>a</code>和<code>b</code>。 每一行应该包含相同数量的模式，与 <code>β</code> 中的元素一一对应。正如我们所看到的，模式可以是变量、构造函数应用到其他模式，或者是归一化为这种形式的表达式（非构造函数由 <code>[match_pattern]</code> 标记）。构造函数的出现会引发案例的分裂，构造函数的参数是指定的变量。在<a href="induction_and_recursion.html#dependent-pattern-matching">Dependent Pattern Matching章节</a>中，我们将看到有时需要在模式中包含显式的项来使一个表达式类型检查通过，尽管它们在模式匹配中不起作用。因此，这些被称为这些是“不可访问模式”。但在<a href="induction_and_recursion.html#dependent-pattern-matching">Dependent Pattern Matching章节</a>之前我们不需要使用这样的不可访问模式。</p>
<p>如我们在上一节中所见，术语 <code>t₁, ..., tₙ</code> 可以使用任何参数 <code>a</code>，以及在相应模式中引入的任何变量。使递归和归纳成为可能的是它们也可以涉及对 <code>foo</code> 的递归调用。在本节中，我们将处理<em>结构递归</em>，即出现在“: =”右侧的 <code>foo</code> 的参数是左侧模式的子项。其基本思想是这些参数在结构上较小，因此在归纳类型中较早出现。以下是一些使用方程编译器定义的结构递归的示例，这些例子来自上一章节：</p>
<pre><code class="language-lean">open Nat
def add : Nat → Nat → Nat
  | m, zero   =&gt; m
  | m, succ n =&gt; succ (add m n)

theorem add_zero (m : Nat)   : add m zero = m := rfl
theorem add_succ (m n : Nat) : add m (succ n) = succ (add m n) := rfl

theorem zero_add : ∀ n, add zero n = n
  | zero   =&gt; rfl
  | succ n =&gt; congrArg succ (zero_add n)

def mul : Nat → Nat → Nat
  | n, zero   =&gt; zero
  | n, succ m =&gt; add (mul n m) n
</code></pre>
<p><code>zero_add</code> 的证明清楚地表明，Lean 中的归纳证明实际上是一种递归形式。</p>
<p>上面的例子表明，<code>add</code> 的定义方程在定义上成立，<code>mul</code> 也是如此。方程编译器在可能的情况下努力确保这一点，正如直接结构归纳的情况一样。然而，在其他情况下，简化只在命题上成立，也就是说，它们是必须显式应用的等式定理。方程编译器在内部生成这样的定理。用户不能直接使用它们；相反，<code>simp</code>策略被配置为在必要时使用它们。因此，<code>zero_add</code> 的以下两个证明都是有效的：</p>
<pre><code class="language-lean">open Nat
# def add : Nat → Nat → Nat
#   | m, zero   =&gt; m
#   | m, succ n =&gt; succ (add m n)
theorem zero_add : ∀ n, add zero n = n
  | zero   =&gt; by simp [add]
  | succ n =&gt; by simp [add, zero_add]
</code></pre>
<p>与模式匹配定义一样，结构递归或归纳的参数可以出现在冒号之前。这样的参数只是在定义被处理之前添加到局部上下文中。例如，加法的定义也可以写成以下形式：</p>
<pre><code class="language-lean">def add : nat → nat → nat
| 0     m := m,
| succ n m := succ (add n m)
</code></pre>
<p>这里，<code>nat</code> 是类型，<code>add</code> 是函数名，<code>: nat → nat → nat</code> 是函数的类型，表示接受两个 <code>nat</code> 类型的参数并返回一个 <code>nat</code> 类型的结果。</p>
<p>第一行是函数的定义，使用了模式匹配的方式。<code>| 0 m := m</code> 意味着当第一个参数为 <code>0</code>，第二个参数为 <code>m</code> 时，函数返回 <code>m</code>。第二行的 <code>succ n m</code> 是前面定义的自然数类型的后继构造子，表示第一个参数为 <code>n</code> 的后继。函数体 <code>succ (add n m)</code> 表示递归调用函数 <code>add</code> 并对其结果应用后继构造子。</p>
<p>这个定义的含义是：对于 <code>n</code> 和 <code>m</code> 两个自然数，<code>add n m</code> 表示将 <code>n</code> 和 <code>m</code> 相加的结果。如果 <code>n</code> 为 <code>0</code>，那么结果就是 <code>m</code>。否则，递归地对 <code>n</code> 的前一个自然数和 <code>m</code> 进行相加，并将结果的后继作为最终的结果。</p>
<pre><code class="language-lean">open Nat
def add (m : Nat) : Nat → Nat
  | zero   =&gt; m
  | succ n =&gt; succ (add m n)
</code></pre>
<p>你还可以使用 <code>match</code> 来编写上述示例。</p>
<pre><code class="language-lean">def pred : nat → Prop
| zero := true
| (succ n) := false

def is_zero (n : nat) : Prop :=
match n with
| zero := true
| _ := false
end
</code></pre>
<p>在上述代码中，我们使用 <code>match</code> 来定义了两个函数 <code>pred</code> 和 <code>is_zero</code>。函数 <code>pred</code> 接受一个自然数作为参数，并返回一个命题。当参数为零时，返回真；否则返回假。函数 <code>is_zero</code> 接受一个自然数作为参数，并返回一个命题。当参数为零时，返回真；否则返回假。</p>
<pre><code class="language-lean">open Nat
def add (m n : Nat) : Nat :=
  match n with
  | zero   =&gt; m
  | succ n =&gt; succ (add m n)
</code></pre>
<p><code>fib</code> is defined recursively as follows:</p>
<p>[
\text{{fib}}(0) = 0
]</p>
<p>[
\text{{fib}}(1) = 1
]</p>
<p>[
\text{{fib}}(n+2) = \text{{fib}}(n+1) + \text{{fib}}(n)
]</p>
<p>This definition states that the Fibonacci function returns 0 for input 0, 1 for input 1, and for any other input, it returns the sum of the previous two Fibonacci numbers.</p>
<p>To prove that the Fibonacci function is well-defined and total, we can use structural induction.</p>
<p>Let's define the property (\text{{fib_property}}(n, x)) as the statement: &quot;For any (n \geq 0), the Fibonacci function (\text{{fib}}) is defined and returns (x) for input (n).&quot;</p>
<p>(\text{{fib_property}}) can be proven for all (n) using structural induction on (n):</p>
<p><strong>Base case:</strong>
For (n = 0):
(\text{{fib}}(0) = 0), which matches our definition. Therefore, (\text{{fib_property}}(0, 0)) holds.</p>
<p>For (n = 1):
(\text{{fib}}(1) = 1), which also matches our definition. Therefore, (\text{{fib_property}}(1, 1)) holds.</p>
<p><strong>Inductive step:</strong>
Assume (\text{{fib_property}}(k, x)) and (\text{{fib_property}}(k+1, y)) are true for some (k \geq 1).</p>
<p>We need to show that (\text{{fib_property}}(k+2, x+y)) holds.</p>
<p>According to the definition of (\text{{fib}}), (\text{{fib}}(k+2) = \text{{fib}}(k+1) + \text{{fib}}(k)). Since (\text{{fib_property}}(k, x)) and (\text{{fib_property}}(k+1, y)) hold, we can substitute (x) and (y) with (\text{{fib}}(k)) and (\text{{fib}}(k+1)) respectively.</p>
<p>Therefore, (\text{{fib_property}}(k+2, x+y)) is true.</p>
<p>By the principle of structural induction, (\text{{fib_property}}(n, x)) holds for all (n \geq 0).</p>
<p>Thus, the Fibonacci function is well-defined and total.</p>
<p>In conclusion, the Fibonacci function is a more interesting example of structural recursion as it requires adding the previous two Fibonacci numbers to calculate the next one.</p>
<pre><code class="language-lean">def fib : Nat → Nat
  | 0   =&gt; 1
  | 1   =&gt; 1
  | n+2 =&gt; fib (n+1) + fib n

example : fib 0 = 1 := rfl
example : fib 1 = 1 := rfl
example : fib (n + 2) = fib (n + 1) + fib n := rfl

example : fib 7 = 21 := rfl
</code></pre>
<p>这里，<code>fib</code> 函数在 <code>n + 2</code>（这相当于 <code>succ (succ n)</code>）的值被定义为在 <code>n + 1</code>（这相当于 <code>succ n</code>）和在 <code>n</code> 处的值的组合。然而，这种计算 Fibonacci 函数的方法是众所周知的低效的，其执行时间在 <code>n</code> 指数级增长。下面是一个更好的方法：</p>
<pre><code class="language-lean">def fibFast (n : Nat) : Nat :=
  (loop n).2
where
  loop : Nat → Nat × Nat
    | 0   =&gt; (0, 1)
    | n+1 =&gt; let p := loop n; (p.2, p.1 + p.2)

#eval fibFast 100
</code></pre>
<p>以下是使用<code>let rec</code>而不是<code>where</code>定义相同定理的代码段：</p>
<pre><code class="language-fsharp">let rec mylt (x : nat) (y : nat) : nat =
  match x with
  | Z -&gt; Z
  | S x1 -&gt; add y (mylt x1 y)
</code></pre>
<p>上述代码段中的<code>let rec</code>表示这是一个递归函数的定义，而不是一个简单的函数定义。这意味着在函数体中，可以使用函数自身来进行递归调用，而不需要使用<code>where</code>子句来定义。</p>
<p>注意，上述代码段中的<code>nat</code>是<code>Lean</code>中的自然数类型，<code>Z</code>表示零，<code>S</code>表示后继操作，<code>add</code>表示自然数的加法操作。</p>
<p>带有<code>let rec</code>的代码段实现了与上一个定义相同的功能，即计算两个自然数的乘积。与以前一样，它使用模式匹配来处理自然数的可能情况，并通过递归地调用自身来实现乘法操作。</p>
<pre><code class="language-lean">def fibFast (n : Nat) : Nat :=
  let rec loop : Nat → Nat × Nat
    | 0   =&gt; (0, 1)
    | n+1 =&gt; let p := loop n; (p.2, p.1 + p.2)
  (loop n).2
</code></pre>
<p>在这两种情况下，Lean生成辅助函数 <code>fibFast.loop</code>。</p>
<p>为了处理结构性递归，方程编译器使用 <em>course-of-values</em> 递归，使用自动生成的常量 <code>below</code> 和 <code>brecOn</code>，这些常量与每个递归定义的类型一起使用。通过查看 <code>Nat.below</code> 和 <code>Nat.brecOn</code> 的类型，可以了解其工作原理：</p>
<pre><code class="language-lean">variable (C : Nat → Type u)

#check (@Nat.below C : Nat → Type u)

#reduce @Nat.below C (3 : Nat)

#check (@Nat.brecOn C : (n : Nat) → ((n : Nat) → @Nat.below C n → C n) → C n)
</code></pre>
<p>类型 <code>@Nat.below C (3 : nat)</code> 是一个存储 <code>C 0</code>、<code>C 1</code> 和 <code>C 2</code> 元素的数据结构。
课程值递归可以通过 <code>Nat.brecOn</code> 来实现。它使我们能够根据函数的所有前一值（表示为 <code>@Nat.below C n</code> 的元素）来定义类型为 <code>(n : Nat) → C n</code> 的依赖函数在特定输入 <code>n</code> 处的值。</p>
<p>课程值递归是方程编译器用来向 Lean 内核证明函数终止性的一种技术之一。它不会影响编译递归函数的代码生成器，就像其他函数式编程语言编译器一样。记住，<code>#eval fib &lt;n&gt;</code> 在 <code>&lt;n&gt;</code> 上是指数级的。另一方面，<code>#reduce fib &lt;n&gt;</code> 是高效的，因为它使用基于 <code>brecOn</code> 构造的发送给内核的定义。</p>
<pre><code class="language-lean">def fib : Nat → Nat
  | 0   =&gt; 1
  | 1   =&gt; 1
  | n+2 =&gt; fib (n+1) + fib n

-- #eval fib 50 -- slow
#reduce fib 50  -- fast

#print fib
</code></pre>
<p>另一个很好的递归定义的例子是列表<code>append</code>函数。</p>
<p><code>append</code>函数用于将两个列表拼接在一起。如果两个列表都为空，则拼接结果为空；如果第一个列表非空，则结果列表的头部是第一个列表的头部，后面跟着将第一个列表的尾部和第二个列表拼接在一起的结果。我们可以使用递归的方法来定义这个函数。</p>
<p>下面是用 LEAN 证明<code>append</code>函数性质的代码：</p>
<pre><code class="language-lean">namespace append

def append {α : Type} : list α → list α → list α
| [] l := l
| (h::t) l := h :: (append t l)

notation a ++ b := append a b

theorem nil_append (l : list α) : [] ++ l = l :=
  rfl

theorem cons_append (h : α) (t l : list α) : (h :: t) ++ l = h :: (t ++ l) :=
  rfl

end append
</code></pre>
<p>我们首先定义了一个命名空间<code>append</code>，在其中定义了<code>append</code>函数。函数接受两个参数，分别是类型为<code>α</code>的两个列表。接下来，我们使用模式匹配的方式来定义<code>append</code>函数的两个情况：如果第一个列表为空，则拼接结果为第二个列表；如果第一个列表非空，我们将第一个列表的头部<code>h</code>与将第一个列表的尾部<code>t</code>与第二个列表<code>l</code>拼接的结果组成一个新的列表。</p>
<p><code>append</code>函数还定义了一个可读性更好的符号<code>++</code>来表示列表的拼接运算。</p>
<p>在上面给出的代码中，我们还给出了两个定理的证明来验证<code>append</code>函数的性质。首先，<code>nil_append</code>定理说明了如果将一个空列表<code>[]</code>与另一个列表<code>l</code>拼接，结果应该是<code>l</code>本身。其次，<code>cons_append</code>定理说明了如果将一个非空列表<code>(h :: t)</code>与另一个列表<code>l</code>拼接，结果应该是将<code>h</code>添加到<code>t</code>与<code>l</code>拼接的结果的头部。这两个定理的证明使用了先前定义的<code>append</code>函数的模式匹配规则。</p>
<p>通过这种递归的方式定义<code>append</code>函数，我们可以方便地进行列表的拼接操作，并且保持代码的简洁性和可读性。</p>
<pre><code class="language-lean">def append : List α → List α → List α
  | [],    bs =&gt; bs
  | a::as, bs =&gt; a :: append as bs

example : append [1, 2, 3] [4, 5] = [1, 2, 3, 4, 5] := rfl
</code></pre>
<p>这里有另一个函数:它将第一个列表的元素与第二个列表的元素相加，直到两个列表中的一个用尽为止。</p>
<pre><code class="language-lean">def listAdd [Add α] : List α → List α → List α
  | [],      _       =&gt; []
  | _,       []      =&gt; []
  | a :: as, b :: bs =&gt; (a + b) :: listAdd as bs

#eval listAdd [1, 2, 3] [4, 5, 6, 6, 9, 10]
-- [5, 7, 9]
</code></pre>
<p>你可以使用 <code>let rec</code> 关键字定义本地递归声明。</p>
<pre><code class="language-lean">def factorial : ℕ → ℕ
| 0 := 1
| (n+1) := (n+1) * factorial n

#eval factorial 5
</code></pre>
<p>在这个例子中，我们定义了一个阶乘函数 <code>factorial</code>，它接受一个自然数作为输入，并返回其阶乘的结果。在函数体内部，我们使用了模式匹配的方式来处理不同的情况。如果输入为 <code>0</code>，那么阶乘的结果就是 <code>1</code>；如果输入为 <code>n+1</code>（其中 <code>n</code> 是大于等于 <code>0</code> 的自然数），那么阶乘的结果就是 <code>(n+1) * factorial n</code>，即 <code>(n+1)</code> 乘以 <code>n</code> 的阶乘。最后，我们通过调用 <code>factorial 5</code> 来计算 <code>5</code> 的阶乘，并使用 <code>#eval</code> 指令将其输出。</p>
<p>希望你能通过练习来尝试类似的例子。</p>
<pre><code class="language-lean">def replicate (n : Nat) (a : α) : List α :=
  let rec loop : Nat → List α → List α
    | 0,   as =&gt; as
    | n+1, as =&gt; loop n (a::as)
  loop n []

#check @replicate.loop
-- {α : Type} → α → Nat → List α → List α
</code></pre>
<p>Lean 对于每个 <code>let rec</code> 创建了一个辅助声明。在上面的例子中，它为出现在 <code>replicate</code> 处的 <code>let rec loop</code> 创建了声明 <code>replicate.loop</code>。请注意，Lean 通过将 <code>let rec</code> 声明中出现的局部变量添加为额外参数来 &quot;关闭&quot; 声明。例如，在 <code>let rec loop</code> 中出现的局部变量 <code>a</code>。</p>
<p>你也可以在策略模式下使用 <code>let rec</code> 来创建归纳证明的证明。</p>
<pre><code class="language-lean"># def replicate (n : Nat) (a : α) : List α :=
#  let rec loop : Nat → List α → List α
#    | 0,   as =&gt; as
#    | n+1, as =&gt; loop n (a::as)
#  loop n []
theorem length_replicate (n : Nat) (a : α) : (replicate n a).length = n := by
  let rec aux (n : Nat) (as : List α)
              : (replicate.loop a n as).length = n + as.length := by
    match n with
    | 0   =&gt; simp [replicate.loop]
    | n+1 =&gt; simp [replicate.loop, aux n, Nat.add_succ, Nat.succ_add]
  exact aux n []
</code></pre>
<p>你还可以在你的定义之后使用 <code>where</code> 子句引入辅助递归声明。
Lean 将它们转换为 <code>let rec</code>。</p>
<pre><code class="language-lean">def replicate (n : Nat) (a : α) : List α :=
  loop n []
where
  loop : Nat → List α → List α
    | 0,   as =&gt; as
    | n+1, as =&gt; loop n (a::as)

theorem length_replicate (n : Nat) (a : α) : (replicate n a).length = n := by
  exact aux n []
where
  aux (n : Nat) (as : List α)
      : (replicate.loop a n as).length = n + as.length := by
    match n with
    | 0   =&gt; simp [replicate.loop]
    | n+1 =&gt; simp [replicate.loop, aux n, Nat.add_succ, Nat.succ_add]
</code></pre>
<h2 id="基于良基递归和归纳"><a class="header" href="#基于良基递归和归纳">基于良基递归和归纳</a></h2>
<p>当结构递归无法使用时，我们可以使用良基递归来证明终止性。我们需要一个良基关系，并证明每个递归应用对于这个关系来说是递减的。依赖类型理论足够强大，可以对良基递归进行编码和证明。让我们从逻辑背景开始，以便理解其工作原理。</p>
<p>Lean标准库定义了两个谓词，<code>Acc r a</code> 和 <code>WellFounded r</code>，其中 <code>r</code> 是类型<code>α</code>上的二元关系，而 <code>a</code> 是类型 <code>α</code> 的一个元素。</p>
<pre><code class="language-lean">variable (α : Sort u)
variable (r : α → α → Prop)

#check (Acc r : α → Prop)
#check (WellFounded r : Prop)
</code></pre>
<p>第一个谓词 &quot;Acc&quot; 是一个归纳定义的谓词。根据它的定义，&quot;Acc r x&quot; 等价于 &quot;∀ y, r y x → Acc r y&quot;。如果我们将 &quot;r y x&quot; 看作一种顺序关系 &quot;y ≺ x&quot;，那么 &quot;Acc r x&quot; 表示 &quot;x&quot; 从下方可达，也就是说它的所有前驱都是可达的。特别地，如果 &quot;x&quot; 没有任何前驱，那么它是可达的。对于任意类型 &quot;α&quot;，我们应该能够通过首先给所有前驱赋值来递归地为 &quot;α&quot; 中的每个可达元素赋值。</p>
<p>谓词 &quot;r&quot; 是&quot;良基&quot;（well founded）的表述，记作 &quot;WellFounded r&quot;，实际上是类型中的每个元素都是可达的表述。以上考虑表明，如果 &quot;r&quot; 是作用在类型 &quot;α&quot; 上的一个良基关系，那么我们应该拥有一个相对于关系 &quot;r&quot; 在类型 &quot;α&quot; 上进行良基递归运算的原则。实际上，我们确实拥有：标准库定义了函数 &quot;WellFounded.fix&quot;，正好用于这个目的。</p>
<pre><code class="language-lean">noncomputable def f {α : Sort u}
      (r : α → α → Prop)
      (h : WellFounded r)
      (C : α → Sort v)
      (F : (x : α) → ((y : α) → r y x → C y) → C x)
      : (x : α) → C x := WellFounded.fix h F
</code></pre>
<p>这里有一系列的角色，但第一个块我们已经见过了：类型 <code>α</code>，关系 <code>r</code>，以及假设 <code>h</code>，即 <code>r</code> 是良基的。变量 <code>C</code> 表示递归定义的目的：对于每个元素 <code>x:α</code>，我们想要构造一个 <code>C x</code> 的元素。函数 <code>F</code> 提供了构造元素 <code>C x</code> 的归纳步骤：它告诉我们如何在给定每个前身 <code>y</code> 的 <code>C y</code> 的元素的情况下构造 <code>C x</code> 的元素。</p>
<p>请注意，<code>WellFounded.fix</code> 同样适用于归纳原则。它表示如果 <code>≺</code> 是良基的并且你想要证明 <code>∀x, C x</code>，只需要证明对于任意的 <code>x</code>，如果我们有 <code>∀y ≺ x, C y</code>，那么我们就有 <code>C x</code>。</p>
<p>在上面的示例中，我们使用了 <code>noncomputable</code> 修饰词，因为代码生成器当前不支持 <code>WellFounded.fix</code>。函数 <code>WellFounded.fix</code> 是 Lean 用来证明函数终止的另一个工具。</p>
<p>Lean 知道自然数上的通常顺序 <code>&lt;</code> 是良基的。它还知道许多从其他基础顺序构建新良基顺序的方法，例如使用字典顺序。</p>
<p>下面是在标准库中找到的自然数除法的基本定义。</p>
<pre><code class="language-lean">open Nat

theorem div_lemma {x y : Nat} : 0 &lt; y ∧ y ≤ x → x - y &lt; x :=
  fun h =&gt; sub_lt (Nat.lt_of_lt_of_le h.left h.right) h.left

def div.F (x : Nat) (f : (x₁ : Nat) → x₁ &lt; x → Nat → Nat) (y : Nat) : Nat :=
  if h : 0 &lt; y ∧ y ≤ x then
    f (x - y) (div_lemma h) y + 1
  else
    zero

noncomputable def div := WellFounded.fix (measure id).wf div.F

#reduce div 8 2 -- 4
</code></pre>
<p>这个定义有些晦涩。这里的递归是在“x”上进行的，而“div.F x f: Nat → Nat”返回了针对固定“x”的“除以y”函数。您必须记住，“div.F”的第二个参数，即递归的配方，是一个函数，它应该返回所有小于“x”的值“x₁”的“除以y”函数。</p>
<p>这个推导器是为了使这样的定义更加方便而设计的。它接受以下内容：</p>
<pre><code class="language-lean">def div (x y : Nat) : Nat :=
  if h : 0 &lt; y ∧ y ≤ x then
    have : x - y &lt; x := Nat.sub_lt (Nat.lt_of_lt_of_le h.1 h.2) h.1
    div (x - y) y + 1
  else
    0
</code></pre>
<p>当 Lean 遇到递归定义时，首先尝试结构递归，只有在失败时才会退回到良基递归。Lean 使用 <code>decreasing_tactic</code> 策略来展示递归应用较小。上面例子中的辅助命题 <code>x - y &lt; x</code> 应被视为该策略的提示。</p>
<p><code>div</code> 的定义方程 <em>不</em> 是严格成立的，但我们可以使用 <code>unfold</code> 策略来展开 <code>div</code>。我们使用 <a href="./conv.html"><code>conv</code></a> 来选择要展开的 <code>div</code> 应用。</p>
<pre><code class="language-lean"># def div (x y : Nat) : Nat :=
#  if h : 0 &lt; y ∧ y ≤ x then
#    have : x - y &lt; x := Nat.sub_lt (Nat.lt_of_lt_of_le h.1 h.2) h.1
#    div (x - y) y + 1
#  else
#    0
example (x y : Nat) : div x y = if 0 &lt; y ∧ y ≤ x then div (x - y) y + 1 else 0 := by
  conv =&gt; lhs; unfold div -- unfold occurrence in the left-hand-side of the equation

example (x y : Nat) (h : 0 &lt; y ∧ y ≤ x) : div x y = div (x - y) y + 1 := by
  conv =&gt; lhs; unfold div
  simp [h]
</code></pre>
<p>下面的例子与之类似：它将任何自然数转换为以0和1表示的二进制表达式，表示为一个列表。我们需要提供递归调用是递减的证据，我们在这里使用<code>sorry</code>来说明。<code>sorry</code>并不会阻止解释器成功执行函数。</p>
<pre><code class="language-lean">def natToBin : Nat → List Nat
  | 0     =&gt; [0]
  | 1     =&gt; [1]
  | n + 2 =&gt;
    have : (n + 2) / 2 &lt; n + 2 := sorry
    natToBin ((n + 2) / 2) ++ [n % 2]

#eval natToBin 1234567
</code></pre>
<p>作为最后一个示例，我们观察到 Ackermann 函数可以直接定义，因为它是通过自然数上的字典序的良定义性来证明的。<code>termination_by</code> 子句指示 Lean 使用一个字典序。此子句实际上是将函数参数映射到类型为 <code>Nat × Nat</code> 的元素上。然后，Lean 使用类型类解析来合成一个类型为 <code>WellFoundedRelation (Nat × Nat)</code> 的元素。</p>
<pre><code class="language-lean">def ack : Nat → Nat → Nat
  | 0,   y   =&gt; y+1
  | x+1, 0   =&gt; ack x 1
  | x+1, y+1 =&gt; ack x (ack (x+1) y)
termination_by ack x y =&gt; (x, y)
</code></pre>
<p>请注意，上面的例子中使用了字典序，因为 <code>WellFoundedRelation (α × β)</code> 实例使用了字典序。Lean 还定义了该实例。</p>
<pre><code class="language-lean">instance (priority := low) [SizeOf α] : WellFoundedRelation α :=
  sizeOfWFRel
</code></pre>
<p>在下面的例子中，我们通过展示递归应用中 <code>as.size - i</code> 正在减小来证明终止性。</p>
<pre><code class="language-lean">def takeWhile (p : α → Bool) (as : Array α) : Array α :=
  go 0 #[]
where
  go (i : Nat) (r : Array α) : Array α :=
    if h : i &lt; as.size then
      let a := as.get ⟨i, h⟩
      if p a then
        go (i+1) (r.push a)
      else
        r
    else
      r
termination_by go i r =&gt; as.size - i
</code></pre>
<p>请注意，此示例中的辅助函数 <code>go</code> 是递归的，但 <code>takeWhile</code> 不是。</p>
<p>默认情况下，Lean 使用 <code>decreasing_tactic</code> 策略来证明递归应用是递减的。修饰符 <code>decreasing_by</code> 允许我们使用自己的策略。以下是一个示例。</p>
<pre><code>def takeWhile {α : Type} (p : α → Prop) : list α → list α :=
  fix go : list α → list α :=
    λ xs, match xs with
          | []         := []
          | (x :: xs') := if p x then x :: go xs' else []
          end
  in go
</code></pre>
<p>在这个例子中，<code>takeWhile</code> 函数的定义包含一个名为 <code>go</code> 的辅助函数。这个辅助函数使用<code>fix</code>来定义，这意味着它是递归的。通过模式匹配，<code>go</code> 在遇到空列表时返回空列表，否则会检查列表中的第一个元素是否满足谓词 <code>p</code>。如果满足，则将第一个元素加入结果列表，并递归调用 <code>go</code> 处理剩下的元素。如果不满足，直接返回空列表。</p>
<p>需要注意的是，<code>go</code> 在递归调用时可能会引发警告，因为默认情况下 Lean 会使用 <code>decreasing_tactic</code> 来确保递归调用是递减的。如果使用者没有提供递减证明，Lean 可能会报出“应用了非递减参数”的错误。使用 <code>decreasing_by</code> 修饰符可以允许我们自定义递减证明的策略。</p>
<p>点击<a href="https://leanprover.github.io/theorem_proving_in_lean/quantifiers_and_equality.html#recursor-decreasing">此处</a>了解更多关于自定义递减证明策略的内容。</p>
<pre><code class="language-lean">theorem div_lemma {x y : Nat} : 0 &lt; y ∧ y ≤ x → x - y &lt; x :=
  fun ⟨ypos, ylex⟩ =&gt; Nat.sub_lt (Nat.lt_of_lt_of_le ypos ylex) ypos

def div (x y : Nat) : Nat :=
  if h : 0 &lt; y ∧ y ≤ x then
    div (x - y) y + 1
  else
    0
decreasing_by apply div_lemma; assumption
</code></pre>
<p>注意，<code>decreasing_by</code>不是<code>termination_by</code>的替代品，它们是互补的。<code>termination_by</code>用于指定一个良序关系，而<code>decreasing_by</code>用于提供我们自己的策略来证明递归应用是递减的。在下面的示例中，我们都使用了它们。</p>
<pre><code class="language-lean">def ack : Nat → Nat → Nat
  | 0,   y   =&gt; y+1
  | x+1, 0   =&gt; ack x 1
  | x+1, y+1 =&gt; ack x (ack (x+1) y)
termination_by ack x y =&gt; (x, y)
decreasing_by
  simp_wf -- unfolds well-founded recursion auxiliary definitions
  first | apply Prod.Lex.right; simp_arith
        | apply Prod.Lex.left; simp_arith
</code></pre>
<p>我们可以使用 <code>decreasing_by sorry</code> 来告诉 Lean &quot;相信&quot; 我们的函数会终止。</p>
<pre><code class="language-lean">def natToBin : Nat → List Nat
  | 0     =&gt; [0]
  | 1     =&gt; [1]
  | n + 2 =&gt; natToBin ((n + 2) / 2) ++ [n % 2]
decreasing_by sorry

#eval natToBin 1234567
</code></pre>
<p>回想一下，使用 <code>sorry</code> 和使用一个新公理是等价的，应该避免使用。在下面的例子中，我们使用了 <code>sorry</code> 来证明 <code>False</code>。命令 <code>#print axioms</code> 显示出 <code>unsound</code> 依赖于不完备公理 <code>sorryAx</code>，而该公理用于实现 <code>sorry</code>。</p>
<pre><code class="language-lean">def unsound (x : Nat) : False :=
  unsound (x + 1)
decreasing_by sorry

#check unsound 0
-- `unsound 0` is a proof of `False`

#print axioms unsound
-- 'unsound' depends on axioms: [sorryAx]
</code></pre>
<h2 id="互递归"><a class="header" href="#互递归">互递归</a></h2>
<p>Lean 也支持互递归的定义。其语法与互归归纳类型相似。下面是一个例子：</p>
<pre><code class="language-lean">mutual def even, odd : Nat → Prop
| 0     =&gt; true
| (n+1) =&gt; odd n
with odd : Nat → Prop
| 0     =&gt; false
| (n+1) =&gt; even n
</code></pre>
<p>在上面的例子中，<code>even</code> 和 <code>odd</code> 是两个互递归的函数，它们递归地定义了自然数是否为偶数和奇数的性质。</p>
<h2 id="证明"><a class="header" href="#证明">证明</a></h2>
<p>为了证明递归函数的终止性，Lean 提供了 <code>termination_by</code> 类来指定使用哪个类型的良序关系。如果没有指定 <code>termination_by</code>，Lean 将根据函数参数的类型使用类型类解析来推导良序关系。</p>
<p>如果指定了 <code>termination_by</code>，它将函数的参数映射到类型 <code>α</code> 上，并且再次使用类型类解析。需要注意的是，默认情况下，<code>β × γ</code> 的默认实例是基于 <code>β</code> 和 <code>γ</code> 的良序关系构建的词典序。</p>
<p>对于自然数 <code>Nat</code>，默认的良序关系实例是 <code>&lt;</code> 关系。</p>
<p>默认情况下，<code>decreasing_tactic</code> 策略用于证明递归应用相对于选择的良序关系来说更小。如果 <code>decreasing_tactic</code> 失败，错误信息中将包含剩余的目标 <code>... |- G</code>。需要注意的是，<code>decreasing_tactic</code> 使用 <code>assumption</code> 策略。因此，您可以使用 <code>have</code> 表达式来证明目标 <code>G</code>。您还可以使用 <code>decreasing_by</code> 来提供自己的策略。</p>
<pre><code class="language-lean">mutual
  def even : Nat → Bool
    | 0   =&gt; true
    | n+1 =&gt; odd n

  def odd : Nat → Bool
    | 0   =&gt; false
    | n+1 =&gt; even n
end

example : even (a + 1) = odd a := by
  simp [even]

example : odd (a + 1) = even a := by
  simp [odd]

theorem even_eq_not_odd : ∀ a, even a = not (odd a) := by
  intro a; induction a
  . simp [even, odd]
  . simp [even, odd, *]
</code></pre>
<p>这是一个互相定义的特点在于，<code>even</code>是在<code>odd</code>的基础上进行递归定义，而<code>odd</code>又是在<code>even</code>的基础上进行递归定义。在底层，这被编译为一个单一的递归定义。内部定义的函数接受一个和类型的元素作为参数，可以是<code>even</code>的输入，也可以是<code>odd</code>的输入。然后返回与输入相适应的输出。为了定义这个函数，Lean使用了一个合适的良序测度。内部细节应该对用户隐藏起来；使用这样的定义的正统方式是使用<code>simp</code>（或者<code>unfold</code>），就像我们之前所做的那样。</p>
<p>互相递归定义也提供了处理互相嵌套归纳类型的自然方式。回想一下之前介绍的<code>Even</code>和<code>Odd</code>作为互相归纳谓词的定义。</p>
<pre><code class="language-lean">mutual
  inductive Even : Nat → Prop where
    | even_zero : Even 0
    | even_succ : ∀ n, Odd n → Even (n + 1)

  inductive Odd : Nat → Prop where
    | odd_succ : ∀ n, Even n → Odd (n + 1)
end
</code></pre>
<p>构造函数 <code>even_zero</code>、<code>even_succ</code> 和 <code>odd_succ</code> 提供了判断一个数是偶数还是奇数的正面手段。为了知道零不是奇数，并且后两个蕴含式是相反的，我们需要使用归纳类型是由这些构造函数生成的这个事实。通常情况下，构造函数被保存在一个以定义类型命名的命名空间中，<code>open Even Odd</code> 命令允许我们更方便地访问它们。</p>
<pre><code class="language-lean"># mutual
#  inductive Even : Nat → Prop where
#    | even_zero : Even 0
#    | even_succ : ∀ n, Odd n → Even (n + 1)
#  inductive Odd : Nat → Prop where
#    | odd_succ : ∀ n, Even n → Odd (n + 1)
# end
open Even Odd

theorem not_odd_zero : ¬ Odd 0 :=
  fun h =&gt; nomatch h

theorem even_of_odd_succ : ∀ n, Odd (n + 1) → Even n
  | _, odd_succ n h =&gt; h

theorem odd_of_even_succ : ∀ n, Even (n + 1) → Odd n
  | _, even_succ n h =&gt; h
</code></pre>
<p>再举一个例子，假设我们使用嵌套的归纳类型来递归地定义一组术语。在这个定义中，一个术语要么是一个常量（由一个字符串表示的名称），要么是将一个常量应用于一组常量的结果。</p>
<pre><code class="language-lean">inductive Term where
  | const : String → Term
  | app   : String → List Term → Term
</code></pre>
<p>然后我们可以使用互递归定义来统计项中出现的常数数量，以及项列表中出现的常数数量。</p>
<pre><code class="language-lean"># inductive Term where
#  | const : String → Term
#  | app   : String → List Term → Term
namespace Term

mutual
  def numConsts : Term → Nat
    | const _ =&gt; 1
    | app _ cs =&gt; numConstsLst cs

  def numConstsLst : List Term → Nat
    | [] =&gt; 0
    | c :: cs =&gt; numConsts c + numConstsLst cs
end

def sample := app &quot;f&quot; [app &quot;g&quot; [const &quot;x&quot;], const &quot;y&quot;]

#eval numConsts sample

end Term
</code></pre>
<p>作为最后一个例子，我们定义一个函数<code>replaceConst a b e</code>，它在表达式<code>e</code>中将常量<code>a</code>替换为<code>b</code>，然后证明常量的数量保持不变。注意，我们的证明使用了互递归（也称为归纳法）。</p>
<pre><code class="language-lean">theorem replace_const_preserves_no_consts : ∀ a b : expr, ∀ e : expr, no_consts (replace_const a b e) = no_consts e :=
begin
  /- proof by mutual recursion -/

  -- base case: `e` is a variable
  intros a b e,
  cases e,
  simp [replace_const],

  -- inductive case 1: `e` is `const a`
  intros a b e,
  cases e,
  simp [replace_const, no_consts],

  -- inductive case 2: `e` is `app e₁ e₂`
  intros a b e,
  cases e,
  simp [replace_const, no_consts],
  rw [replace_const_preserves_no_consts, replace_const_preserves_no_consts],
end
</code></pre>
<p>这个定理证明了在一个表达式<code>e</code>中，用常量<code>a</code>替换为<code>b</code>后，常量的数量保持不变。证明使用了互递归的方法，通过分析表达式<code>e</code>的各种情况来进行证明。最后的两个归纳步骤使用了递归调用来证明替换后常量的数量仍然保持不变。</p>
<pre><code class="language-lean"># inductive Term where
#  | const : String → Term
#  | app   : String → List Term → Term
# namespace Term
# mutual
#  def numConsts : Term → Nat
#    | const _ =&gt; 1
#    | app _ cs =&gt; numConstsLst cs
#   def numConstsLst : List Term → Nat
#    | [] =&gt; 0
#    | c :: cs =&gt; numConsts c + numConstsLst cs
# end
mutual
  def replaceConst (a b : String) : Term → Term
    | const c =&gt; if a == c then const b else const c
    | app f cs =&gt; app f (replaceConstLst a b cs)

  def replaceConstLst (a b : String) : List Term → List Term
    | [] =&gt; []
    | c :: cs =&gt; replaceConst a b c :: replaceConstLst a b cs
end

mutual
  theorem numConsts_replaceConst (a b : String) (e : Term)
            : numConsts (replaceConst a b e) = numConsts e := by
    match e with
    | const c =&gt; simp [replaceConst]; split &lt;;&gt; simp [numConsts]
    | app f cs =&gt; simp [replaceConst, numConsts, numConsts_replaceConstLst a b cs]

  theorem numConsts_replaceConstLst (a b : String) (es : List Term)
            : numConstsLst (replaceConstLst a b es) = numConstsLst es := by
    match es with
    | [] =&gt; simp [replaceConstLst, numConstsLst]
    | c :: cs =&gt;
      simp [replaceConstLst, numConstsLst, numConsts_replaceConst a b c,
            numConsts_replaceConstLst a b cs]
end
</code></pre>
<h2 id="依赖模式匹配"><a class="header" href="#依赖模式匹配">依赖模式匹配</a></h2>
<p>我们在 <a href="induction_and_recursion.html#pattern-matching">模式匹配章节</a> 中讨论的所有模式匹配例子都可以很容易地使用 <code>cases_on</code> 和 <code>rec_on</code> 写出来。但是，对于索引的归纳族，比如 <code>Vector α n</code>，情况通常并非如此，因为情况分割之后对索引的值施加了一些约束。如果没有等式编译器，我们将需要大量样板代码来用递归函数定义非常简单的函数，比如 <code>map</code>，<code>zip</code> 和 <code>unzip</code>。为了理解其中的困难，考虑一下定义一个函数 <code>tail</code>，它取一个向量 <code>v : Vector α (succ n)</code> 并删除第一个元素。最初的想法可能是使用 <code>casesOn</code> 函数：</p>
<pre><code class="language-lean">inductive Vector (α : Type u) : Nat → Type u
  | nil  : Vector α 0
  | cons : α → {n : Nat} → Vector α n → Vector α (n+1)

namespace Vector

#check @Vector.casesOn
/-
  {α : Type u}
  → {motive : (a : Nat) → Vector α a → Sort v} →
  → {a : Nat} → (t : Vector α a)
  → motive 0 nil
  → ((a : α) → {n : Nat} → (a_1 : Vector α n) → motive (n + 1) (cons a a_1))
  → motive a t
-/

end Vector
</code></pre>
<p>但是在“nil”情况下应该返回什么值呢？有一件有趣的事情发生了：如果 <code>v</code> 的类型是 <code>Vector α (succ n)</code>，它<em>不可能</em>是空的，但是如何告诉 <code>casesOn</code> 这一点并不清楚。</p>
<p>一种解决方法是定义一个辅助函数：</p>
<pre><code class="language-lean"># inductive Vector (α : Type u) : Nat → Type u
#   | nil  : Vector α 0
#   | cons : α → {n : Nat} → Vector α n → Vector α (n+1)
# namespace Vector
def tailAux (v : Vector α m) : m = n + 1 → Vector α n :=
  Vector.casesOn (motive := fun x _ =&gt; x = n + 1 → Vector α n) v
    (fun h : 0 = n + 1 =&gt; Nat.noConfusion h)
    (fun (a : α) (m : Nat) (as : Vector α m) =&gt;
     fun (h : m + 1 = n + 1) =&gt;
       Nat.noConfusion h (fun h1 : m = n =&gt; h1 ▸ as))

def tail (v : Vector α (n+1)) : Vector α n :=
  tailAux v rfl
# end Vector
</code></pre>
<p>在 <code>nil</code> 的情况下，<code>m</code> 被实例化为 <code>0</code>，<code>noConfusion</code> 利用了 <code>0 = succ n</code> 不能出现的事实。否则，<code>v</code> 的形式是 <code>a :: w</code>，我们可以将它从长度为 <code>m</code> 的向量转换为长度为 <code>n</code> 的向量后简单地返回 <code>w</code>。</p>
<p>定义 <code>tail</code> 的难点在于保持索引之间的关系。<code>tailAux</code> 中的假设 <code>e : m = n + 1</code> 被用来传递 <code>n</code> 和与次前提相关联的索引之间的关系。此外，<code>zero = n + 1</code> 的情况是不可到达的，而丢弃这样的情况的规范方式是使用 <code>noConfusion</code>。</p>
<p>然而，使用递归方程很容易定义 <code>tail</code> 函数，方程编译器会自动生成所有样板代码。以下是一些类似的例子：</p>
<pre><code class="language-lean"># inductive Vector (α : Type u) : Nat → Type u
#   | nil  : Vector α 0
#   | cons : α → {n : Nat} → Vector α n → Vector α (n+1)
# namespace Vector
def head : {n : Nat} → Vector α (n+1) → α
  | n, cons a as =&gt; a

def tail : {n : Nat} → Vector α (n+1) → Vector α n
  | n, cons a as =&gt; as

theorem eta : ∀ {n : Nat} (v : Vector α (n+1)), cons (head v) (tail v) = v
  | n, cons a as =&gt; rfl

def map (f : α → β → γ) : {n : Nat} → Vector α n → Vector β n → Vector γ n
  | 0,   nil,       nil       =&gt; nil
  | n+1, cons a as, cons b bs =&gt; cons (f a b) (map f as bs)

def zip : {n : Nat} → Vector α n → Vector β n → Vector (α × β) n
  | 0,   nil,       nil       =&gt; nil
  | n+1, cons a as, cons b bs =&gt; cons (a, b) (zip as bs)
# end Vector
</code></pre>
<p>请注意，我们可以省略“无法到达（unreachable）”情况下的递归方程，例如 <code>head nil</code>。对于索引族的自动生成定义远非简单。例如：</p>
<pre><code class="language-lean"># inductive Vector (α : Type u) : Nat → Type u
#   | nil  : Vector α 0
#   | cons : α → {n : Nat} → Vector α n → Vector α (n+1)
# namespace Vector
def map (f : α → β → γ) : {n : Nat} → Vector α n → Vector β n → Vector γ n
  | 0,   nil,       nil       =&gt; nil
  | n+1, cons a as, cons b bs =&gt; cons (f a b) (map f as bs)

#print map
#print map.match_1
# end Vector
</code></pre>
<p>用手动定义<code>map</code>函数比定义<code>tail</code>函数更烦琐。我们鼓励你使用<code>recOn</code>、<code>casesOn</code>和<code>noConfusion</code>来尝试定义它。</p>
<h2 id="不可访问的模式"><a class="header" href="#不可访问的模式">不可访问的模式</a></h2>
<p>有时，一个依赖匹配模式中的参数在定义中并不重要，但是仍然必须包含它以适当地特化表达式的类型。Lean允许用户将这种子项标记为对模式匹配不可访问的。这些注释在左侧出现的项既不是变量也不是构造应用的情况下是必不可少的，因为它们不能作为模式匹配的目标。我们可以将这样的不可访问模式视为模式的“不关心”组成部分。你可以通过写<code>.(t)</code>来声明一个子项不可访问。如果可以推断出不可访问模式，你也可以写<code>_</code>。</p>
<p>在下面的示例中，我们声明了一个归纳类型，它定义了“在<code>f</code>的图像中”的属性。你可以将类型<code>ImageOf f b</code>的元素视为<code>b</code>在<code>f</code>的图像中的证据，其中构造函数<code>imf</code>用于构建这样的证据。然后，我们可以定义任何具有“反函数”的函数<code>f</code>，该函数接受<code>f</code>的图像中的任何元素，并将其映射到它所映射的元素。类型规则强制我们为第一个参数写<code>f a</code>，但是这个表达式既不是变量也不是构造应用，并且在模式匹配定义中不起任何作用。为了定义下面的函数<code>inverse</code>，我们<em>必须</em>将<code>f a</code>标记为不可访问的。</p>
<pre><code class="language-lean">inductive ImageOf {α β : Type u} (f : α → β) : β → Type u where
  | imf : (a : α) → ImageOf f (f a)

open ImageOf

def inverse {f : α → β} : (b : β) → ImageOf f b → α
  | .(f a), imf a =&gt; a

def inverse' {f : α → β} : (b : β) → ImageOf f b → α
  | _, imf a =&gt; a
</code></pre>
<p>在上面的例子中，不可访问的注解明确表示<code>f</code>不是一个模式匹配变量。</p>
<p>不可访问的模式可以用于澄清和控制使用依赖模式匹配的定义。考虑下面的函数<code>Vector.add</code>的定义，该函数用于将两个元素类型为类型的向量相加，假设该类型有一个相关的加法函数：</p>
<pre><code class="language-lean">inductive Vector (α : Type u) : Nat → Type u
  | nil  : Vector α 0
  | cons : α → {n : Nat} → Vector α n → Vector α (n+1)

namespace Vector

def add [Add α] : {n : Nat} → Vector α n → Vector α n → Vector α n
  | 0,   nil,       nil       =&gt; nil
  | n+1, cons a as, cons b bs =&gt; cons (a + b) (add as bs)

end Vector
</code></pre>
<p>在冒号之后出现的 <code>{n : Nat}</code> 是因为它不能在整个定义过程中保持不变。在实现这个定义时，方程编译器会首先根据第一个参数是 <code>0</code> 还是 <code>n+1</code> 进行情况区分。然后会在下面的两个参数上进行嵌套的情况分割，在每种情况下，方程编译器会排除与第一个模式不兼容的情况。</p>
<p>然而，事实上，我们并不需要在第一个参数上进行情况分割；<code>Vector</code> 的 <code>casesOn</code> 消除器会自动抽象该参数并在对第二个参数进行情况分割时用 <code>0</code> 和 <code>n+1</code> 替换它。使用不可访问模式，我们可以提示方程编译器避免在 <code>n</code> 上进行情况分割。</p>
<pre><code class="language-lean"># inductive Vector (α : Type u) : Nat → Type u
#   | nil  : Vector α 0
#   | cons : α → {n : Nat} → Vector α n → Vector α (n+1)
# namespace Vector
def add [Add α] : {n : Nat} → Vector α n → Vector α n → Vector α n
  | .(_), nil,       nil       =&gt; nil
  | .(_), cons a as, cons b bs =&gt; cons (a + b) (add as bs)
# end Vector
</code></pre>
<p>将位置标记为不可访问模式告诉等式编译器第一，要从其他参数的约束来推断该参数的形式，第二，第一个参数不应参与模式匹配。</p>
<p>不可访问模式 <code>.(_)</code> 可以简写为 <code>_</code>。</p>
<pre><code class="language-lean"># inductive Vector (α : Type u) : Nat → Type u
#   | nil  : Vector α 0
#   | cons : α → {n : Nat} → Vector α n → Vector α (n+1)
# namespace Vector
def add [Add α] : {n : Nat} → Vector α n → Vector α n → Vector α n
  | _, nil,       nil       =&gt; nil
  | _, cons a as, cons b bs =&gt; cons (a + b) (add as bs)
# end Vector
</code></pre>
<p>正如我们上面提到的，参数 <code>{n : Nat}</code> 是模式匹配的一部分，因为它不能在整个定义过程中保持固定。在以前的 Lean 版本中，用户经常发现必须包含这些额外的判别式很麻烦。因此，Lean 4 实现了一个新特性，<em>判别式的细化</em>，它会自动为我们包含这些额外的判别式。</p>
<pre><code class="language-lean"># inductive Vector (α : Type u) : Nat → Type u
#   | nil  : Vector α 0
#   | cons : α → {n : Nat} → Vector α n → Vector α (n+1)
# namespace Vector
def add [Add α] {n : Nat} : Vector α n → Vector α n → Vector α n
  | nil,       nil       =&gt; nil
  | cons a as, cons b bs =&gt; cons (a + b) (add as bs)
# end Vector
</code></pre>
<p>当与 <em>auto bound implicits</em> 功能结合使用时，您可以进一步简化声明并写入：</p>
<pre><code class="language-lean"># inductive Vector (α : Type u) : Nat → Type u
#   | nil  : Vector α 0
#   | cons : α → {n : Nat} → Vector α n → Vector α (n+1)
# namespace Vector
def add [Add α] : Vector α n → Vector α n → Vector α n
  | nil,       nil       =&gt; nil
  | cons a as, cons b bs =&gt; cons (a + b) (add as bs)
# end Vector
</code></pre>
<p>使用这些新特性，您可以更紧凑地编写之前部分中定义的其他向量函数，如下所示：</p>
<pre><code class="language-lean"># inductive Vector (α : Type u) : Nat → Type u
#   | nil  : Vector α 0
#   | cons : α → {n : Nat} → Vector α n → Vector α (n+1)
# namespace Vector
def head : Vector α (n+1) → α
  | cons a as =&gt; a

def tail : Vector α (n+1) → Vector α n
  | cons a as =&gt; as

theorem eta : (v : Vector α (n+1)) → cons (head v) (tail v) = v
  | cons a as =&gt; rfl

def map (f : α → β → γ) : Vector α n → Vector β n → Vector γ n
  | nil,       nil       =&gt; nil
  | cons a as, cons b bs =&gt; cons (f a b) (map f as bs)

def zip : Vector α n → Vector β n → Vector (α × β) n
  | nil,       nil       =&gt; nil
  | cons a as, cons b bs =&gt; cons (a, b) (zip as bs)
# end Vector
</code></pre>
<h2 id="匹配表达式"><a class="header" href="#匹配表达式">匹配表达式</a></h2>
<p>LEAN 还提供了一个编译器，用于处理许多函数式语言中的 <em>match-with</em> 表达式。</p>
<pre><code class="language-lean">def isNotZero (m : Nat) : Bool :=
  match m with
  | 0   =&gt; false
  | n+1 =&gt; true
</code></pre>
<p>这看起来与普通的模式匹配定义并没有太大的区别，但关键点在于<code>match</code>语法可以在表达式的任何位置使用，并且可以接受任意参数。</p>
<pre><code class="language-lean">def isNotZero (m : Nat) : Bool :=
  match m with
  | 0   =&gt; false
  | n+1 =&gt; true

def filter (p : α → Bool) : List α → List α
  | []      =&gt; []
  | a :: as =&gt;
    match p a with
    | true =&gt; a :: filter p as
    | false =&gt; filter p as

example : filter isNotZero [1, 0, 0, 3, 0] = [1, 3] := rfl
</code></pre>
<p>下面是另一个例子：</p>
<pre><code class="language-lean">def foo (n : Nat) (b c : Bool) :=
  5 + match n - 5, b &amp;&amp; c with
      | 0,   true  =&gt; 0
      | m+1, true  =&gt; m + 7
      | 0,   false =&gt; 5
      | m+1, false =&gt; m + 3

#eval foo 7 true false

example : foo 7 true false = 9 := rfl
</code></pre>
<p>Lean 在系统的所有部分内部使用 <code>match \ldots with</code> 结构来实现模式匹配。因此，这四个定义具有相同的最终效果。</p>
<pre><code class="language-lean">def bar₁ : Nat × Nat → Nat
  | (m, n) =&gt; m + n

def bar₂ (p : Nat × Nat) : Nat :=
  match p with
  | (m, n) =&gt; m + n

def bar₃ : Nat × Nat → Nat :=
  fun (m, n) =&gt; m + n

def bar₄ (p : Nat × Nat) : Nat :=
  let (m, n) := p; m + n
</code></pre>
<p>这些变体同样适用于解读命题：</p>
<pre><code class="language-lean">variable (p q : Nat → Prop)

example : (∃ x, p x) → (∃ y, q y) → ∃ x y, p x ∧ q y
  | ⟨x, px⟩, ⟨y, qy⟩ =&gt; ⟨x, y, px, qy⟩

example (h₀ : ∃ x, p x) (h₁ : ∃ y, q y)
        : ∃ x y, p x ∧ q y :=
  match h₀, h₁ with
  | ⟨x, px⟩, ⟨y, qy⟩ =&gt; ⟨x, y, px, qy⟩

example : (∃ x, p x) → (∃ y, q y) → ∃ x y, p x ∧ q y :=
  fun ⟨x, px⟩ ⟨y, qy⟩ =&gt; ⟨x, y, px, qy⟩

example (h₀ : ∃ x, p x) (h₁ : ∃ y, q y)
        : ∃ x y, p x ∧ q y :=
  let ⟨x, px⟩ := h₀
  let ⟨y, qy⟩ := h₁
  ⟨x, y, px, qy⟩
</code></pre>
<p>使用 <code>let rec</code> 关键字可以定义局部递归声明。</p>
<pre><code class="language-ocaml">let rec factorial n =
  if n &lt;= 1 then
    1
  else
    n * factorial (n - 1)
</code></pre>
<p>在上面的示例中，<code>factorial</code> 函数是一个局部递归函数。它以一个整数 <code>n</code> 作为参数，并返回 <code>n</code> 的阶乘。函数内部首先检查 <code>n</code> 是否小于等于 1，如果是，则返回 1。否则，它递归地调用自身，并将 <code>n</code> 减去 1 作为参数。递归调用的结果与 <code>n</code> 相乘，得到最终的阶乘结果。</p>
<pre><code class="language-lean">def replicate (n : Nat) (a : α) : List α :=
  let rec loop : Nat → List α → List α
    | 0,   as =&gt; as
    | n+1, as =&gt; loop n (a::as)
  loop n []

#check @replicate.loop
-- {α : Type} → α → Nat → List α → List α
</code></pre>
<p>Lean为每个<code>let rec</code>创建了一个辅助声明。在上面的例子中，它为出现在<code>replicate</code>的<code>let rec loop</code>创建了声明<code>replicate.loop</code>。注意，Lean通过将出现在<code>let rec</code>声明中的任何局部变量添加为额外的参数来&quot;关闭&quot;声明。例如，局部变量<code>a</code>出现在<code>let rec loop</code>中。</p>
<p>在策略模式下，您也可以使用<code>let rec</code>来创建归纳证明。</p>
<pre><code class="language-lean"># def replicate (n : Nat) (a : α) : List α :=
#  let rec loop : Nat → List α → List α
#    | 0,   as =&gt; as
#    | n+1, as =&gt; loop n (a::as)
#  loop n []
theorem length_replicate (n : Nat) (a : α) : (replicate n a).length = n := by
  let rec aux (n : Nat) (as : List α)
              : (replicate.loop a n as).length = n + as.length := by
    match n with
    | 0   =&gt; simp [replicate.loop]
    | n+1 =&gt; simp [replicate.loop, aux n, Nat.add_succ, Nat.succ_add]
  exact aux n []
</code></pre>
<p>你还可以在定义后使用 <code>where</code> 子句引入辅助递归声明，Lean 会将其转换为 <code>let rec</code>。</p>
<pre><code class="language-lean">def replicate (n : Nat) (a : α) : List α :=
  loop n []
where
  loop : Nat → List α → List α
    | 0,   as =&gt; as
    | n+1, as =&gt; loop n (a::as)

theorem length_replicate (n : Nat) (a : α) : (replicate n a).length = n := by
  exact aux n []
where
  aux (n : Nat) (as : List α)
      : (replicate.loop a n as).length = n + as.length := by
    match n with
    | 0   =&gt; simp [replicate.loop]
    | n+1 =&gt; simp [replicate.loop, aux n, Nat.add_succ, Nat.succ_add]
</code></pre>
<h2 id="练习-3"><a class="header" href="#练习-3">练习</a></h2>
<ol>
<li>
<p>打开命名空间<code>Hidden</code>以避免命名冲突，并使用等式编译器定义自然数上的加法、乘法和指数运算。然后使用等式编译器推导出它们的一些基本属性。</p>
</li>
<li>
<p>类似地，使用等式编译器定义列表的一些基本操作（如<code>reverse</code>函数），并通过归纳证明关于列表的定理（例如对于任意列表<code>xs</code>，有<code>reverse (reverse xs) = xs</code>）。</p>
</li>
<li>
<p>定义自己的函数来对自然数进行值域递归。类似地，看看自己能否弄清楚如何定义<code>WellFounded.fix</code>。</p>
</li>
<li>
<p>按照<a href="induction_and_recursion.html#dependent-pattern-matching">依赖模式匹配章节</a>中的示例，定义一个函数来追加两个向量。这有点棘手，你将不得不定义一个辅助函数。</p>
</li>
<li>
<p>考虑以下类型的算术表达式。理念是<code>var n</code>是一个变量<code>vₙ</code>，<code>const n</code>是值为<code>n</code>的常量。</p>
</li>
</ol>
<pre><code class="language-lean">inductive Expr where
  | const : Nat → Expr
  | var : Nat → Expr
  | plus : Expr → Expr → Expr
  | times : Expr → Expr → Expr
  deriving Repr

open Expr

def sampleExpr : Expr :=
  plus (times (var 0) (const 7)) (times (const 2) (var 1))
</code></pre>
<p>在这里，“sampleExpr”代表“(v₀ * 7) + (2 * v₁)”。</p>
<p>编写一个函数来求解这样的表达式，将每个“var n”求值为“v n”。</p>
<pre><code class="language-lean"># inductive Expr where
#   | const : Nat → Expr
#   | var : Nat → Expr
#   | plus : Expr → Expr → Expr
#   | times : Expr → Expr → Expr
#   deriving Repr
# open Expr
# def sampleExpr : Expr :=
#   plus (times (var 0) (const 7)) (times (const 2) (var 1))
def eval (v : Nat → Nat) : Expr → Nat
  | const n     =&gt; sorry
  | var n       =&gt; v n
  | plus e₁ e₂  =&gt; sorry
  | times e₁ e₂ =&gt; sorry

def sampleVal : Nat → Nat
  | 0 =&gt; 5
  | 1 =&gt; 6
  | _ =&gt; 0

-- Try it out. You should get 47 here.
-- #eval eval sampleVal sampleExpr
</code></pre>
<p>实现&quot;常数融合&quot;（constant fusion）的过程，该过程将简化如 <code>5 + 7</code> 这样的子项为 <code>12</code>。使用辅助函数 <code>simpConst</code>，定义一个名为 &quot;fuse&quot; 的函数：对于加法或乘法表达式，先递归地简化参数，然后应用 <code>simpConst</code> 尝试简化结果。</p>
<pre><code class="language-lean">-- 定义常数融合辅助函数 simpConst
def simpConst : expr → option ℕ
| `(nat.zero) := some 0
| `(nat.succ %%n) := some $ 1 + simpConst n
| _ := none

-- 定义常数融合函数 fuse
def fuse : expr → option expr
| `(%%x + %%y) := match (fuse x, fuse y) with
                  | (some x', some y') := match simpConst `(%%x' + %%y') with
                                         | some c := some `(nat.num %%c)
                                         | none := some `(%%x' + %%y')
                                         end
                  | _ := none
                  end
| `(%%x * %%y) := match (fuse x, fuse y) with
                  | (some x', some y') := match simpConst `(%%x' * %%y') with
                                         | some c := some `(nat.num %%c)
                                         | none := some `(%%x' * %%y')
                                         end
                  | _ := none
                  end
| _ := none
</code></pre>
<p>此代码是基于 Lean 证明助手编写的，用于对简单的加法和乘法表达式进行常数融合。首先，我们定义了一个辅助函数 <code>simpConst</code>，通过模式匹配来简化给定的表达式。它会尝试将表达式转换为数字常量（即 <code>nat.num</code>）。</p>
<p>然后，我们定义了一个函数 <code>fuse</code>，它使用模式匹配来搜索加法和乘法表达式，并递归地简化它们的参数。然后，它应用 <code>simpConst</code> 辅助函数来尝试简化结果。如果结果是一个数字常量，那么它将返回相应的 <code>nat.num</code> 表达式。否则，它会返回简化的加法或乘法表达式。</p>
<p>请注意，这只是一个简单的示例，实际应用中的常数融合可能更复杂，并可能需要更复杂的处理逻辑。我们只是展示了一种基本的实现方式。</p>
<pre><code class="language-lean"># inductive Expr where
#   | const : Nat → Expr
#   | var : Nat → Expr
#   | plus : Expr → Expr → Expr
#   | times : Expr → Expr → Expr
#   deriving Repr
# open Expr
# def eval (v : Nat → Nat) : Expr → Nat
#   | const n     =&gt; sorry
#   | var n       =&gt; v n
#   | plus e₁ e₂  =&gt; sorry
#   | times e₁ e₂ =&gt; sorry
def simpConst : Expr → Expr
  | plus (const n₁) (const n₂)  =&gt; const (n₁ + n₂)
  | times (const n₁) (const n₂) =&gt; const (n₁ * n₂)
  | e                           =&gt; e

def fuse : Expr → Expr := sorry

theorem simpConst_eq (v : Nat → Nat)
        : ∀ e : Expr, eval v (simpConst e) = eval v e :=
  sorry

theorem fuse_eq (v : Nat → Nat)
        : ∀ e : Expr, eval v (fuse e) = eval v e :=
  sorry
</code></pre>
<p>最后两个定理证明了这些定义保持值的不变。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="结构和记录"><a class="header" href="#结构和记录">结构和记录</a></h1>
<p>我们已经看到 Lean 的基础系统包括归纳类型。此外，我们还注意到一个引人注目的事实是，仅仅基于类型宇宙、依赖箭头类型和归纳类型就可以构建一个重要的数学建筑；其他一切都可以从这些基础出发推导出来。Lean 标准库包含许多归纳类型的实例（例如 <code>Nat</code>、<code>Prod</code>、<code>List</code>），甚至连逻辑连词也是使用归纳类型定义的。</p>
<p>回想一下，一个只包含一个构造器的非递归归纳类型被称为<em>结构</em>或<em>记录</em>。乘积类型是一个结构，依赖乘积（Sigma）类型也是一个结构。一般来说，当我们定义一个结构 <code>S</code> 时，我们通常会定义<em>投影</em>函数，以允许我们“解构”每个 <code>S</code> 的实例并检索存储在其字段中的值。函数 <code>prod.fst</code> 和 <code>prod.snd</code> 返回对的第一个和第二个元素，就是这样的投影函数的例子。</p>
<p>在编写程序或形式化数学时，定义包含许多字段的结构是很常见的。在 Lean 中可以使用 <code>structure</code> 命令提供的基础设施来支持这个过程。当我们使用这个命令定义一个结构时，Lean 会自动生成所有的投影函数。<code>structure</code> 命令还允许我们基于先前定义的结构定义新的结构。此外，Lean 还提供了方便的符号来定义给定结构的实例。</p>
<h2 id="声明结构"><a class="header" href="#声明结构">声明结构</a></h2>
<p><code>structure</code> 命令本质上是定义归纳数据类型的&quot;前端&quot;。每个 <code>structure</code> 声明都引入了一个同名的命名空间。一般形式如下：</p>
<pre><code>    structure &lt;name&gt; &lt;parameters&gt; &lt;parent-structures&gt; where
      &lt;constructor&gt; :: &lt;fields&gt;
</code></pre>
<p>大多数部分是可选的。以下是一个例子：</p>
<pre><code class="language-lean">structure Point (α : Type u) where
  mk :: (x : α) (y : α)
</code></pre>
<p>类型 <code>Point</code> 的值是通过使用 <code>Point.mk a b</code> 创建的，可以使用 <code>Point.x p</code> 和 <code>Point.y p</code> 来访问点 <code>p</code> 的字段（但 <code>p.x</code> 和 <code>p.y</code> 也有效，详情见下文）。结构命令还会生成有用的递归器和定理。以下是对上面声明生成的一些构造。</p>
<pre><code class="language-lean"># structure Point (α : Type u) where
#  mk :: (x : α) (y : α)
#check Point       -- a Type
#check @Point.rec  -- the eliminator
#check @Point.mk   -- the constructor
#check @Point.x    -- a projection
#check @Point.y    -- a projection
</code></pre>
<p>如果没有提供构造函数的名称，则默认名称为 <code>mk</code>。如果在每个字段之间添加换行符，则还可以避免在字段名称周围使用括号。</p>
<pre><code class="language-lean">structure Point (α : Type u) where
  x : α
  y : α
</code></pre>
<p>下面是一些使用生成的构造的简单定理和表达式。如同往常，您可以使用命令“open Point”来避免使用前缀“Point”。</p>
<pre><code class="language-lean"># structure Point (α : Type u) where
#  x : α
#  y : α
#eval Point.x (Point.mk 10 20)
#eval Point.y (Point.mk 10 20)

open Point

example (a b : α) : x (mk a b) = a :=
  rfl

example (a b : α) : y (mk a b) = b :=
  rfl
</code></pre>
<p>给定<code>p : Point Nat</code>，点符号表示<code>p.x</code>是<code>Point.x p</code>的缩写。这提供了一种方便的方法来访问结构体的字段。</p>
<pre><code class="language-lean"># structure Point (α : Type u) where
#  x : α
#  y : α
def p := Point.mk 10 20

#check p.x  -- Nat
#eval p.x   -- 10
#eval p.y   -- 20
</code></pre>
<p>点符号表示法不仅方便访问记录的投影，还方便应用与同名命名空间中定义的函数。回想一下，在<a href="./propositions_and_proofs.html#conjunction">连接词</a>部分中，如果 <code>p</code> 的类型是 <code>Point</code>，那么表达式 <code>p.foo</code> 的解释是 <code>Point.foo p</code>，假设 <code>foo</code> 的第一个非隐式参数的类型是 <code>Point</code>。因此，在下面的示例中，表达式 <code>p.add q</code> 是 <code>Point.add p q</code> 的简写形式。</p>
<pre><code class="language-lean">structure Point (α : Type u) where
  x : α
  y : α
  deriving Repr

def Point.add (p q : Point Nat) :=
  mk (p.x + q.x) (p.y + q.y)

def p : Point Nat := Point.mk 1 2
def q : Point Nat := Point.mk 3 4

#eval p.add q  -- {x := 4, y := 6}
</code></pre>
<p>在下一章中，你将学习如何定义一个像 <code>add</code> 这样的函数，使它可以适用于 <code>Point α</code> 的元素，而不仅仅是 <code>Point Nat</code>，前提是 <code>α</code> 有一个关联的加法操作。</p>
<p>更一般地，给定表达式 <code>p.foo x y z</code>，其中 <code>p : Point</code>，Lean会将 <code>p</code> 插入到类型为 <code>Point</code> 的 <code>Point.foo</code> 的第一个参数位置。例如，对于下面的标量乘法定义，<code>p.smul 3</code> 被解释为 <code>Point.smul 3 p</code>。</p>
<pre><code class="language-lean"># structure Point (α : Type u) where
#  x : α
#  y : α
#  deriving Repr
def Point.smul (n : Nat) (p : Point Nat) :=
  Point.mk (n * p.x) (n * p.y)

def p : Point Nat := Point.mk 1 2

#eval p.smul 3  -- {x := 3, y := 6}
</code></pre>
<p>通常可以使用类似的技巧来处理 <code>List.map</code> 函数，它将列表作为其第二个非隐式参数传入：</p>
<pre><code class="language-lean">#check @List.map

def xs : List Nat := [1, 2, 3]
def f : Nat → Nat := fun x =&gt; x * x

#eval xs.map f  -- [1, 4, 9]
</code></pre>
<p><strong>对象</strong></p>
<p>我们一直在使用构造函数来创建结构类型的元素。对于包含多个字段的结构体来说，这种方式通常很不方便，因为我们必须记住字段定义的顺序。因此，Lean提供了以下用于定义结构类型元素的替代符号表示法。</p>
<pre><code>    { (&lt;field-name&gt; := &lt;expr&gt;)* : structure-type }
    or
    { (&lt;field-name&gt; := &lt;expr&gt;)* }
</code></pre>
<p>当结构体的名称可以从预期的类型中推断出时，后缀 <code>: structure-type</code> 可以省略。例如，我们使用这种记法来定义“点”。字段的指定顺序不重要，所以下面的所有表达式都定义了相同的点。</p>
<hr />
<pre><code class="language-lisp">(define-struct point (x y))
</code></pre>
<p>这个定义创建了一个带有两个字段 <code>x</code> 和 <code>y</code> 的结构体。我们可以使用以下表达式来创建一个点：</p>
<pre><code class="language-lisp">(make-point 1 2)
</code></pre>
<p>这会创建一个 <code>x</code> 值为 1，<code>y</code> 值为 2 的点。这个点的类型是 <code>point</code>。</p>
<p>我们可以通过以下方式来访问点的字段：</p>
<pre><code class="language-lisp">(point-x (make-point 1 2)) ;; 返回 1
(point-y (make-point 1 2)) ;; 返回 2
</code></pre>
<p>使用辅助函数 <code>point-x</code> 和 <code>point-y</code> 可以返回一个点的 <code>x</code> 和 <code>y</code> 值。</p>
<p>注意，由于结构体的名称可以从预期的类型中推断出，所以我们可以省略结构体类型的后缀 <code>: point</code>。下面的代码与上面的代码等效：</p>
<pre><code class="language-lisp">(define-struct point (x y))
(define (make x y) (make-point x y))
(define (x p) (point-x p))
(define (y p) (point-y p))

(make 1 2) ;; 返回一个点
(x (make 1 2)) ;; 返回 1
(y (make 1 2)) ;; 返回 2
</code></pre>
<p>这种推断结构体名称的能力使得我们定义和使用结构体变得更加简洁和方便。</p>
<pre><code class="language-lean">structure Point (α : Type u) where
  x : α
  y : α

#check { x := 10, y := 20 : Point Nat }  -- Point ℕ
#check { y := 20, x := 10 : Point _ }
#check ({ x := 10, y := 20 } : Point Nat)

example : Point Nat :=
  { y := 20, x := 10 }
</code></pre>
<p>如果未指定字段的值，Lean 尝试推断它。如果无法推断未指定的字段，Lean 将发出错误提醒，指示无法合成相应的占位符。</p>
<pre><code class="language-lean">structure MyStruct where
    {α : Type u}
    {β : Type v}
    a : α
    b : β

#check { a := 10, b := true : MyStruct }
</code></pre>
<p><em>记录更新</em>是另一个常见操作，它通过修改旧记录对象中的一个或多个字段的值来创建一个新的记录对象。Lean允许您在记录的规范中指定未分配的字段应该从先前定义的结构对象<code>s</code>中获取，方法是在字段赋值之前添加注释<code>s with</code>。如果提供了多个记录对象，则会按顺序访问它们，直到找到一个包含未指定字段的对象。如果在访问所有对象之后仍然存在未指定的字段名，Lean将引发错误。</p>
<pre><code class="language-lean">structure Point (α : Type u) where
  x : α
  y : α
  deriving Repr

def p : Point Nat :=
  { x := 1, y := 2 }

#eval { p with y := 3 }  -- { x := 1, y := 3 }
#eval { p with x := 4 }  -- { x := 4, y := 2 }

structure Point3 (α : Type u) where
  x : α
  y : α
  z : α

def q : Point3 Nat :=
  { x := 5, y := 5, z := 5 }

def r : Point3 Nat :=
  { p, q with x := 6 }

example : r.x = 6 := rfl
example : r.y = 2 := rfl
example : r.z = 5 := rfl
</code></pre>
<h2 id="继承"><a class="header" href="#继承">继承</a></h2>
<p>我们可以通过添加新字段来扩展现有的结构。这个特性可以模拟一种继承的形式。</p>
<pre><code class="language-lean">structure Point (α : Type u) where
  x : α
  y : α

inductive Color where
  | red | green | blue

structure ColorPoint (α : Type u) extends Point α where
  c : Color
</code></pre>
<p>在下面的例子中，我们使用多重继承来定义一个结构，并使用父结构的对象来定义一个对象。</p>
<pre><code class="language-lean">structure Point (α : Type u) where
  x : α
  y : α
  z : α

structure RGBValue where
  red : Nat
  green : Nat
  blue : Nat

structure RedGreenPoint (α : Type u) extends Point α, RGBValue where
  no_blue : blue = 0

def p : Point Nat :=
  { x := 10, y := 10, z := 20 }

def rgp : RedGreenPoint Nat :=
  { p with red := 200, green := 40, blue := 0, no_blue := rfl }

example : rgp.x   = 10 := rfl
example : rgp.red = 200 := rfl
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="类型类"><a class="header" href="#类型类">类型类</a></h1>
<p>类型类被引入为函数式编程语言中实现特殊多态的一种有原则的方式。首先我们观察到，如果函数仅仅以类型特定的加法实现作为参数，然后在剩余的参数上调用该实现，实现一个特殊的多态函数（比如加法）将变得很容易。例如，假设我们在 Lean 中声明一个结构来保存加法的实现。</p>
<pre><code class="language-lean"># namespace Ex
structure Add (a : Type) where
  add : a → a → a

#check @Add.add
-- Add.add : {a : Type} → Add a → a → a → a
# end Ex
</code></pre>
<p>在上面的 Lean 代码中，<code>add</code> 字段的类型为 <code>Add.add : {a : Type} → Add a → a → a → a</code>，其中大括号表示 <code>a</code> 是一个隐含参数。
我们可以这样实现 <code>double</code> 函数：</p>
<pre><code class="language-lean"># namespace Ex
# structure Add (a : Type) where
#  add : a → a → a
def double (s : Add a) (x : a) : a :=
  s.add x x

#eval double { add := Nat.add } 10
-- 20

#eval double { add := Nat.mul } 10
-- 100

#eval double { add := Int.add } 10
-- 20
# end Ex
</code></pre>
<p>请注意，你可以通过 <code>double { add := Nat.add } n</code> 将一个自然数 <code>n</code> 乘以2。
当然，如果用户手动传递实现，将会非常麻烦。
实际上，这样做会削弱ad-hoc多态的潜在收益。</p>
<p>类型类的主要思想是将诸如 <code>Add a</code> 的参数隐藏起来，并使用用户定义的实例数据库通过一个称为类型类解析的过程自动合成所需的实例。
在 Lean 中，通过将上面示例中的 <code>structure</code> 改为 <code>class</code>，<code>Add.add</code> 的类型变为：</p>
<pre><code class="language-lean"># namespace Ex
class Add (a : Type) where
  add : a → a → a

#check @Add.add
-- Add.add : {a : Type} → [self : Add a] → a → a → a
# end Ex
</code></pre>
<p>其中方括号表示类型为 <code>Add a</code> 的参数是<em>隐式实例</em>，即应使用类型类解析来综合生成。这个版本的 <code>add</code> 是 Lean 中对应 Haskell 术语 <code>add :: Add a =&gt; a -&gt; a -&gt; a</code> 的模拟。类似地，我们可以通过下面的方式注册实例：</p>
<pre><code class="language-lean"># namespace Ex
# class Add (a : Type) where
#  add : a → a → a
instance : Add Nat where
  add := Nat.add

instance : Add Int where
  add := Int.add

instance : Add Float where
  add := Float.add
# end Ex
</code></pre>
<p>那么对于 <code>n : Nat</code> 和 <code>m : Nat</code>，术语 <code>Add.add n m</code> 触发类型类解析，目标是 <code>Add Nat</code>，并且类型类解析将合成上述 <code>Nat</code> 的实例。我们现在可以使用隐式实例来重新实现 <code>double</code>，方法是：</p>
<pre><code class="language-lean"># namespace Ex
# class Add (a : Type) where
#   add : a → a → a
# instance : Add Nat where
#  add := Nat.add
# instance : Add Int where
#  add := Int.add
# instance : Add Float where
#  add := Float.add
def double [Add a] (x : a) : a :=
  Add.add x x

#check @double
-- @double : {a : Type} → [inst : Add a] → a → a

#eval double 10
-- 20

#eval double (10 : Int)
-- 100

#eval double (7 : Float)
-- 14.000000

#eval double (239.0 + 2)
-- 482.000000

# end Ex
</code></pre>
<p>一般来说，实例之间可能以复杂的方式相互依赖。例如，您可以声明一个（匿名）实例，即如果 <code>a</code> 具有加法，则 <code>Array a</code> 具有加法功能：</p>
<pre><code class="language-lean">instance [Add a] : Add (Array a) where
  add x y := Array.zipWith x y (· + ·)

#eval Add.add #[1, 2] #[3, 4]
-- #[4, 6]

#eval #[1, 2] + #[3, 4]
-- #[4, 6]
</code></pre>
<p>注意，在 Lean 中 <code>(· + ·)</code> 是 <code>fun x y =&gt; x + y</code> 的一种表示方式。</p>
<p>上面的示例展示了如何使用类型类进行记法的重载。
现在，我们来探讨另一个应用场景。我们经常需要一个给定类型的任意元素。
在 Lean 中，类型可能没有任何元素。
通常情况下，我们希望在某些“边角情况”下，定义能够返回一个任意元素。
例如，当 <code>xs</code> 的类型是 <code>List a</code> 时，我们希望表达式 <code>head xs</code> 的类型为 <code>a</code>。
类似地，许多定理在额外假设类型非空的情况下成立。
例如，如果 <code>a</code> 是一个类型，那么 <code>exists x : a, x = x</code> 只有在 <code>a</code> 非空时才为真。
标准库定义了一个类型类 <code>Inhabited</code>，使得类型类推断能够推断出一个非空类型的“默认”元素。
让我们从上面程序的第一步开始，声明一个适当的类：</p>
<pre><code class="language-lean"># namespace Ex
class Inhabited (a : Type u) where
  default : a

#check @Inhabited.default
-- Inhabited.default : {a : Type u} → [self : Inhabited a] → a
# end Ex
</code></pre>
<p>注意 <code>Inhabited.default</code> 没有任何显式的参数。</p>
<p><code>Inhabited a</code> 类的元素简单地表示为形如 <code>Inhabited.mk x</code> 的表达式，其中 <code>x: a</code> 是某个元素。
投射函数 <code>Inhabited.default</code> 将允许我们从 <code>Inhabited a</code> 的元素中“提取”出 <code>a</code> 的元素。
现在我们为该类提供一些实例：</p>
<pre><code class="language-lean"># namespace Ex
# class Inhabited (a : Type _) where
#  default : a
instance : Inhabited Bool where
  default := true

instance : Inhabited Nat where
  default := 0

instance : Inhabited Unit where
  default := ()

instance : Inhabited Prop where
  default := True

#eval (Inhabited.default : Nat)
-- 0

#eval (Inhabited.default : Bool)
-- true
# end Ex
</code></pre>
<p>你可以使用命令 <code>export</code> 为 <code>Inhabited.default</code> 创建别名 <code>default</code>。</p>
<pre><code class="language-lean"># namespace Ex
# class Inhabited (a : Type _) where
#  default : a
# instance : Inhabited Bool where
#  default := true
# instance : Inhabited Nat where
#  default := 0
# instance : Inhabited Unit where
#  default := ()
# instance : Inhabited Prop where
#  default := True
export Inhabited (default)

#eval (default : Nat)
-- 0

#eval (default : Bool)
-- true
# end Ex
</code></pre>
<h2 id="嵌套实例化"><a class="header" href="#嵌套实例化">嵌套实例化</a></h2>
<p>如果这就是类型类推断的全部内容，那就不是很令人印象深刻；
这只是一种将实例存储在查找表中以供推导器查找的机制。
使类型类推断强大的是它可以<em>嵌套</em>实例化。也就是说，
一个实例声明可以依赖于类型类的一个隐式实例。
这会导致类推断通过递归地链式实例化，并在需要时进行回溯，类似于 Prolog 中的搜索。</p>
<p>例如，下面的定义表明，如果两个类型<code>a</code>和<code>b</code>是可行的，那么它们的乘积也是可行的：</p>
<pre><code class="language-lean">instance [Inhabited a] [Inhabited b] : Inhabited (a × b) where
  default := (default, default)
</code></pre>
<p>在之前的实例声明中添加了这个之后，类型类实例可以推导出，例如，<code>Nat × Bool</code> 的默认元素：</p>
<pre><code class="language-haskell">instance (Default a, Default b) =&gt; Default (a, b) where
  def = (def, def)
</code></pre>
<p>这个实例声明表示，当类型 <code>a</code> 和 <code>b</code> 都有默认实现时，<code>(a, b)</code> 类型的默认实现就是 <code>(def, def)</code>。这样，通过这个实例声明，我们可以为 <code>Nat × Bool</code> 类型推导出一个默认元素。</p>
<p>在这个例子中，如果 <code>Nat</code> 和 <code>Bool</code> 类型都有定义了 <code>Default</code> 类型类的实例，那么 <code>(def, def)</code> 就会成为 <code>Nat × Bool</code> 的默认元素。</p>
<p>对于其他的类型，我们可以根据具体的需求提供不同的实现。通过定义实例，我们可以满足不同类型的默认值需求。在本例中，我们定义了一个通用的实例，可以适用于所有具有 <code>Default</code> 实例的类型对 <code>(a, b)</code>。</p>
<pre><code class="language-lean"># namespace Ex
# class Inhabited (a : Type u) where
#  default : a
# instance : Inhabited Bool where
#  default := true
# instance : Inhabited Nat where
#  default := 0
# opaque default [Inhabited a] : a :=
#  Inhabited.default
instance [Inhabited a] [Inhabited b] : Inhabited (a × b) where
  default := (default, default)

#eval (default : Nat × Bool)
-- (0, true)
# end Ex
</code></pre>
<p>类似地，我们可以用适当的常量函数填充类型函数：</p>
<pre><code class="language-lean">instance [Inhabited b] : Inhabited (a → b) where
  default := fun _ =&gt; default
</code></pre>
<p>作为一个练习，尝试为其他类型（如 <code>List</code> 和 <code>Sum</code> 类型）定义默认实例。</p>
<p>Lean 标准库中包含了 <code>inferInstance</code> 的定义。它的类型是 <code>{α : Sort u} → [i : α] → α</code>，在期望类型是一个实例时触发类型类解析过程非常有用。</p>
<pre><code class="language-lean">#check (inferInstance : Inhabited Nat) -- Inhabited Nat

def foo : Inhabited (Nat × Nat) :=
  inferInstance

theorem ex : foo.default = (default, default) :=
  rfl
</code></pre>
<p>您可以使用 <code>#print</code> 命令来检查 <code>inferInstance</code> 函数的简单性。</p>
<pre><code class="language-lean">#print inferInstance
</code></pre>
<h2 id="tostring"><a class="header" href="#tostring">ToString</a></h2>
<p>多态方法 <code>toString</code> 的类型为 <code>{α : Type u} → [ToString α] → α → String</code>。您可以为自己的类型实现该实例，并使用链式调用将复杂的值转换为字符串。Lean已经为大多数内置类型提供了 <code>ToString</code> 实例。</p>
<pre><code class="language-lean">structure Person where
  name : String
  age  : Nat

instance : ToString Person where
  toString p := p.name ++ &quot;@&quot; ++ toString p.age

#eval toString { name := &quot;Leo&quot;, age := 542 : Person }
#eval toString ({ name := &quot;Daniel&quot;, age := 18 : Person }, &quot;hello&quot;)
</code></pre>
<h2 id="数字"><a class="header" href="#数字">数字</a></h2>
<p>数字在 Lean 中是多态的。你可以使用一个数字（例如 <code>2</code>）来表示任何实现了类型类 <code>OfNat</code> 的类型的元素。</p>
<pre><code class="language-lean">structure Rational where
  num : Int
  den : Nat
  inv : den ≠ 0

instance : OfNat Rational n where
  ofNat := { num := n, den := 1, inv := by decide }

instance : ToString Rational where
  toString r := s!&quot;{r.num}/{r.den}&quot;

#eval (2 : Rational) -- 2/1

#check (2 : Rational) -- Rational
#check (2 : Nat)      -- Nat
</code></pre>
<p>在 Lean 中，<code>(2 : Nat)</code> 和 <code>(2 : Rational)</code> 这两个术语的展开形式分别为 <code>OfNat.ofNat Nat 2 (instOfNatNat 2)</code> 和 <code>OfNat.ofNat Rational 2 (instOfNatRational 2)</code>。我们称展开形式中出现的数字 <code>2</code> 为原始自然数。你可以使用宏 <code>nat_lit 2</code> 来表示原始自然数 <code>2</code>。</p>
<pre><code class="language-lean">#check nat_lit 2  -- Nat
</code></pre>
<p>原始自然数 <em>不是</em> 多态的。</p>
<p><code>OfNat</code> 类型类是通过数字参数化的。因此，您可以为特定数字定义实例。
第二个参数通常是一个变量，就像上面的示例一样，或者是一个 <em>原始</em> 自然数。</p>
<pre><code class="language-lean">class Monoid (α : Type u) where
  unit : α
  op   : α → α → α

instance [s : Monoid α] : OfNat α (nat_lit 1) where
  ofNat := s.unit

def getUnit [Monoid α] : α :=
  1
</code></pre>
<h2 id="输出参数"><a class="header" href="#输出参数">输出参数</a></h2>
<p>默认情况下，当项 <code>T</code> 已知且不包含缺失部分时，Lean 仅尝试合成实例 <code>Inhabited T</code>。下面的命令会产生错误&quot;类型类实例问题被卡住，常常是由于元变量 <code>?m.7</code>&quot;，因为类型中有一个缺失部分（即 <code>_</code>）。</p>
<pre><code class="language-lean">#check_failure (inferInstance : Inhabited (Nat × _))
</code></pre>
<p>你可以将类型类 <code>Inhabited</code> 的参数视为类型类合成器的<em>输入</em>值。当一个类型类有多个参数时，你可以将其中一些标记为输出参数。即使这些参数有缺失的部分，Lean也会启动类型类合成器。在下面的示例中，我们使用输出参数来定义一个<em>异构</em>多态乘法。</p>
<pre><code class="language-lean"># namespace Ex
class HMul (α : Type u) (β : Type v) (γ : outParam (Type w)) where
  hMul : α → β → γ

export HMul (hMul)

instance : HMul Nat Nat Nat where
  hMul := Nat.mul

instance : HMul Nat (Array Nat) (Array Nat) where
  hMul a bs := bs.map (fun b =&gt; hMul a b)

#eval hMul 4 3           -- 12
#eval hMul 4 #[2, 3, 4]  -- #[8, 12, 16]
# end Ex
</code></pre>
<p>参数 <code>α</code> 和 <code>β</code> 被认为是输入参数，而 <code>γ</code> 是一个输出参数。
给定一个应用程序 <code>hMul a b</code>，在知道 <code>a</code> 和 <code>b</code> 的类型之后，类型类综合器会被调用，并从输出参数 <code>γ</code> 中获取到结果类型。
在上面的例子中，我们定义了两个实例。第一个实例是自然数的同类乘法。第二个实例是数组的标量乘法。
注意，您可以将实例链接起来并泛化第二个实例。</p>
<pre><code class="language-lean"># namespace Ex
class HMul (α : Type u) (β : Type v) (γ : outParam (Type w)) where
  hMul : α → β → γ

export HMul (hMul)

instance : HMul Nat Nat Nat where
  hMul := Nat.mul

instance : HMul Int Int Int where
  hMul := Int.mul

instance [HMul α β γ] : HMul α (Array β) (Array γ) where
  hMul a bs := bs.map (fun b =&gt; hMul a b)

#eval hMul 4 3                    -- 12
#eval hMul 4 #[2, 3, 4]           -- #[8, 12, 16]
#eval hMul (-2) #[3, -1, 4]       -- #[-6, 2, -8]
#eval hMul 2 #[#[2, 3], #[0, 4]]  -- #[#[4, 6], #[0, 8]]
# end Ex
</code></pre>
<p>当你拥有一个实例 <code>HMul α β γ</code> 时，你可以在 <code>Array β</code> 类型的数组上使用我们的新的标量数组乘法实例，标量的类型是 <code>α</code>。在最后的 <code>#eval</code> 中，注意实例在一个数组的数组上被使用了两次。</p>
<h2 id="默认实例"><a class="header" href="#默认实例">默认实例</a></h2>
<p>在类 <code>HMul</code> 中，参数 <code>α</code> 和 <code>β</code> 被视为输入值。因此，类型类合成仅在这两个类型已知之后才开始。这可能经常过于限制。</p>
<pre><code class="language-lean"># namespace Ex
class HMul (α : Type u) (β : Type v) (γ : outParam (Type w)) where
  hMul : α → β → γ

export HMul (hMul)

instance : HMul Int Int Int where
  hMul := Int.mul

def xs : List Int := [1, 2, 3]

-- Error &quot;typeclass instance problem is stuck, it is often due to metavariables HMul ?m.89 ?m.90 ?m.91&quot;
#check_failure fun y =&gt; xs.map (fun x =&gt; hMul x y)
# end Ex
</code></pre>
<p>实例 <code>HMul</code> 没有被 Lean 合成，因为没有指定 <code>y</code> 的类型。
然而，在这种情况下，默认情况下我们可以假设 <code>y</code> 和 <code>x</code> 的类型应该相同。我们可以使用<em>默认实例</em>来实现这一点。</p>
<pre><code class="language-lean"># namespace Ex
class HMul (α : Type u) (β : Type v) (γ : outParam (Type w)) where
  hMul : α → β → γ

export HMul (hMul)

@[default_instance]
instance : HMul Int Int Int where
  hMul := Int.mul

def xs : List Int := [1, 2, 3]

#check fun y =&gt; xs.map (fun x =&gt; hMul x y)  -- Int → List Int
# end Ex
</code></pre>
<p>通过为上面的实例添加属性 <code>default_instance</code> ，我们告诉 Lean 在待解决的类型类综合问题中使用此实例。实际的 Lean 实现定义了同态和异态的算术运算符类型类。此外，<code>a+b</code>、<code>a*b</code>、<code>a-b</code>、<code>a/b</code> 和 <code>a%b</code> 是异态版本的符号表示。实例 <code>OfNat Nat n</code> 是 <code>OfNat</code> 类的默认实例（优先级为100）。这就是为什么当期望的类型未知时，数字 <code>2</code> 的类型为 <code>Nat</code>。您可以定义优先级更高的默认实例来覆盖内置的实例。</p>
<pre><code class="language-lean">structure Rational where
  num : Int
  den : Nat
  inv : den ≠ 0

@[default_instance 200]
instance : OfNat Rational n where
  ofNat := { num := n, den := 1, inv := by decide }

instance : ToString Rational where
  toString r := s!&quot;{r.num}/{r.den}&quot;

#check 2 -- Rational
</code></pre>
<p>优先级对于控制不同默认实例之间的交互也很有用。
例如，假设 <code>xs</code> 的类型是 <code>List α</code>。在展开 <code>xs.map (fun x =&gt; 2 * x)</code> 时，我们希望给乘法的同类型实例的优先级高于 <code>OfNat</code> 的默认实例。
当我们只实现了 <code>HMul α α α</code> 实例而没有实现 <code>HMul Nat α α</code> 实例时，这点尤为重要。
现在，我们揭示 Lean 中 <code>a*b</code> 表示法的定义。</p>
<pre><code class="language-lean"># namespace Ex
class OfNat (α : Type u) (n : Nat) where
  ofNat : α

@[default_instance]
instance (n : Nat) : OfNat Nat n where
  ofNat := n

class HMul (α : Type u) (β : Type v) (γ : outParam (Type w)) where
  hMul : α → β → γ

class Mul (α : Type u) where
  mul : α → α → α

@[default_instance 10]
instance [Mul α] : HMul α α α where
  hMul a b := Mul.mul a b

infixl:70 &quot; * &quot; =&gt; HMul.hMul
# end Ex
</code></pre>
<p><code>Mul</code> 类非常方便，适用于只实现均质乘法的类型。</p>
<h2 id="局部实例"><a class="header" href="#局部实例">局部实例</a></h2>
<p>在 Lean 中，类型类是使用属性来实现的。因此，您可以使用 <code>local</code> 修饰符来指示它们仅在当前的 <code>section</code> 或 <code>namespace</code> 关闭之前有效，或者在当前文件的末尾之前有效。</p>
<pre><code class="language-lean">structure Point where
  x : Nat
  y : Nat

section

local instance : Add Point where
  add a b := { x := a.x + b.x, y := a.y + b.y }

def double (p : Point) :=
  p + p

end -- instance `Add Point` is not active anymore

-- def triple (p : Point) :=
--  p + p + p  -- Error: failed to synthesize instance
</code></pre>
<p>你也可以使用 &quot;<code>attribute</code>&quot; 命令来临时禁用一个实例，直到当前 &quot;<code>section</code>&quot; 或 &quot;<code>namespace</code>&quot; 关闭，或者直到当前文件的末尾。</p>
<pre><code class="language-lean">structure Point where
  x : Nat
  y : Nat

instance addPoint : Add Point where
  add a b := { x := a.x + b.x, y := a.y + b.y }

def double (p : Point) :=
  p + p

attribute [-instance] addPoint

-- def triple (p : Point) :=
--  p + p + p  -- Error: failed to synthesize instance
</code></pre>
<h2 id="作用域实例"><a class="header" href="#作用域实例">作用域实例</a></h2>
<p>你还可以在命名空间中声明作用域实例。这种类型的实例只在你进入该命名空间或打开该命名空间时处于活动状态。</p>
<pre><code class="language-lean">structure Point where
  x : Nat
  y : Nat

namespace Point

scoped instance : Add Point where
  add a b := { x := a.x + b.x, y := a.y + b.y }

def double (p : Point) :=
  p + p

end Point
-- instance `Add Point` is not active anymore

-- #check fun (p : Point) =&gt; p + p + p  -- Error

namespace Point
-- instance `Add Point` is active again
#check fun (p : Point) =&gt; p + p + p

end Point

open Point -- activates instance `Add Point`
#check fun (p : Point) =&gt; p + p + p
</code></pre>
<p>你可以使用命令 <code>open scoped &lt;namespace&gt;</code> 来激活作用域属性，但不会从命名空间中“打开”名称。</p>
<pre><code class="language-lean">structure Point where
  x : Nat
  y : Nat

namespace Point

scoped instance : Add Point where
  add a b := { x := a.x + b.x, y := a.y + b.y }

def double (p : Point) :=
  p + p

end Point

open scoped Point -- activates instance `Add Point`
#check fun (p : Point) =&gt; p + p + p

-- #check fun (p : Point) =&gt; double p -- Error: unknown identifier 'double'
</code></pre>
<h2 id="可判定命题"><a class="header" href="#可判定命题">可判定命题</a></h2>
<p>让我们考虑标准库中另一个示例，即<code>Decidable</code>命题的类型类。大致来说，<code>Prop</code>类型的一个元素是可判断的，如果我们可以确定它是真还是假。这一区别只在构造性数学中有用；经典数学上，每个命题都是可判定的。但是，如果我们使用经典原理，比如用<code>case</code>语句定义一个函数，那么这个函数将不是可计算的。从算法的角度来说，<code>Decidable</code>类型类可以用来推断一种有效确定命题是否为真的过程。因此，当可能时，该类型类支持这种计算定义，并同时允许平滑过渡到使用经典定义和经典推理。</p>
<p>在标准库中，<code>Decidable</code>被如下形式地定义：</p>
<pre><code class="language-lean"># namespace Hidden
class inductive Decidable (p : Prop) where
  | isFalse (h : ¬p) : Decidable p
  | isTrue  (h : p)  : Decidable p
# end Hidden
</code></pre>
<p>从逻辑上讲，拥有一个元素 <code>t : Decidable p</code> 要比拥有一个元素 <code>t : p ∨ ¬p</code> 更强大；它使我们能够根据 <code>p</code> 的真值来定义任意类型的值。例如，为了使表达式 <code>if p then a else b</code> 有意义，我们需要知道 <code>p</code> 是可判定的。该表达式是 <code>ite p a b</code> 的语法糖，其中 <code>ite</code> 定义如下：</p>
<pre><code class="language-lean"># namespace Hidden
def ite {α : Sort u} (c : Prop) [h : Decidable c] (t e : α) : α :=
  Decidable.casesOn (motive := fun _ =&gt; α) h (fun _ =&gt; e) (fun _ =&gt; t)
# end Hidden
</code></pre>
<p>标准库还包含一个名为 <code>dite</code> 的变种，即依赖 if-then-else 表达式。它的定义如下：</p>
<pre><code class="language-lean"># namespace Hidden
def dite {α : Sort u} (c : Prop) [h : Decidable c] (t : c → α) (e : Not c → α) : α :=
  Decidable.casesOn (motive := fun _ =&gt; α) h e t
# end Hidden
</code></pre>
<p>也就是说，在 <code>dite c t e</code> 中，我们可以假设在 &quot;then&quot; 分支中 <code>hc : c</code>，在 &quot;else&quot; 分支中 <code>hnc : ¬ c</code>。为了更方便地使用 <code>dite</code>，Lean 允许我们写成 <code>if h : c then t else e</code>，而不是 <code>dite c (λ h : c =&gt; t) (λ h : ¬ c =&gt; e)</code>。</p>
<p>在没有经典逻辑的情况下，我们不能证明每个命题都是可判定的。但我们可以证明一些命题是可判定的。例如，我们可以证明相等性和自然数和整数上的比较等基本操作的可判定性。此外，可判定性在命题连接词下是保持不变的。</p>
<pre><code class="language-lean">#check @instDecidableAnd
  -- {p q : Prop} → [Decidable p] → [Decidable q] → Decidable (And p q)

#check @instDecidableOr
#check @instDecidableNot
</code></pre>
<p>因此，我们可以对自然数上的可判定谓词进行情况定义：</p>
<pre><code class="language-lean">def step (a b x : Nat) : Nat :=
  if x &lt; a ∨ x &gt; b then 0 else 1

set_option pp.explicit true
#print step
</code></pre>
<p>打开隐式参数后，编译器推导出命题 <code>x &lt; a ∨ x &gt; b</code> 的可判定性，只需应用适当的实例。</p>
<p>使用经典公理，我们可以证明每个命题都是可判定的。您可以导入经典公理，并通过打开 <code>Classical</code> 命名空间来使用可判定性的通用实例。</p>
<pre><code class="language-lean">open Classical
</code></pre>
<p>因此，<code>Decidable p</code>对于每一个<code>p</code>都有一个实例。
因此，当您想要进行经典推理时，库中依赖决定性假设的所有定理都可以自由使用。在<a href="./axioms_and_computation.html">章节公理和计算</a>中，我们将看到使用排中律来定义函数可以阻止它们被用于计算。因此，标准库给<code>propDecidable</code>实例分配了较低的优先级。</p>
<pre><code class="language-lean"># namespace Hidden
open Classical
noncomputable scoped
instance (priority := low) propDecidable (a : Prop) : Decidable a :=
  choice &lt;| match em a with
    | Or.inl h =&gt; ⟨isTrue h⟩
    | Or.inr h =&gt; ⟨isFalse h⟩
# end Hidden
</code></pre>
<p>这确保 Lean 会优先考虑其他实例，并在其他推断可决性的尝试失败后再退回到 <code>propDecidable</code>。</p>
<p><code>Decidable</code> 类型类还为证明定理提供了一些小规模的自动化。标准库引入了策略 <code>decide</code>，它使用 <code>Decidable</code> 实例来解决简单的目标。</p>
<pre><code class="language-lean">example : 10 &lt; 5 ∨ 1 &gt; 0 := by
  decide

example : ¬ (True ∧ False) := by
  decide

example : 10 * 20 = 200 := by
  decide

theorem ex : True ∧ 2 = 1+1 := by
  decide

#print ex
-- theorem ex : True ∧ 2 = 1 + 1 :=
-- of_decide_eq_true (Eq.refl true)

#check @of_decide_eq_true
-- ∀ {p : Prop} [Decidable p], decide p = true → p

#check @decide
-- (p : Prop) → [Decidable p] → Bool
</code></pre>
<p>它们的工作原理如下。表达式 &quot;decide p&quot; 试图推断一个 &quot;p&quot; 的决策过程，如果成功的话，它的计算结果将是 &quot;true&quot; 或 &quot;false&quot;。特别地，如果 &quot;p&quot; 是一个真闭合表达式，&quot;decide p&quot; 将通过定义化规约为布尔值 &quot;true&quot;。在假设 &quot;decide p = true&quot; 的情况下，&quot;of_decide_eq_true&quot; 得到一个关于 &quot;p&quot; 成立的证明。策略 &quot;decide&quot; 将这一切组合在一起来证明目标 &quot;p&quot;。根据前面的观察，只要推断的决策过程对于 &quot;c&quot; 来说具有足够的信息来定义化地计算出 &quot;isTrue&quot; 的情况，&quot;decide&quot; 将能够成功。</p>
<h2 id="管理类型类推断"><a class="header" href="#管理类型类推断">管理类型类推断</a></h2>
<p>如果你处于这样一种情况，需要提供一个 Lean 可以通过类型类推断来推断的表达式，你可以使用 &quot;inferInstance&quot; 请求 Lean 执行推断：</p>
<pre><code class="language-lean">def foo : Add Nat := inferInstance
def bar : Inhabited (Nat → Nat) := inferInstance

#check @inferInstance
-- {α : Sort u} → [α] → α
</code></pre>
<p>事实上，你可以使用 Lean 的 <code>(t : T)</code> 表示法来简洁地指定你要查找的实例所属的类：</p>
<pre><code class="language-lean">#check (inferInstance : Add Nat)
</code></pre>
<p>你还可以使用辅助定义 <code>inferInstanceAs</code> ：</p>
<pre><code class="language-lean">#check inferInstanceAs (Add Nat)

#check @inferInstanceAs
-- (α : Sort u) → [α] → α
</code></pre>
<p>有时候 Lean 无法找到一个实例，因为该类被嵌套在一个定义中。例如，Lean 无法找到 <code>Inhabited (Set α)</code> 的一个实例。我们可以显式地声明一个：</p>
<pre><code class="language-lean">def Set (α : Type u) := α → Prop

-- fails
-- example : Inhabited (Set α) :=
--  inferInstance

instance : Inhabited (Set α) :=
  inferInstanceAs (Inhabited (α → Prop))
</code></pre>
<p>有时，你可能会发现类型类推断无法找到预期的实例，或者更糟糕的是，进入无限循环并超时。为了帮助在这些情况下进行调试，Lean允许你请求搜索的跟踪日志：</p>
<pre><code class="language-lean">set_option trace.Meta.synthInstance true
</code></pre>
<p>如果你在使用 VS Code，你可以将鼠标放在相关的定理或定义上来阅读结果，或者使用 <code>Ctrl-Shift-Enter</code> 快捷键打开消息窗口来阅读结果。在 Emacs 中，你可以使用 <code>C-c C-x</code> 在你的文件上运行一个独立的 Lean 进程，输出缓冲区会显示每次类型类解析过程被触发时的跟踪。</p>
<p>你还可以使用以下选项限制搜索范围：</p>
<pre><code class="language-lean">set_option synthInstance.maxHeartbeats 10000
set_option synthInstance.maxSize 400
</code></pre>
<p>选项 <code>synthInstance.maxHeartbeats</code> 指定每个类型类解析问题的最大心跳数。一个心跳是指（小型）内存分配的次数（以千为单位），0 表示没有限制。选项 <code>synthInstance.maxSize</code> 是用于构建类型类实例合成过程中的解决方案时使用的实例的最大数量。</p>
<p>请记住，在 VS Code 和 Emacs 编辑器模式中，<code>set_option</code> 命令中的选项名称支持制表符补全，以帮助您找到合适的选项。</p>
<p>正如上面所述，给定上下文中的类型类实例代表了一个类似 Prolog 的程序，它产生了回溯搜索。程序的效率和找到的解决方案都可能取决于系统尝试实例的顺序。最后声明的实例将首先尝试。而且，如果实例在其他模块中声明，那么它们尝试的顺序将取决于命名空间的打开顺序。后打开的命名空间中声明的实例将先尝试。</p>
<p>您可以通过为类型类实例分配一个 <em>优先级</em> 来改变尝试的顺序。当声明一个实例时，它会被分配一个默认的优先级值。您可以在定义实例时分配其他优先级。以下示例说明了如何进行这样的分配：</p>
<pre><code class="language-lean">class Foo where
  a : Nat
  b : Nat

instance (priority := default+1) i1 : Foo where
  a := 1
  b := 1

instance i2 : Foo where
  a := 2
  b := 2

example : Foo.a = 1 :=
  rfl

instance (priority := default+2) i3 : Foo where
  a := 3
  b := 3

example : Foo.a = 3 :=
  rfl
</code></pre>
<h2 id="使用类型类进行强制转换"><a class="header" href="#使用类型类进行强制转换">使用类型类进行强制转换</a></h2>
<p>最基本的类型强制转换将一个类型的元素映射到另一个类型。例如，从 <code>Nat</code> 到 <code>Int</code> 的强制转换允许我们将任意元素 <code>n : Nat</code> 视为 <code>Int</code> 类型的元素。但是有些强制转换取决于参数；例如，对于任意类型 <code>α</code>，我们可以将任意元素 <code>as : List α</code> 视为 <code>Set α</code> 的元素，即出现在列表中的元素的集合。相应的强制转换定义在以 <code>α</code> 为参数的类型族 <code>List α</code> 上。</p>
<p>Lean 允许我们声明三种类型的强制转换：</p>
<ul>
<li>从一个类型族到另一个类型族</li>
<li>从一个类型族到排序类的集合</li>
<li>从一个类型族到函数类型的集合</li>
</ul>
<p>第一种类型的强制转换允许我们将源族的任意成员的元素视为目标族相应成员的元素。第二种类型的强制转换允许我们将源族的任意成员的元素视为类型。第三种类型的强制转换允许我们将源族的任意成员的元素视为函数。让我们逐个考虑每种类型。</p>
<p>在 Lean 中，强制转换是基于类型类解析框架实现的。我们通过声明一个类型为 <code>Coe α β</code> 的实例来定义从 <code>α</code> 到 <code>β</code> 的强制转换。例如，我们可以如下方式定义从 <code>Bool</code> 到 <code>Prop</code> 的强制转换：</p>
<pre><code class="language-lean">instance : Coe Bool Prop where
  coe b := b = true
</code></pre>
<p>这使得我们可以在 if-then-else 表达式中使用布尔条件：</p>
<pre><code class="language-lean">#eval if true then 5 else 3
#eval if false then 5 else 3
</code></pre>
<p>我们可以定义从 <code>List α</code> 到 <code>Set α</code> 的强制转换如下：</p>
<pre><code class="language-lean">def list.to_set (l : list α) : set α := λ a, a ∈ l
</code></pre>
<p>The coercion function <code>list.to_set</code> takes a list <code>l</code> of type <code>list α</code> and returns a function from <code>α</code> to <code>Prop</code> such that for any element <code>a</code> of type <code>α</code>, <code>a</code> is in <code>l</code> if and only if it satisfies the function. This coercion allows us to treat a list as a set and perform set operations on it.</p>
<pre><code class="language-lean"># def Set (α : Type u) := α → Prop
# def Set.empty {α : Type u} : Set α := fun _ =&gt; False
# def Set.mem (a : α) (s : Set α) : Prop := s a
# def Set.singleton (a : α) : Set α := fun x =&gt; x = a
# def Set.union (a b : Set α) : Set α := fun x =&gt; a x ∨ b x
# notation &quot;{ &quot; a &quot; }&quot; =&gt; Set.singleton a
# infix:55 &quot; ∪ &quot; =&gt; Set.union
def List.toSet : List α → Set α
  | []    =&gt; Set.empty
  | a::as =&gt; {a} ∪ as.toSet

instance : Coe (List α) (Set α) where
  coe a := a.toSet

def s : Set Nat := {1}
#check s ∪ [2, 3]
-- s ∪ List.toSet [2, 3] : Set Nat
</code></pre>
<p>我们可以使用符号 <code>↑</code> 来在特定位置引入强制转换的表示。这也有助于明确我们的意图，并解决强制转换解析系统的限制。</p>
<pre><code class="language-lean"># def Set (α : Type u) := α → Prop
# def Set.empty {α : Type u} : Set α := fun _ =&gt; False
# def Set.mem (a : α) (s : Set α) : Prop := s a
# def Set.singleton (a : α) : Set α := fun x =&gt; x = a
# def Set.union (a b : Set α) : Set α := fun x =&gt; a x ∨ b x
# notation &quot;{ &quot; a &quot; }&quot; =&gt; Set.singleton a
# infix:55 &quot; ∪ &quot; =&gt; Set.union
# def List.toSet : List α → Set α
#   | []    =&gt; Set.empty
#   | a::as =&gt; {a} ∪ as.toSet
# instance : Coe (List α) (Set α) where
#   coe a := a.toSet
def s : Set Nat := {1}

#check let x := ↑[2, 3]; s ∪ x
-- let x := List.toSet [2, 3]; s ∪ x : Set Nat
#check let x := [2, 3]; s ∪ x
-- let x := [2, 3]; s ∪ List.toSet x : Set Nat
</code></pre>
<p>Lean 还支持使用类型类 <code>CoeDep</code> 进行依赖的强制转换。例如，我们不能将任意命题强制转换为 <code>Bool</code>，只能是实现了 <code>Decidable</code> 类型类的命题可以进行强制转换。</p>
<pre><code class="language-lean">instance (p : Prop) [Decidable p] : CoeDep Prop p Bool where
  coe := decide p
</code></pre>
<p>Lean 还会根据需要链接（非依赖的）强制转换。实际上，类型类 <code>CoeT</code> 是 <code>Coe</code> 的传递闭包。</p>
<p>现在我们来考虑第二类强制转换。通过“排序类”，我们指的是宇宙集合 <code>Type u</code>。第二类强制转换的形式为：</p>
<pre><code>    c : (x1 : A1) → ... → (xn : An) → F x1 ... xn → Type u
</code></pre>
<p>其中<code>F</code>是上述类型族。它使我们可以在<code>t</code>为类型<code>F a1 ... an</code>时写作<code>s : t</code>。换句话说，这个强制转换允许我们将<code>F a1 ... an</code>的元素视为类型。这在定义代数结构时非常有用，其中一个组成部分，即结构的载体，是<code>Type</code>类型。例如，我们可以如下定义一个半群：</p>
<pre><code class="language-lean">structure Semigroup where
  carrier : Type u
  mul : carrier → carrier → carrier
  mul_assoc (a b c : carrier) : mul (mul a b) c = mul a (mul b c)

instance (S : Semigroup) : Mul S.carrier where
  mul a b := S.mul a b
</code></pre>
<p>换句话说，一个半群由一个类型 <code>carrier</code> 和一个乘法运算 <code>mul</code> 组成，满足乘法结合律。<code>instance</code> 命令使得我们可以在有 <code>a b : S.carrier</code> 的情况下，用 <code>a * b</code> 代替 <code>Semigroup.mul S a b</code>；注意到 Lean 可以从 <code>a</code> 和 <code>b</code> 的类型推断出参数 <code>S</code>。函数 <code>Semigroup.carrier</code> 将类 <code>Semigroup</code> 映射到排序 <code>Type u</code>：</p>
<pre><code class="language-lean"># structure Semigroup where
#   carrier : Type u
#   mul : carrier → carrier → carrier
#   mul_assoc (a b c : carrier) : mul (mul a b) c = mul a (mul b c)
# instance (S : Semigroup) : Mul S.carrier where
#   mul a b := S.mul a b
#check Semigroup.carrier
</code></pre>
<p>如果我们声明这个函数为一个强制转换函数，那么每当我们有一个半群<code>S：Semigroup</code>时，我们可以使用<code>a：S</code>来代替<code>a：S.carrier</code>：</p>
<pre><code class="language-lean"># structure Semigroup where
#   carrier : Type u
#   mul : carrier → carrier → carrier
#   mul_assoc (a b c : carrier) : mul (mul a b) c = mul a (mul b c)
# instance (S : Semigroup) : Mul S.carrier where
#   mul a b := S.mul a b
instance : CoeSort Semigroup (Type u) where
  coe s := s.carrier

example (S : Semigroup) (a b c : S) : (a * b) * c = a * (b * c) :=
  Semigroup.mul_assoc _ a b c
</code></pre>
<p>是强制转换使得 <code>(a b c : S)</code> 的写法成为可能。注意，我们定义了一个 <code>CoeSort Semigroup (Type u)</code> 的实例而不是 <code>Coe Semigroup (Type u)</code>。</p>
<p>通过“类函数类型”，我们指的是 Pi 类型 <code>(z : B) → C</code> 的集合。第三种强制转换的形式为：</p>
<pre><code>    c : (x1 : A1) → ... → (xn : An) → (y : F x1 ... xn) → (z : B) → C
</code></pre>
<p>其中<code>F</code>再次是类型的一个族，而<code>B</code>和<code>C</code>可以依赖于<code>x1, ..., xn, y</code>。这使得当<code>t</code>是<code>F a1 ... an</code>的元素时，我们可以写成<code>t s</code>。换句话说，强制转换使我们能够将<code>F a1 ... an</code>的元素视为函数。继续上面的例子，我们可以定义半群<code>S1</code>和<code>S2</code>之间的态射的概念。也就是说，从<code>S1</code>的承载到<code>S2</code>的承载的函数（注意隐式的强制转换），并且保持乘法运算。投影<code>morphism.mor</code>将一个态射映射到底层的函数：</p>
<pre><code class="language-lean"># structure Semigroup where
#   carrier : Type u
#   mul : carrier → carrier → carrier
#   mul_assoc (a b c : carrier) : mul (mul a b) c = mul a (mul b c)
# instance (S : Semigroup) : Mul S.carrier where
#   mul a b := S.mul a b
# instance : CoeSort Semigroup (Type u) where
#   coe s := s.carrier
structure Morphism (S1 S2 : Semigroup) where
  mor : S1 → S2
  resp_mul : ∀ a b : S1, mor (a * b) = (mor a) * (mor b)

#check @Morphism.mor
</code></pre>
<p>因此，它是第三种类型的强制的首要选择。</p>
<pre><code class="language-lean"># structure Semigroup where
#   carrier : Type u
#   mul : carrier → carrier → carrier
#   mul_assoc (a b c : carrier) : mul (mul a b) c = mul a (mul b c)
# instance (S : Semigroup) : Mul S.carrier where
#   mul a b := S.mul a b
# instance : CoeSort Semigroup (Type u) where
#   coe s := s.carrier
# structure Morphism (S1 S2 : Semigroup) where
#   mor : S1 → S2
#   resp_mul : ∀ a b : S1, mor (a * b) = (mor a) * (mor b)
instance (S1 S2 : Semigroup) : CoeFun (Morphism S1 S2) (fun _ =&gt; S1 → S2) where
  coe m := m.mor

theorem resp_mul {S1 S2 : Semigroup} (f : Morphism S1 S2) (a b : S1)
        : f (a * b) = f a * f b :=
  f.resp_mul a b

example (S1 S2 : Semigroup) (f : Morphism S1 S2) (a : S1) :
      f (a * a * a) = f a * f a * f a :=
  calc f (a * a * a)
    _ = f (a * a) * f a := by rw [resp_mul f]
    _ = f a * f a * f a := by rw [resp_mul f]
</code></pre>
<p>有了强制转换的设定，我们可以使用 <code>f (a * a * a)</code> 来代替 <code>f.mor (a * a * a)</code>。当使用 <code>Morphism</code> <code>f</code> 替代期望函数的地方时，Lean会插入强制转换。与 <code>CoeSort</code> 类似，我们还有另一个类 <code>CoeFun</code> 用于这种类型的强制转换。字段 <code>F</code> 用于指定我们要转换到的函数类型。该类型可能依赖于我们要转换的类型。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="策略模式"><a class="header" href="#策略模式">策略模式</a></h1>
<p>在一个策略块中，你可以使用关键字 <code>conv</code> 进入转换模式。在这个模式下，可以在假设和目标中导航，甚至在函数抽象和依赖箭头中，应用重写或简化步骤。</p>
<h2 id="基本导航和重写"><a class="header" href="#基本导航和重写">基本导航和重写</a></h2>
<p>首先，让我们证明一个例子 <code>(a b c : Nat) : a * (b * c) = a * (c * b)</code> （本文件中的例子有些不切实际，因为其他策略可以立即完成它们）。最初的尝试是进入策略模式并尝试 <code>rw [Nat.mul_comm]</code>。但这会把目标转化为 <code>b * c * a = a * (c * b)</code>，在这个术语中，第一个出现的乘法被交换了。有几种修复这个问题的方法，其中一种方法是使用一个更精确的工具：转换模式。下面的代码块显示了每行执行后的当前目标。</p>
<pre><code class="language-lean">example (a b c : Nat) : a * (b * c) = a * (c * b) := by
  conv =&gt;
    -- ⊢ a * (b * c) = a * (c * b)
    lhs
    -- ⊢ a * (b * c)
    congr
    -- 2 goals: ⊢ a, ⊢ b * c
    rfl
    -- ⊢ b * c
    rw [Nat.mul_comm]
</code></pre>
<p>上面的片段显示了三个导航命令：</p>
<ul>
<li><code>lhs</code>导航到关系的左侧（在这里是等式），还有一个<code>rhs</code>导航到右侧。</li>
<li><code>congr</code>根据当前头函数（这里是乘法）的（非依赖的和显式的）参数创建相同数量的目标。</li>
<li><code>rfl</code>使用自反性来关闭目标。</li>
</ul>
<p>一旦到达相关的目标，我们可以像正常策略模式一样使用<code>rw</code>命令。</p>
<p>使用转换模式的第二个主要原因是在限定词下进行重写。假设我们想要证明示例<code>(fun x : Nat =&gt; 0 + x) = (fun x =&gt; x)</code>。最初的尝试是进入策略模式并尝试<code>rw [Nat.zero_add]</code>。但这将导致令人沮丧的失败。</p>
<pre><code>error: tactic 'rewrite' failed, did not find instance of the pattern
       in the target expression
  0 + ?n
⊢ (fun x =&gt; 0 + x) = fun x =&gt; x
</code></pre>
<p>解决方案是：</p>
<pre><code class="language-lean">example : (fun x : Nat =&gt; 0 + x) = (fun x =&gt; x) := by
  conv =&gt;
    lhs
    intro x
    rw [Nat.zero_add]
</code></pre>
<p>其中 <code>intro x</code> 是进入 <code>fun</code> 文件夹的导航命令。
需要注意的是这个示例有些人为，也可以这样做：</p>
<pre><code class="language-lean">example : (fun x : Nat =&gt; 0 + x) = (fun x =&gt; x) := by
  funext x; rw [Nat.zero_add]
</code></pre>
<p>或者只是</p>
<pre><code class="language-lean">example : (fun x : Nat =&gt; 0 + x) = (fun x =&gt; x) := by
  simp
</code></pre>
<p><code>conv</code> 还可以使用 <code>conv at h</code> 从本地环境中重写一个假设 <code>h</code>。</p>
<h2 id="模式匹配-1"><a class="header" href="#模式匹配-1">模式匹配</a></h2>
<p>使用上述命令进行导航可能会很繁琐。我们可以使用模式匹配来简化操作，如下所示：</p>
<pre><code class="language-lean">example (a b c : Nat) : a * (b * c) = a * (c * b) := by
  conv in b * c =&gt; rw [Nat.mul_comm]
</code></pre>
<p>这只是一种语法糖，即为</p>
<pre><code class="language-lean">example (a b c : Nat) : a * (b * c) = a * (c * b) := by
  conv =&gt;
    pattern b * c
    rw [Nat.mul_comm]
</code></pre>
<p>当然，通配符是允许的：</p>
<pre><code class="language-lean">example (a b c : Nat) : a * (b * c) = a * (c * b) := by
  conv in _ * c =&gt; rw [Nat.mul_comm]
</code></pre>
<h2 id="结构化转化策略"><a class="header" href="#结构化转化策略">结构化转化策略</a></h2>
<p>花括号和点号也可用于<code>conv</code>模式，以结构化转化策略。</p>
<pre><code class="language-lean">example (a b c : Nat) : (0 + a) * (b * c) = a * (c * b) := by
  conv =&gt;
    lhs
    congr
    . rw [Nat.zero_add]
    . rw [Nat.mul_comm]
</code></pre>
<h2 id="转化模式中的其他策略"><a class="header" href="#转化模式中的其他策略">转化模式中的其他策略</a></h2>
<ul>
<li><code>arg i</code> 输入应用程序的第<code>i</code>个非依赖显式参数。</li>
</ul>
<pre><code class="language-lean">example (a b c : Nat) : a * (b * c) = a * (c * b) := by
  conv =&gt;
    -- ⊢ a * (b * c) = a * (c * b)
    lhs
    -- ⊢ a * (b * c)
    arg 2
    -- ⊢ b * c
    rw [Nat.mul_comm]
</code></pre>
<ul>
<li>
<p><code>args</code> 是 <code>congr</code> 的另一个名称。</p>
</li>
<li>
<p><code>simp</code> 将简化器应用于当前目标。它支持在常规策略模式下可用的相同选项。</p>
</li>
</ul>
<pre><code class="language-lean">def f (x : Nat) :=
  if x &gt; 0 then x + 1 else x + 2

example (g : Nat → Nat) (h₁ : g x = x + 1) (h₂ : x &gt; 0) : g x = f x := by
  conv =&gt;
    rhs
    simp [f, h₂]
  exact h₁
</code></pre>
<ul>
<li>使用给定的参数迭代<code>arg</code>和<code>intro</code>，输入为<code>[1, x, 2, y]</code>。这只是一个宏：</li>
</ul>
<pre><code>syntax enterArg := ident &lt;|&gt; group(&quot;@&quot;? num)
syntax &quot;enter &quot; &quot;[&quot; (colGt enterArg),+ &quot;]&quot;: conv
macro_rules
  | `(conv| enter [$i:num]) =&gt; `(conv| arg $i)
  | `(conv| enter [@$i:num]) =&gt; `(conv| arg @$i)
  | `(conv| enter [$id:ident]) =&gt; `(conv| ext $id)
  | `(conv| enter [$arg:enterArg, $args,*]) =&gt; `(conv| (enter [$arg]; enter [$args,*]))
</code></pre>
<ul>
<li>
<p><code>done</code> 如果存在未解决的目标，则失败。</p>
</li>
<li>
<p><code>trace_state</code> 显示当前策略的状态。</p>
</li>
<li>
<p><code>whnf</code> 将术语转换为弱头正常形式。</p>
</li>
<li>
<p><code>tactic =&gt; &lt;tactic sequence&gt;</code> 返回常规策略模式。这对于不受 <code>conv</code> 模式支持的目标的消除以及应用自定义的合同和外延引理非常有用。</p>
</li>
</ul>
<pre><code class="language-lean">example (g : Nat → Nat → Nat)
        (h₁ : ∀ x, x ≠ 0 → g x x = 1)
        (h₂ : x ≠ 0)
        : g x x + x = 1 + x := by
  conv =&gt;
    lhs
    -- ⊢ g x x + x
    arg 1
    -- ⊢ g x x
    rw [h₁]
    -- 2 goals: ⊢ 1, ⊢ x ≠ 0
    . skip
    . tactic =&gt; exact h₂
</code></pre>
<ul>
<li><code>&lt;term&gt;</code> 的应用是 <code>tactic =&gt; apply &lt;term&gt;</code> 的语法糖</li>
</ul>
<pre><code class="language-lean">example (g : Nat → Nat → Nat)
        (h₁ : ∀ x, x ≠ 0 → g x x = 1)
        (h₂ : x ≠ 0)
        : g x x + x = 1 + x := by
  conv =&gt;
    lhs
    arg 1
    rw [h₁]
    . skip
    . apply h₂
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="公理和计算"><a class="header" href="#公理和计算">公理和计算</a></h1>
<p>我们已经看到 Lean 中实现的构造演算版本包括依赖函数类型（dependent function types）、带有归纳类型（inductive types）和从底部开始具有不可证明谓词（proof-irrelevant <code>Prop</code>）的等级层级的宇宙。在本章中，我们考虑通过添加附加公理和规则来扩展 CIC。以这种方式扩展基础系统通常是方便的，它可以使得证明更多定理成为可能，也可以使证明定理变得更容易，而这些定理否则可能无法证明。但添加附加公理可能带来负面后果，这些后果可能超出对其正确性的担忧。特别地，公理的使用与定义和定理的计算内容相关，我们将在此进行探讨。</p>
<p>Lean 被设计用于支持计算和经典的推理。倾向于&quot;计算纯净&quot;（computationally pure）的用户可以坚持使用一个能够确保系统中的封闭表达式求值到规范形式的片段。特别地，例如，任何具有类型 <code>Nat</code> 的计算纯净封闭表达式将归约为一个数字。</p>
<p>Lean 的标准库定义了一个附加公理，即命题等值性（propositional extensionality），以及一个因此导致函数等值性原理的商数构建（quotient construction）。这些扩展可以用于开发集合和有限集的理论。我们将在下面看到，使用这些定理可能会阻止 Lean 内核中的求值，以至于类型为 <code>Nat</code> 的封闭项不再计算为数字。但 Lean 在将定义编译为其虚拟机求值器的字节码时会擦除类型和命题信息，由于这些公理只会添加新的命题，所以它们与计算解释是兼容的。即使是对计算感兴趣的用户，也可能希望使用排中律来推理计算。这也会阻止核心求值，但它与编译为字节码是兼容的。</p>
<p>标准库还定义了完全与计算解释相敌对的选择公理，因为它从一个断言其存在的命题中神奇地产生&quot;数据&quot;。在某些经典建设中，其使用是必不可少的，用户可以在需要时导入它。但使用此构造生成的表达式会阻止计算。
在 Lean 中，数据没有计算内容，我们需要标记这些定义为<code>noncomputable</code>来说明这一点。</p>
<p>通过一个聪明的技巧（称为 Diaconescu 定理），可以使用命题外延性、函数外延性和选择公理推导出排中律。然而，正如上面所提到的，使用排中律仍然与字节码编译和代码抽取兼容，正如其他经典原则一样，只要它们不被用于制造数据。</p>
<p>因此，在宇宙、依赖函数类型和归纳类型的基本框架之上，标准库还添加了三个额外的组件：</p>
<ul>
<li>命题外延性公理</li>
<li>商集构造，它意味着函数外延性</li>
<li>选择原则，它从一个存在的命题中生成数据。</li>
</ul>
<p>前两者会阻止 Lean 中的规范化，但与字节码求值兼容，而第三者则不能进行计算解释。下面我们将更详细地讨论这些细节。</p>
<h2 id="历史和哲学背景"><a class="header" href="#历史和哲学背景">历史和哲学背景</a></h2>
<p>在大部分历史上，数学本质上是计算的：几何处理几何对象的构造，代数处理方程组的算法解法，分析提供计算随时间演化的系统未来行为的方法。从一个定理的证明到“对于每个<code>x</code>，都存在<code>y</code>使得...”的效果，通常可以直接提取一个算法来计算给定<code>x</code>的这样一个<code>y</code>。</p>
<p>然而，19世纪，数学论证的复杂性增加，迫使数学家们开发新的推理风格，抑制算法信息并引用数学对象的描述，将这些对象的细节抽象化。目标是获得强大的“概念性”理解，而不会陷入计算细节，但这导致了一些在直接计算阅读上简直是<em>错误</em>的数学定理的产生。</p>
<p>即使在今天，人们普遍认可计算对数学的重要性。但是对于如何最好地解决计算问题，存在不同的观点。从一种<em>构造性</em>的观点来看，将数学与其计算根源分离是一个错误；每个有意义的数学定理都应该具有直接的计算表达。
计算解释。从 <em>经典</em> 角度来看，保持关注点的分离是更有成效的：我们可以使用一种语言和一套方法来编写计算机程序，同时保持使用非构造性理论和方法对其进行推理的自由。Lean被设计用于支持这两种方法。库的核心部分是根据构造性开发的，但系统也提供了支持进行经典数学推理的功能。</p>
<p>从计算的角度来看，依赖类型理论的最纯净的部分完全避免使用<code>Prop</code>。归纳类型和依赖函数类型可以被视为数据类型，并且可以通过应用规约规则来“评估”这些类型的项，直到无法再应用规则为止。原则上，任何类型为<code>Nat</code>的封闭项（即没有自由变量的项）应该被评估为一个数字，即<code>succ (... (succ zero)...)</code>。</p>
<p>引入不受证明影响的<code>Prop</code>并将定理标记为不可约是关注点分离的第一步。意图是类型<code>p : Prop</code>的元素在计算中不起任何作用，因此在这个意义上，一个项<code>t : p</code>的具体构造是“无关紧要”的。仍然可以定义包含类型<code>Prop</code>元素的计算对象；关键是这些元素可以帮助我们推理计算的影响，但在我们从项中提取“代码”时可以忽略它们。类型为<code>Prop</code>的元素并非完全无害，它们包括等式<code>s = t : α</code>，其中<code>α</code>是任意类型，这些等式可以用作转换，以类型检查项。在下面，我们将看到这些转换如何阻塞系统中的计算。但是，在一个擦除命题内容、忽略中间类型约束并将项规约到正规形式的评估方案下仍然可以进行计算。这正是Lean的虚拟机所做的。</p>
<h2>在采用不受证明影响的<code>Prop</code>之后，我们可能认为使用排中律定律，即<code>p ∨ ¬p</code>（其中<code>p</code>是任意命题）是合理的。当然，这也可能阻塞计算。
命题展开性</h2>
<p>命题展开性是以下的公理：</p>
<pre><code>extensionalityP : Π {P Q : Prop} → (P ↔ Q) → P ≡ Q
extensionalityP (P ↔ Q) = logical-equivalence-extensionality (logically-upward-! P Q) (logically-downward-! P Q)
</code></pre>
<p>其中，<code>Π</code> 表示依赖函数类型，<code>Prop</code> 表示命题类型。</p>
<p>命题展开性公理表明，如果命题 <code>P</code> 和 <code>Q</code> 互相等价（即，它们之间有双向的逻辑等价关系），则 <code>P</code> 和 <code>Q</code> 是相等的。</p>
<p>这一公理的证明依赖于逻辑等价性的展开性公理，具体地说就是 <code>logically-upward-!</code> 和 <code>logically-downward-!</code> 函数。这两个函数分别根据逻辑等价关系的定义将相应的命题进一步展开成对应的逻辑关系。在 Coq 语言中，使用 <code>≡</code> 符号表示两个命题的相等关系。</p>
<p>命题展开性公理的引入使得在 Coq 语言中可以使用等价符号（↔）来表示命题的双向逻辑等价关系，从而更加直观地描述和推理命题的逻辑关系。</p>
<pre><code class="language-lean"># namespace Hidden
axiom propext {a b : Prop} : (a ↔ b) → a = b
# end Hidden
</code></pre>
<p>它断言当两个命题相互蕴含时，它们实际上是相等的。这与集合论解释一致，在该解释中，任何元素 <code>a: Prop</code> 要么为空，要么是一个有着某个特殊元素 <code>*</code> 的单元素集 <code>{*}</code>。这个公理的效果是，在任何情况下，等价的命题可以相互替代：</p>
<pre><code class="language-lean">theorem thm₁ (a b c d e : Prop) (h : a ↔ b) : (c ∧ a ∧ d → e) ↔ (c ∧ b ∧ d → e) :=
  propext h ▸ Iff.refl _

theorem thm₂ (a b : Prop) (p : Prop → Prop) (h : a ↔ b) (h₁ : p a) : p b :=
  propext h ▸ h₁
</code></pre>
<h2 id="函数的等值性扩展性"><a class="header" href="#函数的等值性扩展性">函数的等值性扩展性</a></h2>
<p>类似于命题的等值性扩展性，函数的等值性扩展性断言了任意两个类型为 <code>(x : α) → β x</code> 的函数，如果它们在所有的输入上保持一致，那么它们是相等的。</p>
<pre><code class="language-lean">universe u v
#check (@funext :
           {α : Type u}
         → {β : α → Type u}
         → {f g : (x : α) → β x}
         → (∀ (x : α), f x = g x)
         → f = g)

#print funext
</code></pre>
<p>从经典的集合论的角度来看，这正是两个函数相等的意思。这被称为“外延”的函数观点。然而，从构造的角度来看，有时更自然地将函数看作算法或者以某种显式方式呈现的计算机程序。当然，两个计算机程序可能在每个输入上计算出相同的答案，尽管它们在语法上非常不同。以类似的方式，你可能希望保持一种函数观点，而不将拥有相同输入/输出行为的函数等同起来。这被称为“内涵”的函数观点。</p>
<p>实际上，函数外延性是从商集存在性推导出来的，我们将在下一节中描述。在 Lean 标准库中，因此<code>funext</code>是从商构造中
<a href="https://github.com/leanprover/lean4/blob/master/src/Init/Core.lean">通过证明</a>。</p>
<p>假设对于<code>α : Type</code>，我们定义<code>Set α := α → Prop</code>来表示<code>α</code>的子集的类型，基本上将子集与谓词等同起来。通过结合<code>funext</code>和<code>propext</code>，我们得到这种集合的外延理论：</p>
<pre><code class="language-lean">def Set (α : Type u) := α → Prop

namespace Set

def mem (x : α) (a : Set α) := a x

infix:50 (priority := high) &quot;∈&quot; =&gt; mem

theorem setext {a b : Set α} (h : ∀ x, x ∈ a ↔ x ∈ b) : a = b :=
  funext (fun x =&gt; propext (h x))

end Set
</code></pre>
<p>我们可以接着定义空集和集合的交集，然后证明集合恒等式：</p>
<pre><code class="language-lean"># def Set (α : Type u) := α → Prop
# namespace Set
# def mem (x : α) (a : Set α) := a x
# infix:50 (priority := high) &quot;∈&quot; =&gt; mem
# theorem setext {a b : Set α} (h : ∀ x, x ∈ a ↔ x ∈ b) : a = b :=
#   funext (fun x =&gt; propext (h x))
def empty : Set α := fun x =&gt; False

notation (priority := high) &quot;∅&quot; =&gt; empty

def inter (a b : Set α) : Set α :=
  fun x =&gt; x ∈ a ∧ x ∈ b

infix:70 &quot; ∩ &quot; =&gt; inter

theorem inter_self (a : Set α) : a ∩ a = a :=
  setext fun x =&gt; Iff.intro
    (fun ⟨h, _⟩ =&gt; h)
    (fun h =&gt; ⟨h, h⟩)

theorem inter_empty (a : Set α) : a ∩ ∅ = ∅ :=
  setext fun x =&gt; Iff.intro
    (fun ⟨_, h⟩ =&gt; h)
    (fun h =&gt; False.elim h)

theorem empty_inter (a : Set α) : ∅ ∩ a = ∅ :=
  setext fun x =&gt; Iff.intro
    (fun ⟨h, _⟩ =&gt; h)
    (fun h =&gt; False.elim h)

theorem inter.comm (a b : Set α) : a ∩ b = b ∩ a :=
  setext fun x =&gt; Iff.intro
    (fun ⟨h₁, h₂⟩ =&gt; ⟨h₂, h₁⟩)
    (fun ⟨h₁, h₂⟩ =&gt; ⟨h₂, h₁⟩)
# end Set
</code></pre>
<p>下面是一个示例，展示了函数外延性如何阻碍 Lean 内核中的计算。</p>
<pre><code class="language-lean">open function

-- define a new constant with a complicated computation rule
constant f : ℕ → bool
constant hf : ∀ n, f n = tt

-- define a new constant with a simpler definition
constant g : ℕ → bool
constant hg : ∀ n, g n = tt

-- define a new function using the function extensionality axiom
def h : ℕ → bool :=
λ n, if f n = tt then tt else g n

-- the following lemma shows that h n = tt for all n
-- 
-- the proof does not directly match any constructor, and needs to apply function extensionality somewhere
lemma hn_tt : ∀ n, h n = tt :=
by {
  intro n,
  rw h,
  -- if h n is not equal to tt as a term, then it must have been constructed using the else branch
  -- in this case, f n must be false, so obtain a contradiction
  by_contradiction hneq,
  simp at hneq,
  exact (hf n).symm.trans hneq,
}
</code></pre>
<p>在这个例子中，我们假设有一个函数 <code>f</code> 和一个函数 <code>g</code> ，它们都接受一个自然数作为输入，并返回一个布尔值。我们使用函数外延性公理定义了一个新的函数 <code>h</code> ，它根据 <code>f n</code> 的结果决定返回 <code>tt</code> 还是根据 <code>g n</code> 的结果返回 <code>tt</code> 。</p>
<p>引理 <code>hn_tt</code> 用于证明对于所有的自然数 <code>n</code> ，<code>h n</code> 等于 <code>tt</code> 。为了证明这个引理，我们首先对 <code>h</code> 进行了简化。如果 <code>h n</code> 不等于 <code>tt</code> ，那么它只能是使用了 <code>else</code> 分支进行构造。在这种情况下，<code>f n</code> 必须为假，从而产生矛盾。因此，我们可以得出结论 <code>h n = tt</code> 。</p>
<pre><code class="language-lean">def f (x : Nat) := x
def g (x : Nat) := 0 + x

theorem f_eq_g : f = g :=
  funext fun x =&gt; (Nat.zero_add x).symm

def val : Nat :=
  Eq.recOn (motive := fun _ _ =&gt; Nat) f_eq_g 0

-- does not reduce to 0
#reduce val

-- evaluates to 0
#eval val
</code></pre>
<p>首先，我们使用函数等价性证明了两个函数 <code>f</code> 和 <code>g</code> 相等，然后我们通过在类型中将 <code>f</code> 替换为 <code>g</code>，将 <code>0</code> 转化为类型 <code>Nat</code>。当然，这个转化是没有实际作用的，因为 <code>Nat</code> 并不依赖于 <code>f</code>。但是这已经足够造成问题了：根据系统的计算规则，我们现在有了一个闭合的 <code>Nat</code> 类型的项，它不能被简化成一个数值。在这种情况下，我们可能会尝试将表达式简化为 <code>0</code>。但在非平凡的例子中，消除转换会改变项的类型，这可能导致环境表达式的类型不正确。然而，虚拟机在求值表达式为 <code>0</code> 时并不会出现问题。下面是一个类似的人为例子，展示了 <code>propext</code> 可能产生的问题。</p>
<pre><code class="language-lean">theorem tteq : (True ∧ True) = True :=
  propext (Iff.intro (fun ⟨h, _⟩ =&gt; h) (fun h =&gt; ⟨h, h⟩))

def val : Nat :=
  Eq.recOn (motive := fun _ _ =&gt; Nat) tteq 0

-- does not reduce to 0
#reduce val

-- evaluates to 0
#eval val
</code></pre>
<p>当前的研究项目，包括对<em>观察型理论</em>和<em>立方型理论</em>的研究，旨在以允许对涉及函数外延性、商以及其他类型的约简方式扩展类型理论。但解决方案并不是那么明确，而且 Lean 的基础计算规则并不支持这样的约简。</p>
<p>从某种意义上说，类型转换不会改变表达式的含义。相反，它是一种用于推理表达式类型的机制。在合适的语义下，将项按保持其含义的方式约简是有意义的，可以忽略用于使约简类型正确的中间簿记。在这种情况下，向&quot;Prop&quot;中添加新的公理并不重要；根据证明的不相关性，&quot;Prop&quot;中的表达式不携带信息，可以安全地被约简过程忽略。</p>
<h2 id="商集"><a class="header" href="#商集">商集</a></h2>
<p>设<code>α</code>为任意类型，<code>r</code>是<code>α</code>上的等价关系。在数学中通常形成&quot;商集&quot;<code>α / r</code>，即&quot;模&quot;<code>r</code>的<code>α</code>的元素的类型。从集合论的角度来看，可以将<code>α / r</code>视为<code>α</code>的<code>r</code>等价类的集合。如果<code>f: α → β</code>是任意一个满足对每个<code>x y: α</code>都有<code>r x y</code>推出<code>f x = f y</code>的函数，那么<code>f</code>&quot;映射&quot;到一个函数<code>f' : α / r → β</code>，通过对每个等价类<code>⟦x⟧</code>定义<code>f' ⟦x⟧ = f x</code>。Lean 的标准库通过添加额外的常量来执行这些构造，将这个最后的等式作为定义约简规则。</p>
<p>在最基本的形式中，商集构造甚至不需要<code>r</code>是一个等价关系。以下常量内置于 Lean 中：</p>
<pre><code class="language-lean"># namespace Hidden
universe u v

axiom Quot : {α : Sort u} → (α → α → Prop) → Sort u

axiom Quot.mk : {α : Sort u} → (r : α → α → Prop) → α → Quot r

axiom Quot.ind :
    ∀ {α : Sort u} {r : α → α → Prop} {β : Quot r → Prop},
      (∀ a, β (Quot.mk r a)) → (q : Quot r) → β q

axiom Quot.lift :
    {α : Sort u} → {r : α → α → Prop} → {β : Sort u} → (f : α → β)
    → (∀ a b, r a b → f a = f b) → Quot r → β
# end Hidden
</code></pre>
<p>第一个定理是根据类型<code>α</code>上的任何二元关系<code>r</code>，形成类型<code>Quot r</code>。 第二个定理将<code>α</code>映射到<code>Quot α</code>，所以如果<code>r:α→α→Prop</code>和<code>a:α</code>，那么<code>Quot.mk r a</code>是<code>Quot r</code>的一个元素。 第三个定理<code>Quot.ind</code>表示<code>Quot.mk r a</code>的每个元素都是这种形式。至于<code>Quot.lift</code>，给定一个函数<code>f:α→β</code>，如果<code>h</code>是一个证明，证明<code>f</code>尊重关系<code>r</code>，那么<code>Quot.lift f h</code>就是在<code>Quot r</code>上对应的函数。其思想是对于<code>α</code>中的每个元素<code>a</code>，函数<code>Quot.lift f h</code>将<code>Quot.mk r a</code>（包含<code>a</code>的<code>r</code>-类）映射到<code>f a</code>，其中<code>h</code>表明该函数是良定义的。实际上，计算原理被声明为一个规约规则，如下面的证明所清楚地说明的。</p>
<pre><code class="language-lean">def mod7Rel (x y : Nat) : Prop :=
  x % 7 = y % 7

-- the quotient type
#check (Quot mod7Rel : Type)

-- the class of a
#check (Quot.mk mod7Rel 4 : Quot mod7Rel)

def f (x : Nat) : Bool :=
  x % 7 = 0

theorem f_respects (a b : Nat) (h : mod7Rel a b) : f a = f b := by
  simp [mod7Rel, f] at *
  rw [h]

#check (Quot.lift f f_respects : Quot mod7Rel → Bool)

-- the computation principle
example (a : Nat) : Quot.lift f f_respects (Quot.mk mod7Rel a) = f a :=
  rfl
</code></pre>
<p><code>Quot.sound</code>: For all <code>a₁ a₂ : α</code>, if <code>r a₁ a₂</code>, then <code>quot.mk r a₁ = quot.mk r a₂</code>.</p>
<p>This axiom ensures that the equivalence relation <code>r</code> is respected by the canonical map <code>quot.mk</code>, meaning that elements that are equivalent under <code>r</code> are mapped to the same element in the quotient type.</p>
<p>The <code>Quot.sound</code> axiom is crucial for proving the unique existence of the function <code>quot.lift</code>, which allows us to define functions on quotients using the property of the equivalence relation. Without this axiom, it would not be possible to ensure that the definitions on the quotient type are well-defined.</p>
<p>In summary, while the four constants of the quotient type alone are not very strong, the additional axiom <code>Quot.sound</code> plays a crucial role in making the quotient construction valid and ensuring the well-definedness of functions defined on quotients.</p>
<pre><code class="language-lean"># namespace Hidden
# universe u v
axiom Quot.sound :
      ∀ {α : Type u} {r : α → α → Prop} {a b : α},
        r a b → Quot.mk r a = Quot.mk r b
# end Hidden
</code></pre>
<p>这是一条公理，它断言了在<code>α</code>的任意两个<code>r</code>相关的元素在商集中等同。如果一个定理或定义使用了<code>Quot.sound</code>，则它将在<code>#print axioms</code>命令中显示。</p>
<p>当然，商集构造最常用于<code>r</code>是一个等价关系的情况下。给定如上所述的<code>r</code>，如果我们根据规则<code>r' a b</code>当且仅当<code>Quot.mk r a = Quot.mk r b</code>定义<code>r'</code>，则很明显<code>r'</code>是一个等价关系。事实上，<code>r'</code>是函数<code>a ↦ quot.mk r a</code>的<em>核</em>。公理<code>Quot.sound</code>表示<code>r a b</code>意味着<code>r' a b</code>。使用<code>Quot.lift</code>和<code>Quot.ind</code>，我们可以证明<code>r'</code>是包含<code>r</code>的最小等价关系，即如果<code>r''</code>是包含<code>r</code>的任何等价关系，那么<code>r' a b</code>意味着<code>r'' a b</code>。特别地，如果<code>r</code>一开始就是一个等价关系，那么对于所有<code>a</code>和<code>b</code>，我们有<code>r a b</code>当且仅当<code>r' a b</code>。</p>
<p>为了支持这种常见用例，标准库定义了<em>setoid</em>的概念，它只是一个带有相关等价关系的类型：</p>
<pre><code class="language-lean"># namespace Hidden
class Setoid (α : Sort u) where
  r : α → α → Prop
  iseqv : Equivalence r

instance {α : Sort u} [Setoid α] : HasEquiv α :=
  ⟨Setoid.r⟩

namespace Setoid

variable {α : Sort u} [Setoid α]

theorem refl (a : α) : a ≈ a :=
  iseqv.refl a

theorem symm {a b : α} (hab : a ≈ b) : b ≈ a :=
  iseqv.symm hab

theorem trans {a b c : α} (hab : a ≈ b) (hbc : b ≈ c) : a ≈ c :=
  iseqv.trans hab hbc

end Setoid
# end Hidden
</code></pre>
<p>给定一个类型 <code>α</code>，一个关系 <code>r</code> 在 <code>α</code> 上，以及一个证明 <code>p</code> 说明 <code>r</code> 是一个等价关系，我们可以定义 <code>Setoid.mk r p</code> 作为集合类的一个实例。</p>
<pre><code class="language-lean"># namespace Hidden
def Quotient {α : Sort u} (s : Setoid α) :=
  @Quot α Setoid.r
# end Hidden
</code></pre>
<p>常数 <code>Quotient.mk</code>、<code>Quotient.ind</code>、<code>Quotient.lift</code> 和 <code>Quotient.sound</code> 无非是 <code>Quot</code> 中相应元素的特例。类型类推断可以找到与类型 <code>α</code> 相关联的 Setoid 的事实带来了许多好处。首先，我们可以使用记法 <code>a ≈ b</code>（输入为 <code>\approx</code>）表示 <code>Setoid.r a b</code>，这里的 <code>Setoid</code> 实例在记法 <code>Setoid.r</code> 中是隐含的。我们可以使用通用定理 <code>Setoid.refl</code>、<code>Setoid.symm</code>、<code>Setoid.trans</code> 来推理关系。特别是对于商集，我们可以使用通用记法 <code>⟦a⟧</code> 表示 <code>Quot.mk Setoid.r</code>，这里的 <code>Setoid</code> 实例在记法 <code>Setoid.r</code> 中是隐含的，以及定理<code>Quotient.exact</code>：</p>
<pre><code class="language-lean"># universe u
#check (@Quotient.exact :
         ∀ {α : Sort u} {s : Setoid α} {a b : α},
           Quotient.mk s a = Quotient.mk s b → a ≈ b)
</code></pre>
<p><code>Quot</code> 恰好与<code>Quotient.sound</code>一同出现那么间接地意味着等价类中每个元素与<code>α</code>中的等价类准确对应。</p>
<p>回想一下，在标准库中，<code>α × β</code> 表示类型 <code>α</code> 和 <code>β</code> 的笛卡尔积。为了说明quotients的使用，让我们首先定义 <em>无序</em> 对的类型，其是类型 <code>α × α</code> 的商。首先，我们定义相关的等价关系：</p>
<pre><code class="language-lean">private def eqv (p₁ p₂ : α × α) : Prop :=
  (p₁.1 = p₂.1 ∧ p₁.2 = p₂.2) ∨ (p₁.1 = p₂.2 ∧ p₁.2 = p₂.1)

infix:50 &quot; ~ &quot; =&gt; eqv
</code></pre>
<p>下一步是证明 <code>eqv</code> 其实是一个等价关系，也就是说，它是自反的，对称的和传递的。我们可以通过使用依赖模式匹配来执行case-analysis，并将假设分解为能够重新组合以得出结论的部分，以便以一种方便和易读的方式证明这三个事实。</p>
<pre><code class="language-lean"># private def eqv (p₁ p₂ : α × α) : Prop :=
#   (p₁.1 = p₂.1 ∧ p₁.2 = p₂.2) ∨ (p₁.1 = p₂.2 ∧ p₁.2 = p₂.1)
# infix:50 &quot; ~ &quot; =&gt; eqv
private theorem eqv.refl (p : α × α) : p ~ p :=
  Or.inl ⟨rfl, rfl⟩

private theorem eqv.symm : ∀ {p₁ p₂ : α × α}, p₁ ~ p₂ → p₂ ~ p₁
  | (a₁, a₂), (b₁, b₂), (Or.inl ⟨a₁b₁, a₂b₂⟩) =&gt;
    Or.inl (by simp_all)
  | (a₁, a₂), (b₁, b₂), (Or.inr ⟨a₁b₂, a₂b₁⟩) =&gt;
    Or.inr (by simp_all)

private theorem eqv.trans : ∀ {p₁ p₂ p₃ : α × α}, p₁ ~ p₂ → p₂ ~ p₃ → p₁ ~ p₃
  | (a₁, a₂), (b₁, b₂), (c₁, c₂), Or.inl ⟨a₁b₁, a₂b₂⟩, Or.inl ⟨b₁c₁, b₂c₂⟩ =&gt;
    Or.inl (by simp_all)
  | (a₁, a₂), (b₁, b₂), (c₁, c₂), Or.inl ⟨a₁b₁, a₂b₂⟩, Or.inr ⟨b₁c₂, b₂c₁⟩ =&gt;
    Or.inr (by simp_all)
  | (a₁, a₂), (b₁, b₂), (c₁, c₂), Or.inr ⟨a₁b₂, a₂b₁⟩, Or.inl ⟨b₁c₁, b₂c₂⟩ =&gt;
    Or.inr (by simp_all)
  | (a₁, a₂), (b₁, b₂), (c₁, c₂), Or.inr ⟨a₁b₂, a₂b₁⟩, Or.inr ⟨b₁c₂, b₂c₁⟩ =&gt;
    Or.inl (by simp_all)

private theorem is_equivalence : Equivalence (@eqv α) :=
  { refl := eqv.refl, symm := eqv.symm, trans := eqv.trans }
</code></pre>
<p>现在我们已经证明了 <code>eqv</code> 是一个等价关系，我们可以构造一个 <code>Setoid (α × α)</code>，并使用它来定义类型 <code>UProd α</code>，表示无序对。</p>
<pre><code class="language-lean"># private def eqv (p₁ p₂ : α × α) : Prop :=
#   (p₁.1 = p₂.1 ∧ p₁.2 = p₂.2) ∨ (p₁.1 = p₂.2 ∧ p₁.2 = p₂.1)
# infix:50 &quot; ~ &quot; =&gt; eqv
# private theorem eqv.refl (p : α × α) : p ~ p :=
#   Or.inl ⟨rfl, rfl⟩
# private theorem eqv.symm : ∀ {p₁ p₂ : α × α}, p₁ ~ p₂ → p₂ ~ p₁
#   | (a₁, a₂), (b₁, b₂), (Or.inl ⟨a₁b₁, a₂b₂⟩) =&gt;
#     Or.inl (by simp_all)
#   | (a₁, a₂), (b₁, b₂), (Or.inr ⟨a₁b₂, a₂b₁⟩) =&gt;
#     Or.inr (by simp_all)
# private theorem eqv.trans : ∀ {p₁ p₂ p₃ : α × α}, p₁ ~ p₂ → p₂ ~ p₃ → p₁ ~ p₃
#   | (a₁, a₂), (b₁, b₂), (c₁, c₂), Or.inl ⟨a₁b₁, a₂b₂⟩, Or.inl ⟨b₁c₁, b₂c₂⟩ =&gt;
#     Or.inl (by simp_all)
#   | (a₁, a₂), (b₁, b₂), (c₁, c₂), Or.inl ⟨a₁b₁, a₂b₂⟩, Or.inr ⟨b₁c₂, b₂c₁⟩ =&gt;
#     Or.inr (by simp_all)
#   | (a₁, a₂), (b₁, b₂), (c₁, c₂), Or.inr ⟨a₁b₂, a₂b₁⟩, Or.inl ⟨b₁c₁, b₂c₂⟩ =&gt;
#     Or.inr (by simp_all)
#   | (a₁, a₂), (b₁, b₂), (c₁, c₂), Or.inr ⟨a₁b₂, a₂b₁⟩, Or.inr ⟨b₁c₂, b₂c₁⟩ =&gt;
#     Or.inl (by simp_all)
# private theorem is_equivalence : Equivalence (@eqv α) :=
#   { refl := eqv.refl, symm := eqv.symm, trans := eqv.trans }
instance uprodSetoid (α : Type u) : Setoid (α × α) where
  r     := eqv
  iseqv := is_equivalence

def UProd (α : Type u) : Type u :=
  Quotient (uprodSetoid α)

namespace UProd

def mk {α : Type} (a₁ a₂ : α) : UProd α :=
  Quotient.mk' (a₁, a₂)

notation &quot;{ &quot; a₁ &quot;, &quot; a₂ &quot; }&quot; =&gt; mk a₁ a₂

end UProd
</code></pre>
<p>请注意，我们在本地定义了表示有序对的记号 <code>{a₁, a₂}</code>，表示为 <code>Quotient.mk (a₁, a₂)</code>。这在说明的目的上很有用，但一般情况下并不是一个好主意，因为这个记法会使花括号的其他用途（例如记录和集合）被遮盖。</p>
<p>我们可以很容易地证明 <code>{a₁, a₂} = {a₂, a₁}</code>，使用 <code>Quot.sound</code>，因为我们有 <code>(a₁, a₂) ~ (a₂, a₁)</code>。</p>
<pre><code class="language-lean"># private def eqv (p₁ p₂ : α × α) : Prop :=
#   (p₁.1 = p₂.1 ∧ p₁.2 = p₂.2) ∨ (p₁.1 = p₂.2 ∧ p₁.2 = p₂.1)
# infix:50 &quot; ~ &quot; =&gt; eqv
# private theorem eqv.refl (p : α × α) : p ~ p :=
#   Or.inl ⟨rfl, rfl⟩
# private theorem eqv.symm : ∀ {p₁ p₂ : α × α}, p₁ ~ p₂ → p₂ ~ p₁
#   | (a₁, a₂), (b₁, b₂), (Or.inl ⟨a₁b₁, a₂b₂⟩) =&gt;
#     Or.inl (by simp_all)
#   | (a₁, a₂), (b₁, b₂), (Or.inr ⟨a₁b₂, a₂b₁⟩) =&gt;
#     Or.inr (by simp_all)
# private theorem eqv.trans : ∀ {p₁ p₂ p₃ : α × α}, p₁ ~ p₂ → p₂ ~ p₃ → p₁ ~ p₃
#   | (a₁, a₂), (b₁, b₂), (c₁, c₂), Or.inl ⟨a₁b₁, a₂b₂⟩, Or.inl ⟨b₁c₁, b₂c₂⟩ =&gt;
#     Or.inl (by simp_all)
#   | (a₁, a₂), (b₁, b₂), (c₁, c₂), Or.inl ⟨a₁b₁, a₂b₂⟩, Or.inr ⟨b₁c₂, b₂c₁⟩ =&gt;
#     Or.inr (by simp_all)
#   | (a₁, a₂), (b₁, b₂), (c₁, c₂), Or.inr ⟨a₁b₂, a₂b₁⟩, Or.inl ⟨b₁c₁, b₂c₂⟩ =&gt;
#     Or.inr (by simp_all)
#   | (a₁, a₂), (b₁, b₂), (c₁, c₂), Or.inr ⟨a₁b₂, a₂b₁⟩, Or.inr ⟨b₁c₂, b₂c₁⟩ =&gt;
#     Or.inl (by simp_all)
# private theorem is_equivalence : Equivalence (@eqv α) :=
#   { refl := eqv.refl, symm := eqv.symm, trans := eqv.trans }
# instance uprodSetoid (α : Type u) : Setoid (α × α) where
#   r     := eqv
#   iseqv := is_equivalence
# def UProd (α : Type u) : Type u :=
#   Quotient (uprodSetoid α)
# namespace UProd
# def mk {α : Type} (a₁ a₂ : α) : UProd α :=
#   Quotient.mk' (a₁, a₂)
# notation &quot;{ &quot; a₁ &quot;, &quot; a₂ &quot; }&quot; =&gt; mk a₁ a₂
theorem mk_eq_mk (a₁ a₂ : α) : {a₁, a₂} = {a₂, a₁} :=
  Quot.sound (Or.inr ⟨rfl, rfl⟩)
# end UProd
</code></pre>
<p>为了完成这个例子，给定<code>a : α</code>和<code>u : uprod α</code>，我们定义命题<code>a ∈ u</code>，如果<code>a</code>是无序对<code>u</code>中的一个元素，那么该命题应该成立。首先，我们在（有序）对上定义类似的命题<code>mem_fn a u</code>；然后我们展示<code>mem_fn</code>与等价关系<code>eqv</code>保持一致，使用引理<code>mem_respects</code>。这是在 Lean 标准库中广泛使用的一种习惯用法。</p>
<pre><code class="language-lean"># private def eqv (p₁ p₂ : α × α) : Prop :=
#   (p₁.1 = p₂.1 ∧ p₁.2 = p₂.2) ∨ (p₁.1 = p₂.2 ∧ p₁.2 = p₂.1)
# infix:50 &quot; ~ &quot; =&gt; eqv
# private theorem eqv.refl (p : α × α) : p ~ p :=
#   Or.inl ⟨rfl, rfl⟩
# private theorem eqv.symm : ∀ {p₁ p₂ : α × α}, p₁ ~ p₂ → p₂ ~ p₁
#   | (a₁, a₂), (b₁, b₂), (Or.inl ⟨a₁b₁, a₂b₂⟩) =&gt;
#     Or.inl (by simp_all)
#   | (a₁, a₂), (b₁, b₂), (Or.inr ⟨a₁b₂, a₂b₁⟩) =&gt;
#     Or.inr (by simp_all)
# private theorem eqv.trans : ∀ {p₁ p₂ p₃ : α × α}, p₁ ~ p₂ → p₂ ~ p₃ → p₁ ~ p₃
#   | (a₁, a₂), (b₁, b₂), (c₁, c₂), Or.inl ⟨a₁b₁, a₂b₂⟩, Or.inl ⟨b₁c₁, b₂c₂⟩ =&gt;
#     Or.inl (by simp_all)
#   | (a₁, a₂), (b₁, b₂), (c₁, c₂), Or.inl ⟨a₁b₁, a₂b₂⟩, Or.inr ⟨b₁c₂, b₂c₁⟩ =&gt;
#     Or.inr (by simp_all)
#   | (a₁, a₂), (b₁, b₂), (c₁, c₂), Or.inr ⟨a₁b₂, a₂b₁⟩, Or.inl ⟨b₁c₁, b₂c₂⟩ =&gt;
#     Or.inr (by simp_all)
#   | (a₁, a₂), (b₁, b₂), (c₁, c₂), Or.inr ⟨a₁b₂, a₂b₁⟩, Or.inr ⟨b₁c₂, b₂c₁⟩ =&gt;
#     Or.inl (by simp_all)
# private theorem is_equivalence : Equivalence (@eqv α) :=
#   { refl := eqv.refl, symm := eqv.symm, trans := eqv.trans }
# instance uprodSetoid (α : Type u) : Setoid (α × α) where
#   r     := eqv
#   iseqv := is_equivalence
# def UProd (α : Type u) : Type u :=
#   Quotient (uprodSetoid α)
# namespace UProd
# def mk {α : Type} (a₁ a₂ : α) : UProd α :=
#   Quotient.mk' (a₁, a₂)
# notation &quot;{ &quot; a₁ &quot;, &quot; a₂ &quot; }&quot; =&gt; mk a₁ a₂
# theorem mk_eq_mk (a₁ a₂ : α) : {a₁, a₂} = {a₂, a₁} :=
#   Quot.sound (Or.inr ⟨rfl, rfl⟩)
private def mem_fn (a : α) : α × α → Prop
  | (a₁, a₂) =&gt; a = a₁ ∨ a = a₂

-- auxiliary lemma for proving mem_respects
private theorem mem_swap {a : α} :
      ∀ {p : α × α}, mem_fn a p = mem_fn a (⟨p.2, p.1⟩)
  | (a₁, a₂) =&gt; by
    apply propext
    apply Iff.intro
    . intro
      | Or.inl h =&gt; exact Or.inr h
      | Or.inr h =&gt; exact Or.inl h
    . intro
      | Or.inl h =&gt; exact Or.inr h
      | Or.inr h =&gt; exact Or.inl h


private theorem mem_respects
      : {p₁ p₂ : α × α} → (a : α) → p₁ ~ p₂ → mem_fn a p₁ = mem_fn a p₂
  | (a₁, a₂), (b₁, b₂), a, Or.inl ⟨a₁b₁, a₂b₂⟩ =&gt; by simp_all
  | (a₁, a₂), (b₁, b₂), a, Or.inr ⟨a₁b₂, a₂b₁⟩ =&gt; by simp_all; apply mem_swap

def mem (a : α) (u : UProd α) : Prop :=
  Quot.liftOn u (fun p =&gt; mem_fn a p) (fun p₁ p₂ e =&gt; mem_respects a e)

infix:50 (priority := high) &quot; ∈ &quot; =&gt; mem

theorem mem_mk_left (a b : α) : a ∈ {a, b} :=
  Or.inl rfl

theorem mem_mk_right (a b : α) : b ∈ {a, b} :=
  Or.inr rfl

theorem mem_or_mem_of_mem_mk {a b c : α} : c ∈ {a, b} → c = a ∨ c = b :=
  fun h =&gt; h
# end UProd
</code></pre>
<p>为了方便起见，标准库还定义了 <code>Quotient.lift₂</code> 用于将二元函数提升，以及 <code>Quotient.ind₂</code> 用于对两个变量进行归纳。</p>
<p>在本节中，我们给出了关于商构造怎样暗示了函数外延性的一些提示。不难证明，对于类型 <code>(x : α) → β x</code> 上的外延等价是一个等价关系，因此我们可以考虑函数 &quot;在等价关系下的等价类&quot; 的类型 <code>extfun α β</code>。当然，应用操作保持了等价关系，也就是说如果 <code>f₁</code> 等价于 <code>f₂</code>，则 <code>f₁ a</code> 等于 <code>f₂ a</code>。因此应用操作产生了一个函数 <code>extfun_app : extfun α β → (x : α) → β x</code>。但是对于每个 <code>f</code>，<code>extfun_app ⟦f⟧</code> 在定义上等于 <code>fun x =&gt; f x</code>，这又在定义上等于 <code>f</code>。所以，当 <code>f₁</code> 和 <code>f₂</code> 在外延上相等时，我们有以下一连串的等式：</p>
<pre><code>    f₁ = extfun_app ⟦f₁⟧ = extfun_app ⟦f₂⟧ = f₂
</code></pre>
<p>结果是，<code>f₁</code> 等于 <code>f₂</code>。</p>
<h2 id="选择"><a class="header" href="#选择">选择</a></h2>
<p>为了陈述标准库中定义的最终公理，我们需要 <code>Nonempty</code> 类型，其定义如下：</p>
<pre><code class="language-lean"># namespace Hidden
class inductive Nonempty (α : Sort u) : Prop where
  | intro (val : α) : Nonempty α
# end Hidden
</code></pre>
<p>因为<code>Nonempty α</code>的类型是<code>Prop</code>，它的构造器包含数据，所以只能消除为<code>Prop</code>。
实际上，<code>Nonempty α</code>等价于<code>∃ x : α, True</code>。</p>
<pre><code class="language-lean">example (α : Type u) : Nonempty α ↔ ∃ x : α, True :=
  Iff.intro (fun ⟨a⟩ =&gt; ⟨a, trivial⟩) (fun ⟨a, h⟩ =&gt; ⟨a⟩)
</code></pre>
<p>我们的选择公理可以简单地表述如下：</p>
<pre><code class="language-lean"># namespace Hidden
# universe u
axiom choice {α : Sort u} : Nonempty α → α
# end Hidden
</code></pre>
<p>根据给出的断言 “h”，即 “α” 是非空的，<code>choice h</code> 神奇般地产生了 <code>α</code> 的一个元素。当然，这会阻止任何有意义的计算：根据 <code>Prop</code> 的解释，<code>h</code> 并不包含任何关于如何找到这样的元素的信息。</p>
<p>这个定理位于 <code>Classical</code> 命名空间中，因此定理的全名是 <code>Classical.choice</code>。选择原则等价于<em>不定描述原理</em>，可以用子类型来表达，如下所示：</p>
<pre><code class="language-lean"># namespace Hidden
# universe u
# axiom choice {α : Sort u} : Nonempty α → α
noncomputable def indefiniteDescription {α : Sort u} (p : α → Prop)
                                        (h : ∃ x, p x) : {x // p x} :=
  choice &lt;| let ⟨x, px⟩ := h; ⟨⟨x, px⟩⟩
# end Hidden
</code></pre>
<p>由于它依赖于<code>choice</code>，Lean 无法为<code>indefiniteDescription</code>生成字节码，因此需要我们将定义标记为<code>noncomputable</code>。在<code>Classical</code>命名空间中，函数<code>choose</code>和属性<code>choose_spec</code>将<code>indefiniteDescription</code>的输出分解为两部分：</p>
<pre><code class="language-lean"># open Classical
# namespace Hidden
noncomputable def choose {α : Sort u} {p : α → Prop} (h : ∃ x, p x) : α :=
  (indefiniteDescription p h).val

theorem choose_spec {α : Sort u} {p : α → Prop} (h : ∃ x, p x) : p (choose h) :=
  (indefiniteDescription p h).property
# end Hidden
</code></pre>
<p><code>选择</code>原则也消除了<code>非空</code>和更具建设性的<code>有人居住</code>属性之间的区别：</p>
<pre><code class="language-lean"># open Classical
theorem inhabited_of_nonempty : Nonempty α → Inhabited α :=
  fun h =&gt; choice (let ⟨a⟩ := h; ⟨⟨a⟩⟩)
</code></pre>
<p>在下一部分中，我们将看到 <code>propext</code>、<code>funext</code>和<code>choice</code>三者联合起来暗含了排中律和所有命题的可决定性。利用这些，我们可以加强“不确定描述”的原则，具体如下所示：</p>
<pre><code class="language-lean"># open Classical
# universe u
#check (@strongIndefiniteDescription :
         {α : Sort u} → (p : α → Prop)
         → Nonempty α → {x // (∃ (y : α), p y) → p x})
</code></pre>
<p>假设环境类型<code>α</code>非空，</p>
<p>如果存在条件<code>p</code>满足的<code>strongIndefiniteDescription p</code>，</p>
<p>那么它会产生一个满足<code>p</code>的<code>α</code>元素。</p>
<p>这个定义的数据部分通常被称为 <em>希尔伯特的epsilon函数</em>。</p>
<pre><code class="language-lean"># open Classical
# universe u
#check (@epsilon :
         {α : Sort u} → [Nonempty α]
         → (α → Prop) → α)

#check (@epsilon_spec :
         ∀ {α : Sort u} {p : α → Prop} (hex : ∃ (y : α), p y),
           p (@epsilon _ (nonempty_of_exists hex) p))
</code></pre>
<p>中文翻译：</p>
<h2 id="排中律"><a class="header" href="#排中律">排中律</a></h2>
<p>排中律是以下的陈述：</p>
<pre><code class="language-lean">open Classical

#check (@em : ∀ (p : Prop), p ∨ ¬p)
</code></pre>
<p><a href="https://en.wikipedia.org/wiki/Diaconescu%27s_theorem">Diaconescu定理</a>说明选择公理足以推导出排中律。更具体地说，它表明排中律可以从<code>Classical.choice</code>、<code>propext</code>和<code>funext</code>推得。我们概述一下在标准库中找到的证明。</p>
<p>首先，我们导入必要的公理，并定义两个谓词<code>U</code>和<code>V</code>：</p>
<pre><code class="language-lean"># namespace Hidden
open Classical
theorem em (p : Prop) : p ∨ ¬p :=
  let U (x : Prop) : Prop := x = True ∨ p
  let V (x : Prop) : Prop := x = False ∨ p

  have exU : ∃ x, U x := ⟨True, Or.inl rfl⟩
  have exV : ∃ x, V x := ⟨False, Or.inl rfl⟩
#   sorry
# end Hidden
</code></pre>
<p>如果 <code>p</code> 为真，则<code>Prop</code>的所有元素都属于 <code>U</code> 和 <code>V</code>。
如果 <code>p</code> 为假，则 <code>U</code> 是单元素集合 <code>true</code>，<code>V</code> 是单元素集合 <code>false</code>。</p>
<p>接下来，我们使用 <code>some</code> 从 <code>U</code> 和 <code>V</code> 中选择一个元素：</p>
<pre><code class="language-lean"># namespace Hidden
# open Classical
# theorem em (p : Prop) : p ∨ ¬p :=
#   let U (x : Prop) : Prop := x = True ∨ p
#   let V (x : Prop) : Prop := x = False ∨ p
#   have exU : ∃ x, U x := ⟨True, Or.inl rfl⟩
#   have exV : ∃ x, V x := ⟨False, Or.inl rfl⟩
  let u : Prop := choose exU
  let v : Prop := choose exV

  have u_def : U u := choose_spec exU
  have v_def : V v := choose_spec exV
#   sorry
# end Hidden
</code></pre>
<p><code>U</code>和<code>V</code>都是析取式，所以<code>u_def</code>和<code>v_def</code>表示了四种情况。在这四种情况中，其中一种是<code>u = True</code>且<code>v = False</code>，而在其他的情况中，<code>p</code>为真。因此我们有：</p>
<pre><code class="language-lean"># namespace Hidden
# open Classical
# theorem em (p : Prop) : p ∨ ¬p :=
#   let U (x : Prop) : Prop := x = True ∨ p
#   let V (x : Prop) : Prop := x = False ∨ p
#   have exU : ∃ x, U x := ⟨True, Or.inl rfl⟩
#   have exV : ∃ x, V x := ⟨False, Or.inl rfl⟩
#   let u : Prop := choose exU
#   let v : Prop := choose exV
#   have u_def : U u := choose_spec exU
#   have v_def : V v := choose_spec exV
  have not_uv_or_p : u ≠ v ∨ p :=
    match u_def, v_def with
    | Or.inr h, _ =&gt; Or.inr h
    | _, Or.inr h =&gt; Or.inr h
    | Or.inl hut, Or.inl hvf =&gt;
      have hne : u ≠ v := by simp [hvf, hut, true_ne_false]
      Or.inl hne
#   sorry
# end Hidden
</code></pre>
<p>另一方面，如果 <code>p</code> 为真，则根据函数外延性和命题外延性，<code>U</code> 和 <code>V</code> 是相等的。根据<code>u</code>和<code>v</code>的定义，这意味着它们也是相等的。</p>
<pre><code class="language-lean"># namespace Hidden
# open Classical
# theorem em (p : Prop) : p ∨ ¬p :=
#   let U (x : Prop) : Prop := x = True ∨ p
#   let V (x : Prop) : Prop := x = False ∨ p
#   have exU : ∃ x, U x := ⟨True, Or.inl rfl⟩
#   have exV : ∃ x, V x := ⟨False, Or.inl rfl⟩
#   let u : Prop := choose exU
#   let v : Prop := choose exV
#   have u_def : U u := choose_spec exU
#   have v_def : V v := choose_spec exV
#   have not_uv_or_p : u ≠ v ∨ p :=
#     match u_def, v_def with
#     | Or.inr h, _ =&gt; Or.inr h
#     | _, Or.inr h =&gt; Or.inr h
#     | Or.inl hut, Or.inl hvf =&gt;
#       have hne : u ≠ v := by simp [hvf, hut, true_ne_false]
#       Or.inl hne
  have p_implies_uv : p → u = v :=
    fun hp =&gt;
    have hpred : U = V :=
      funext fun x =&gt;
        have hl : (x = True ∨ p) → (x = False ∨ p) :=
          fun _ =&gt; Or.inr hp
        have hr : (x = False ∨ p) → (x = True ∨ p) :=
          fun _ =&gt; Or.inr hp
        show (x = True ∨ p) = (x = False ∨ p) from
          propext (Iff.intro hl hr)
    have h₀ : ∀ exU exV, @choose _ U exU = @choose _ V exV := by
      rw [hpred]; intros; rfl
    show u = v from h₀ _ _
#   sorry
# end Hidden
</code></pre>
<p>将这最后两个事实结合起来，得出了所需的结论：</p>
<pre><code class="language-lean"># namespace Hidden
# open Classical
# theorem em (p : Prop) : p ∨ ¬p :=
#   let U (x : Prop) : Prop := x = True ∨ p
#   let V (x : Prop) : Prop := x = False ∨ p
#   have exU : ∃ x, U x := ⟨True, Or.inl rfl⟩
#   have exV : ∃ x, V x := ⟨False, Or.inl rfl⟩
#   let u : Prop := choose exU
#   let v : Prop := choose exV
#   have u_def : U u := choose_spec exU
#   have v_def : V v := choose_spec exV
#   have not_uv_or_p : u ≠ v ∨ p :=
#     match u_def, v_def with
#     | Or.inr h, _ =&gt; Or.inr h
#     | _, Or.inr h =&gt; Or.inr h
#     | Or.inl hut, Or.inl hvf =&gt;
#       have hne : u ≠ v := by simp [hvf, hut, true_ne_false]
#       Or.inl hne
#   have p_implies_uv : p → u = v :=
#     fun hp =&gt;
#     have hpred : U = V :=
#       funext fun x =&gt;
#         have hl : (x = True ∨ p) → (x = False ∨ p) :=
#           fun _ =&gt; Or.inr hp
#         have hr : (x = False ∨ p) → (x = True ∨ p) :=
#           fun _ =&gt; Or.inr hp
#         show (x = True ∨ p) = (x = False ∨ p) from
#           propext (Iff.intro hl hr)
#     have h₀ : ∀ exU exV, @choose _ U exU = @choose _ V exV := by
#       rw [hpred]; intros; rfl
#     show u = v from h₀ _ _
  match not_uv_or_p with
  | Or.inl hne =&gt; Or.inr (mt p_implies_uv hne)
  | Or.inr h   =&gt; Or.inl h
# end Hidden
</code></pre>
<p>排中律的推论包括双重否定消除、按情况证明和反证法等，这些都在<a href="./propositions_and_proofs.html#classical-logic">经典逻辑章节</a>中进行了描述。排中律和命题外延性暗示了命题完备性：</p>
<pre><code class="language-lean"># namespace Hidden
open Classical
theorem propComplete (a : Prop) : a = True ∨ a = False :=
  match em a with
  | Or.inl ha =&gt; Or.inl (propext (Iff.intro (fun _ =&gt; ⟨⟩) (fun _ =&gt; ha)))
  | Or.inr hn =&gt; Or.inr (propext (Iff.intro (fun h =&gt; hn h) (fun h =&gt; False.elim h)))
# end Hidden
</code></pre>
<p>我们还得到了一个更强的原则，即每个命题都是可决定的。回顾一下，“可决定”命题的定义如下：</p>
<pre><code class="language-lean"># namespace Hidden
class inductive Decidable (p : Prop) where
  | isFalse (h : ¬p) : Decidable p
  | isTrue  (h : p)  : Decidable p
# end Hidden
</code></pre>
<p>与只能消解为 <code>Prop</code> 的 <code>p ∨ ¬ p</code> 不同，类型 <code>Decidable p</code> 等同于和类型 <code>Sum p (¬ p)</code>
，它可以消解为任何类型。正是这个数据类型，使得我们能够编写 if-then-else 表达式。</p>
<p>作为经典推理的一个例子，我们使用 <code>choose</code> 来证明如果 <code>f : α → β</code> 是单射并且 <code>α</code> 是非空的，那么
<code>f</code> 具有一个左逆。为了定义左逆 <code>linv</code>，我们使用了一个依赖的 if-then-else 表达式。回想一下，
<code>if h : c then t else e</code> 是 <code>dite c (fun h : c =&gt; t) (fun h : ¬ c =&gt; e)</code> 的简记法。在定义
<code>linv</code> 中，选择被使用了两次：首先，用来证明 <code>∃ a : A, f a = b</code> 是“可判的”，然后用来选择一个
使得 <code>f a = b</code> 的 <code>a</code>。请注意，<code>propDecidable</code> 是一种局部实例，并且通过 <code>open Classical</code>
命令被激活。我们使用这个实例来证明 if-then-else 表达式的合理性（参见<a href="./type_classes.html#decidable-propositions">可判命题一节</a>中的讨论）。</p>
<pre><code class="language-lean">open Classical

noncomputable def linv [Inhabited α] (f : α → β) : β → α :=
  fun b : β =&gt; if ex : (∃ a : α, f a = b) then choose ex else default

theorem linv_comp_self {f : α → β} [Inhabited α]
                       (inj : ∀ {a b}, f a = f b → a = b)
                       : linv f ∘ f = id :=
  funext fun a =&gt;
    have ex  : ∃ a₁ : α, f a₁ = f a := ⟨a, rfl⟩
    have feq : f (choose ex) = f a  := choose_spec ex
    calc linv f (f a)
      _ = choose ex := dif_pos ex
      _ = a         := inj feq
</code></pre>
<p>从传统的观点来看，“linv”是一个函数。从建设性的观点来看，它是不可接受的；因为通常情况下没有方法可以实现这样的函数，所以这个构造方法是没有信息量的。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
